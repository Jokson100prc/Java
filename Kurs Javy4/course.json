{
  "summary": "Kurs języka Java dla SDA",
  "title": "Kurs Javy",
  "programming_language": "JAVA",
  "language": "en",
  "course_type": "PyCharm",
  "items": [
    {
      "title": "Java podstawowa",
      "id": 0,
      "update_date": "Jan 1, 1970 1:00:00 AM",
      "items": [
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Wstęp",
          "task_list": [
            {
              "name": "Podstawowe wiadomości",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  public static void main(String[] args) {\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eWiadomości wstępne\u003c/h1\u003e\n\u003ch2\u003eLiteratura\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003eKathy Sierra, Bert Bates, Head First Java. Edycja polska (Rusz głową!), Wydanie II. HELION\u003c/li\u003e\n  \u003cli\u003eKrzysztof Barteczko, Java Programowanie praktyczne od podstaw, PWN\u003c/li\u003e\n  \u003cli\u003eHerbert Schildt: „Java. Kompendium programisty”, Wydaw. Helion\u003c/li\u003e\n  \u003cli\u003eMarcin Lis: „Praktyczny kurs Java, Wydanie II”, Wydaw. HELION 2007\u003c/li\u003e\n  \u003cli\u003eCay Horstmann: „Java. Podstawy”, Wydanie X, HELION 2017,\u003c/li\u003e\n  \u003cli\u003eCay Horstmann: „Java. Techniki zaawansowane”, Wydanie X, HELION 2017\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eStrony\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ca href \u003d \"http://www.samouczekprogramisty.pl/kurs-programowania-java/\"\u003eSamouczek programisty\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href \u003d \"https://kobietydokodu.pl/kurs-javy/\"\u003eKobiety do kodu\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Pierwszy program",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  public static void main(String[] args){\n    System.out.println(\"Programowanie w Java\");\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    public static void main(String[] args){\n      System.out.println(\"Programowanie w Java\");\n    }\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cH1\u003ePierwszy program\u003c/H1\u003e\n\u003cp\u003ePierwszy program w języku Java wyświetla komunikat:\u003c/p\u003e\n\u003ccode\u003eclass FirstApp{\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e\u0026nbsp;\u0026nbsp;static public void main(String[] args) {\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;System.out.println(\"Programowanie w Java.\");\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e\u0026nbsp;\u0026nbsp;}\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e}\u003c/code\u003e\u003cbr\u003e\n\u003c/code\u003e\n\u003cH2\u003eKompilacja\u003c/H2\u003e\n\u003cp\u003e\n  Tekst programu musi znajdować się w pliku o nazwie klasy z rozszerzeniem \"java\",\n  czyli nasz program powinien być zapisany w pliku: \u003csamp\u003eFirstApp.java\u003c/samp\u003e\n\u003cp\u003e\n  Program można skompilować w trybie poleceń (menu \u003ccite\u003eStart→Programy→Akcesoria→Wiersz poleceń\u003c/cite\u003e):\n\u003c/p\u003e\n  \u003csamp\u003e\n    javac FirstApp.java\n  \u003c/samp\u003e\n  \u003cp\u003elub\u003c/p\u003e\n  \u003csamp\u003e\n    \"C:\\Program Files\\java\\jdk1.numer_wersji\\bin\\javac\" FirstApp.java\n  \u003c/samp\u003e\n  \u003cp\u003eW wyniku kompilacji powstaje plik \u003ccite\u003eFirstApp.class\u003c/cite\u003e\u003c/p\u003e\n\u003cH2\u003eUruchomienie\u003c/H2\u003e\n\u003cp\u003e\n  Wykonanie programu to wywołanie interpretera JWM, któremu należy wskazać wywoływaną klasę (uwaga na wielkość\n  znaków, nazwa musi być zgodny z nazwą klasy w pliku), nie podajemy rozszerzenia:\n  \u003cblockquote\u003e\n    java FirstApp\n  \u003c/blockquote\u003e\n\u003c/p\u003e\n\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Typy danych",
          "task_list": [
            {
              "name": "Wiadomości",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  public static void main(String[] args){\n    System.out.println(1_000_000_000);\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cH1\u003eTypy danych\u003c/H1\u003e\n\u003cp\u003e\nDla komputera wszystko jest liczbą, która jest zapisana w kodzie binarnym.  Popatrzmy na kilka przykładów:\n\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\n    Obraz to liczby zapisane w postaci tabeli, które oznaczają jakim kolorem wyświetlić dany punkt na obrazie.\n  \u003c/li\u003e\n  \u003cli\u003e\n      Tekst to ciąg liczb, którym przydzielono kolejne znaki alfabetu.\u003c/li\u003e\n  \u003cli\u003e\n    Dźwięk to ciąg liczb, których wartości są wychyleniem membrany głośnika w kolejnych chwilach czasu.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\nTe same wartości liczbowe można przedstawiać w różnych systemach liczbowych np.\ndziesiętnym, dwójkowym, ósemkowym itd. Poniższe równanie wydaję się bezsensowne,\nale może być prawdziwe, jeśli są to cztery różne zapisy tej samej liczby dziesiętnej 15:\n\u003c/p\u003e\n\u003cp\u003e\n \u003csamp\u003e \u003cbr\u003e\n1111 \u003d 15 \u003d 17 \u003d 0F\u003cbr\u003e\n \u003c/samp\u003e\n\u003c/p\u003e\n\u003cp\u003e\nZapis dziesiętny (cyfry od 0 do 9):\n\u003csamp\u003e \u003cbr\u003e\n10\u003csup\u003e1\u003c/sup\u003e 10\u003csup\u003e0\u003c/sup\u003e \u003cbr\u003e\n1  \u0026nbsp;\u0026nbsp;5 \u003d 1*10 + 5*1 \u003d 15 \u003cbr\u003e\n\u003c/samp\u003e\n\u003c/p\u003e\n\u003cp\u003e\nZapis binarny, dwie cyfry (0 i 1):\n \u003csamp\u003e\u003cbr\u003e\n2\u003csup\u003e3\u003c/sup\u003e 4\u003csup\u003e2\u003c/sup\u003e 2\u003csup\u003e1\u003c/sup\u003e 2\u003csup\u003e0\u003c/sup\u003e \u003cbr\u003e\n1\u0026nbsp; 1\u0026nbsp; 1\u0026nbsp; 1 \u003d 1*8 + 1*4 + 1*2 + 1*1 \u003d 15\n \u003c/samp\u003e \u003cbr\u003e\n\u003c/p\u003e\n\u003cp\u003eZapis ósemkowy (cyfry od 0 do 7)\n\u003csamp\u003e \u003cbr\u003e\n8\u003csup\u003e1\u003c/sup\u003e 8\u003csup\u003e0\u003c/sup\u003e\u003cbr\u003e\n1 \u0026nbsp;7 \u003d 1*8 + 7*1 \u003d 15\n \u003c/samp\u003e\u003cbr\u003e\n\u003c/p\u003eZapis szesntastkowy (szestaście cyfr od 0 do F\u003d15)\n\u003csamp\u003e \u003cbr\u003e\n16\u003csup\u003e1\u003c/sup\u003e 16\u003csup\u003e0\u003c/sup\u003e\u003cbr\u003e\n0 \u0026nbsp;\u0026nbsp;F \u003d 0*16 + 15*1 \u003d 15\n\u003c/samp\u003e\u003cbr\u003e\n\u003c/p\u003e\n\u003c/p\u003e\n\u003cp\u003e\nLiczby także dzielimy na dodatnie, ujemne, całkowite, rzeczywiste, wymierne, niewymierne,\nułamki itd.\n\u003c/p\u003e\n\u003cp\u003e\n\u003cstrong\u003eTyp danych\u003c/strong\u003e określa rodzaj liczby (całkowita, rzeczywista), zakres jej wartośći, oraz sposób jej\ninterpretacji. Z zakresem wartości związana jest ilość miejsca w pamieci. Im typ ma większy zakres\n  tym więcej miejsca potrzeba na zapis liczby tego typu.\n\u003c/p\u003e\n\u003cp\u003e\n  Interpretacja oznacza rodzaj umowy, zgodnie z którą należy daną liczbę traktować. Więc nazwa typu będzie swoistym\n  kontraktem, umową. Jednocześnie, w każdej chwili możemy taki typ potraktować jak \"zwykłą\" liczbę,\n  zrywająć kontrakt. W ten sposób liczba może być w jednej chwili znakiem wyświetlanym na ekranie, potem\n  można ją \"zamienić\" na liczbę dziesiętną.\n\u003c/p\u003e\n\u003ch2\u003eRodzaje typów\u003c/h2\u003e\n\u003cp\u003e\n    W języku Java typy dzielimy na dwa podstawowe rodzaje:\n\u003c/p\u003e\n\u003col\u003e\n    \u003cli\u003etypy proste\u003c/li\u003e\n    \u003cli\u003etypy złożone\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eTypy proste to wartości liczbowe, do których możemy się bezpośrednio odwoływać. Jednocześnie typy proste to takie,\n    które mają charakter jednostkowy, co oznacza, że w takim typie możemy przechowywać jedną\n    i tylko jedną wartość.\u003c/p\u003e\n\u003cp\u003e\n    Typy złożone, jak nazwa wskazuje, służą do przehowywania wielu, i to różnych typów, są więc rodzajem pojemnika\n    na różne typy proste i złożone.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Typy całkowite",
              "stepic_id": 0,
              "task_files": {
                "src/IntegerTypes.java": {
                  "name": "src/IntegerTypes.java",
                  "placeholders": [
                    {
                      "offset": 21,
                      "length": 11,
                      "hints": [],
                      "possible_answer": "",
                      "placeholder_text": "10_milionów"
                    },
                    {
                      "offset": 21,
                      "length": 12,
                      "hints": [],
                      "possible_answer": "",
                      "placeholder_text": "10_miliardów"
                    },
                    {
                      "offset": 21,
                      "length": 10,
                      "hints": [],
                      "possible_answer": "",
                      "placeholder_text": "2_binarnie"
                    },
                    {
                      "offset": 21,
                      "length": 10,
                      "hints": [],
                      "possible_answer": "",
                      "placeholder_text": "8_ósemkowo"
                    },
                    {
                      "offset": 21,
                      "length": 15,
                      "hints": [],
                      "possible_answer": "",
                      "placeholder_text": "16_szesnastkowo"
                    }
                  ],
                  "is_visible": true,
                  "text": "class IntegerTypes {\n16_szesnastkowo8_ósemkowo2_binarnie10_miliardów10_milionów\n  public static int getTenM(){\n    return 1;\n  }\n\n  public static long getTenB(){\n    return 1;\n  }\n\n  public static String getBinary(){\n    return \"liczba_binarna\";\n  }\n  public static String getOctal(){\n    return \"liczba_ósemkowa\";\n  }\n\n  public static String getHex(){\n    return \"liczba_szestastkowa\";\n  }\n\n  public static void main(String[] args){\n    System.out.println(getTenM());\n    System.out.println(getTenB());\n    System.out.println(getBinary());\n    System.out.println(getOctal());\n    System.out.println(getHex());\n    System.out.println(9.3e6);\n  }\n}"
                }
              },
              "test_files": {
                "test/IntegerTypesTest.java": "import org.junit.Assert;\nimport org.junit.Test;\n\npublic class IntegerTypesTest {\n\n  @Test\n  public void testSolution() {\n    Assert.assertEquals(IntegerTypes.getTenM(), 10_000_000);\n    Assert.assertEquals(IntegerTypes.getTenB(), 10_000_000_000L);\n    Assert.assertEquals(Integer.parseInt(IntegerTypes.getBinary().substring(2), 2), 2);\n    Assert.assertEquals(Integer.parseInt(IntegerTypes.getOctal(), 8), 8);\n    Assert.assertEquals(Integer.parseInt(IntegerTypes.getHex().substring(2), 16), 16);\n  }\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eTypy całkowite\u003c/h1\u003e\n\u003cp\u003e\n    Typy całkowite służą do przechowywania liczb całkowitych i należą do typów prostych. Do typów całkowityh należą:\n    \u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003ebyte\u003c/code\u003e wartości od -128 do 127, zajmuje 1 bajt\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eshort\u003c/code\u003e wartości od -32768 do 32767, zajmuje 2 bajty\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eint\u003c/code\u003e wartość od ok. -2 10\u003csup\u003e9\u003c/sup\u003e do ok. 2 10\u003csup\u003e9\u003c/sup\u003e zajmuje 4 bajty\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003elong\u003c/code\u003e wartości od ok. -2 10\u003csup\u003e18\u003c/sup\u003e do ok. 2 10\u003csup\u003e18\u003c/sup\u003e zajmuje 8 bajtów\n    \u003c/li\u003e\n    \u003c/ul\u003e\n\u003c/p\u003e\n\u003ch2\u003eLiterały\u003c/h2\u003e\n\u003cp\u003eLiterał to napis reprezentujący bezpośrednio wartość. Liczby typu całkowitego  można zapisywać w kilku\nsystemach liczbowych:\u003c/p\u003e\n\u003cul\u003e\n    \u003cli\u003e\n        w kodzie dziesiętnym np. \u003ccode\u003e12, 234\u003c/code\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        w kodzie dwójkowym np. \u003ccode\u003e0b11001100\u003c/code\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        w kodzie ósemkowy np. \u003ccode\u003e 03, 010\u003c/code\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        w kodzie szesnastkowym np. \u003ccode\u003e0xF3B\u003c/code\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        zapis dziesiętny oznacza typ \u003ccode\u003eint\u003c/code\u003e np. \u003ccode\u003e100\u003c/code\u003e, to znaczy, że literał zajmuje 4 bajty i ma zakres typu int.\n    \u003c/li\u003e\n    \u003cli\u003e\n        zapis dziesiętny z przyrostkiem \u003ccode\u003el\u003c/code\u003e lub \u003ccode\u003eL\u003c/code\u003e oznacza typ \u003ccode\u003elong\u003c/code\u003e np. \u003ccode\u003e100L\u003c/code\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        zapis z separatorem (_) pozwala na grupowanie cyfr w długich literałach np. \u003ccode\u003e1_000\u003c/code\u003e\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eĆwiczenie 1\u003c/h2\u003e\nUzupełnij w pliku \u003csamp\u003eTask.java\u003c/samp\u003e kolejne funkcje \u003ccode\u003eprintln\u003c/code\u003e:\n\u003col\u003e\n    \u003cli\u003e\n        Wpisz liczbę 10 milionów w kodzie dziesiętnym w miejscu napisu \u003csamp\u003e10_milionów\u003c/samp\u003e.\n    \u003c/li\u003e\n    \u003cli\u003e\n        Wpisz liczbę 10 miliardów w kodzie dziesiętnym w miejscu napisu \u003csamp\u003e10_miliardów\u003c/samp\u003e.\n    \u003c/li\u003e\n    \u003cli\u003e\n        Wpisz liczbę 2 w kodzie binarnym w miejscu napisu \u003csamp\u003e2_binarnie\u003c/samp\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        Wpisz liczbę 8 w kodzie ósemkowym w miejscu \u003csamp\u003e8_ósemkowo\u003c/samp\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        Wpisz liczbę 16 w kodzie szestnastkowym w miejscu napisu \u003csamp\u003e16_szestnastkowo\u003c/samp\u003e\n    \u003c/li\u003e\n\u003c/ol\u003e\nW punktach 2\n\u003c/html\u003e\u003cbr\u003e\n\u003cdiv class\u003d\u0027hint\u0027\u003eWykorzystaj znak _ do grupowania cyfr w dużych liczbach.\u003c/div\u003e\n\u003cdiv class\u003d\u0027hint\u0027\u003eWykorzystaj typ long do tak dużej liczby.\u003c/div\u003e\n\u003cdiv class\u003d\u0027hint\u0027\u003eZapis binarny zaczynamy ciągiem 0b. Liczba 4 binarnie to 0b100\u003c/div\u003e\n\u003cdiv class\u003d\u0027hint\u0027\u003eZapis w kodzie ósemkowym zaczynamy od 0 np. 012 to liczba 10.\u003c/div\u003e\n\u003cdiv class\u003d\u0027hint\u0027\u003eZapis szesnastkowy ropoczyna 0x np. 0x0A to 10\u003c/div\u003e\n\u003cbr\u003e\n",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Typy rzeczywiste",
              "stepic_id": 0,
              "task_files": {
                "src/RealTypes.java": {
                  "name": "src/RealTypes.java",
                  "placeholders": [
                    {
                      "offset": 63,
                      "length": 15,
                      "hints": [],
                      "possible_answer": "1",
                      "placeholder_text": "10 do potęgi 30"
                    },
                    {
                      "offset": 130,
                      "length": 21,
                      "hints": [],
                      "possible_answer": "1",
                      "placeholder_text": "0,1234 jako typ float"
                    }
                  ],
                  "is_visible": true,
                  "text": "class RealTypes {\n\n  public static double getBig(){\n    return 10 do potęgi 30;\n  }\n\n  public static float getSmall(){\n    return 0,1234 jako typ float;\n  }\n\n  public static void main(String[] args){\n    System.out.println(getBig());\n    System.out.println(getSmall());\n  }\n}"
                }
              },
              "test_files": {
                "test/RealTypesTest.java": "import org.junit.Assert;\nimport org.junit.Test;\n\npublic class RealTypesTest {\n\n  @Test\n  public void testSolution() {\n    Assert.assertEquals(RealTypes.getBig(), 10e30, Math.ulp(10e30));\n    Assert.assertEquals(RealTypes.getSmall(), 0.1234f, Math.ulp(0.1234f));\n  }\n}"
              },
              "description_text": "\u003cp\u003e\n\u003ch1\u003eTypy rzeczywiste\u003c/h1\u003e\n\u003cp\u003eTypy rzeczywiste służa do przechowywania liczb rzeczywistych w zapisie dziesiętnym. Dostępne są dwa typy proste\n  do tego typu liczb:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\n    \u003ccode\u003efloat\u003c/code\u003e, który ma zakres od ok. - 3,4 10\u003csup\u003e38\u003c/sup\u003e do 3,4 10\u003csup\u003e38\u003c/sup\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003ccode\u003edouble\u003c/code\u003e, który ma zakres od ok. - 1,7 10\u003csup\u003e308\u003c/sup\u003e do 1,7 10\u003csup\u003e308\u003c/sup\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n  \u003cp\u003e\n    Literały do zapisu liczb rzeczywistych tworzymy wg poniższych reguł:\n  \u003c/p\u003e\n    \u003cul\u003e\n    \u003cli\u003e\n      miejsce dziesiętne oznaczmay kropką np. \u003ccode\u003e2.45\u003c/code\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n      duże liczby można zpaisywać w notacji naukowej np. \u003ccode\u003e 9.3e6 \u003d 9300000\u003c/code\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n      domyślnie powyższe zapisy są traktowane jako liczby typu \u003ccode\u003edouble\u003c/code\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n      literały z przyrostkiem \u003ccode\u003ef\u003c/code\u003e lub \u003ccode\u003eF\u003c/code\u003e oznaczają wartości typu \u003ccode\u003efloat\u003c/code\u003e\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/p\u003e\n\u003ch2\u003eĆwiczenie 1\u003c/h2\u003e\n\u003cul\u003e\n \u003cli\u003e\n   W miejscu napisu \u003csamp\u003e10 do potęgi 30\u003c/samp\u003e wpisz taką właśnie liczbę\n \u003c/li\u003e\n  \u003cli\u003e\n    W miejscu napisu \u003csamp\u003e0,1234\u003c/samp\u003e wpisz taką wartość typu \u003ccode\u003efloat\u003c/code\u003e.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003c/html\u003e\u003cbr\u003e\n\u003cdiv class\u003d\u0027hint\u0027\u003eWykorzystaj zapis naukowy.\u003c/div\u003e\n\u003cdiv class\u003d\u0027hint\u0027\u003eStosuj przyrostek do oznaczania typu float.\u003c/div\u003e\n\u003cbr\u003e\n",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Typ znakowy",
              "stepic_id": 0,
              "task_files": {
                "src/CharType.java": {
                  "name": "src/CharType.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class CharType {\n  static public void main(String[] args){\n    //Ćwiczenie 1\n    System.out.println(\u0027 \u0027);\n    //Ćwiczenie 2\n    System.out.print(\u0027 \u0027);\n    System.out.print(\u0027 \u0027);\n    System.out.print(\u0027 \u0027);\n    System.out.print(\u0027 \u0027);\n    System.out.print(\u0027 \u0027);\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eTyp znakowy\u003c/h1\u003e\n\u003cp\u003e\n  Do przechowywania znaków alfanumerycznych w Unicode służy typ char. Zajmuje on 2 bajty i przyjmuje wartości\nod 0 do 65535. Literały tego typu tworzymy poprzez:\n  \u003cul\u003e\n  \u003cli\u003e\n    pojedyncze znaki w apostrofach np. \u0027a\u0027, \u0027C\u0027, \u0027\u003c\u0027\n  \u003c/li\u003e\n  \u003cli\u003e\n    znaki specjalne w apostrofach:\n    \u003cul\u003e\n      \u003cli\u003e\n        \u0027\\n’ - nowy wiersz\n      \u003c/li\u003e\n      \u003cli\u003e\n        \u0027\\t\u0027 - tabulator\n      \u003c/li\u003e\n      \u003cli\u003e\n        \u0027\\r\u0027 - powrót karetki\n      \u003c/li\u003e\n      \u003cli\u003e\n        \u0027\\b\u0027 - backspace\n      \u003c/li\u003e\n      \u003cli\u003e\n        \u0027\\f\u0027 - wysunięcie\n      \u003c/li\u003e\n      \u003cli\u003e\n        \u0027\\\\\u0027 - znak ukośnika \\\n      \u003c/li\u003e\n      \u003cli\u003e\n        \u0027\\\u0027\u0027 - znak apostrofu \u0027\n      \u003c/li\u003e\n      \u003cli\u003e\n        \u0027\\\"\u0027 - znak podwójnego apostrofu \"\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    kod szesnastkowy Unicode w apostrofach np. ‘\\u006E’ (litera n)\n    (Uwaga! w taki sposób nie wolno podawać znaków CR i LF, zamiast tego podajemy ‘\\n’, ‘\\r’)\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\n\u003ch2\u003eĆwiczenie 1\u003c/h2\u003e\n\u003cp\u003e\n    Korzystając z aplikacji Tablica znaków (Akcesoria) odszukaj znak  greckiej litery alfa i wyświetl go\n    korzystając z jego unikodu.\n\u003c/p\u003e\n\u003ch2\u003eĆwiczenie 2\u003c/h2\u003e\n\u003cp\u003e\nKorzystając tylko z wywołania \u003ccode\u003eSystem.out.print()\u003c/code\u003e wyświetl poniższy obrazek:\u003cbr\u003e\n    /\\\u003cbr\u003e\n    \\/\u003cbr\u003e\n\u003c/p\u003e\n\u003ch2\u003eUwaga\u003c/h2\u003e\nWykonane ćwiczenia samodzielnie oceniamy. Nie naciskamy przycisku Check.\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Typ logiczny",
              "stepic_id": 0,
              "task_files": {
                "src/BooleanType.java": {
                  "name": "src/BooleanType.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class BooleanType {\n  static public void main(String[] args){\n    System.out.println(true);\n    System.out.println(false);\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eTyp logiczny\u003c/h1\u003e\nTyp logiczny \u003ccode\u003eboolean\u003c/code\u003e służy do przechowywania tylko dwóch wartości reprezentowanych przez dwa słowa kluczowe: \u003ccode\u003etrue\u003c/code\u003e i\n\u003ccode\u003efalse\u003c/code\u003e. Typ ten zajmuje 1 bajt.\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Zmienne",
              "stepic_id": 0,
              "task_files": {
                "src/Variables.java": {
                  "name": "src/Variables.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Variables{\n\n  static public void main(String[] args){\n    int   n     \u003d 10;\n    float kwota \u003d 12.89f;\n    char  znak  \u003d \u0027A\u0027;\n    System.out.println(n);\n    System.out.println(kwota);\n    System.out.println(znak);\n    System.out.println(stan);\n    boolean stan \u003d true;\n    {\n      int a \u003d 5;\n    }\n    System.out.println(a);\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003c\u003e\n\u003ch1\u003eZmienne\u003c/h1\u003e\n\u003cp\u003e\nNie ma programu bez zmiennych. Zmienną można porównać do pojemnika, w którym można coś przechować.\nMożna pojemnik całkowicie zapełnić, można trzymać pusty lub wypełnić w części.\nMogą być pojemniki, w których można trzymać różne towary np. mąkę, cukier, mleko,\nsą takie w których można trzymać tylko jeden rodzaj zawartości np. tylko płyny.\n\u003c/p\u003e\n\u003cp\u003e\nW programie zmienną jest wydzielony obszar pamięci, w której można zapisać dowolną wartość, pod warunkiem,\n    że ta wartość jest zgodna z typem zmiennej. Zmienna ma swoją nazwę – identyfikator,\n    który musi być zbudowany zgodnie z pewnymi regułami:\n    \u003cul\u003e\n    \u003cli\u003e\n        nazwa zmiennej nie może być identyczna ze słowem kluczowym języka JAVA czyli: \u003cbr\u003e\n        \u003ccode\u003e\n            abstract default if package synchronized assert do implements private\n            this boolean double import protected throw break else instanceof public\n            throws byte extends int return transient case false interface short true\n            catch final long static try char finally native\n            strictfp void class float new super volatile const for null switch while continue goto\n        \u003c/code\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        nie może zaczynać się od znaku cyfry,\n    \u003c/li\u003e\n    \u003cli\u003e\n        może zawierać znaki alfabetu a-z i A-Z, cyfry 0-9, znak podkreślenia _ i znak dolara $,\n    \u003c/li\u003e\n    \u003cli\u003e\n        rozróżniane są wielkie i małe litery.\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\nPrzykładowe poprawne nazyw zmiennych: \u003cbr\u003e\n    \u003cul\u003e\n    \u003cli\u003e\u003csamp\u003eliczba\u003c/samp\u003e\u003c/li\u003e\n    \u003cli\u003e\u003csamp\u003eliczba_01\u003c/samp\u003e\u003c/li\u003e\n    \u003cli\u003e\u003csamp\u003eliczba$\u003c/samp\u003e\u003c/li\u003e\n    \u003cli\u003e\u003csamp\u003eLiczba\u003c/samp\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Niepoprawnymi nazwami zmiennych są:\n    \u003cul\u003e\n    \u003cli\u003e\u003csamp\u003e0liczba\u003c/samp\u003e - zaczyna się od cyfry\u003c/li\u003e\n    \u003cli\u003e\u003csamp\u003e@iczba\u003c/samp\u003e - zawiera niedozwolony znak @\u003c/li\u003e\n    \u003cli\u003e\u003csamp\u003ećma\u003c/samp\u003e- zawiera polski znak diakrytyczny\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003ch2\u003eDeklarowanie zmiennych\u003c/h2\u003e\n\u003cp\u003e\n    Deklaracja zmiennej to inaczej wprowadzenie nazwy zmiennej w programie, a także związanie jej z typem.\n    Po zadeklarowaniu nasza zmienna będzie zajmowała odpowiedni obszar pamięci, której zawartość\n    będzie interpretowana zgodnie z jej typem. Po zadeklarowaniu można zmiennej przypisać dowolną\n    wartość zgodną z typem i można te operację dowolnie powtarzać.\n    Na razie zmienne będziemy deklarować wg schematu:\u003c/p\u003e\n\u003cp\u003e\n\u003csamp\u003e\n    typ_danych nazwa_zmiennej;\u003cbr\u003e\n\u003c/samp\u003e\n\u003c/p\u003e\n    np.\n\u003cp\u003e\n    \u003ccode\u003echar znak; \u003c/code\u003e \u003cbr\u003e\n    \u003ccode\u003eint kwota;\u003c/code\u003e \u003cbr\u003e\n    \u003ccode\u003efloat temperatura;\u003c/code\u003e \u003cbr\u003e\n    \u003ccode\u003eboolean isValid;\u003c/code\u003e \u003cbr\u003e\n\u003c/p\u003e\n    \u003cp\u003e\n    Można połączyć deklarację z nadaniem zmiennej wartości początkowej tzw. inicjalizacją.\n        Korzystamy wtedy z poznanych literałów i znaku równości \u003d:\u003c/p\u003e\n\n\u003ccode\u003echar znak \u003d ’a’;\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eint kwota \u003d 100; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003efloat temperatura \u003d 36.8f; \u003c/code\u003e \u003cbr\u003e\n\u003ccode\u003eboolean isValid \u003d false;\u003c/code\u003e\u003cbr\u003e\n\u003cp\u003e\n    Wartości umieszczone po znaku równości to poznane wześniej literały. Należy pamiętać, aby stosować literały\n    typu zgodnego z typem zmiennej.\n\u003c/p\u003e\n\u003cp\u003e\n    Deklaracje zmiennych można umieszczać w dowolnym miejscu bloku programu, trzeba jednak pamiętać, że:\n    \u003cul\u003e\n    \u003cli\u003ezmienna istnieje tylko dla kodu programu położonego za miejscem jej deklaracji,\n        czyli najpierw deklarujemy potem używamy,\u003c/li\u003e\n\n    \u003cli\u003ezmienna jest widoczna tylko w bloku jej deklaracji, czyli można ją odczytać lub zmienić\n        tam, gdzie jest zadeklarowana,\n    \u003c/li\u003e\n    \u003cli\u003e\n    gdy kod naszego programu opuszcza blok to zmienna przestaje istnieć.\n    \u003c/li\u003e\n    \u003c/ul\u003e\n    \u003c/code\u003e\n\u003ch3\u003ePrzykłady\u003c/h3\u003e\n\u003cp\u003eNiepoprawna kolejność, nie można odwoływać się do zmiennej przed jej deklaracją: \u003c/p\u003e\n\u003ccode\u003eSystem.out.println(liczba);\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eint liczba \u003d 10;\u003c/code\u003e\u003cbr\u003e\n\u003cp\u003eZmienna zadeklarowana w bloku po jego opuszczeniu przestaje istnieć, więc nie wolno do niej się odwoływać poza nim\n\u003c/p\u003e\n\u003ccode\u003e{\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eint liczba \u003d 10;\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e}\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eSystem.out.println(liczba);\u003c/code\u003e\u003cbr\u003e\n\u003ch2\u003eĆwiczenie 1\u003c/h2\u003e\n\u003cP\u003eZmień kolejność dwóch wierszy kodu w Variables.java, aby program się skompilował.\u003c/P\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Operatory i wyrażenia",
          "task_list": [
            {
              "name": "Wiadomości",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eWiadomości wstępne\u003c/h1\u003e\n\u003cp\u003eWyrażenie to ciąg operatorów i wartości, które zwracają także wartość. Operatorami są symbole operacji\n  np. arytmetycznych jak dodawanie \u0027+\u0027, a wartościami moga być liczby, które dodajemy.\u003c/p\u003e\n\u003ccode\u003e2 + 3\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e2 + a\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e2 + funkcja()\u003c/code\u003e\u003cbr\u003e\n\u003cp\u003eWartościami w wyrażeniach moga być zmienne, literały, inne wyrażenia czy funkcje (które poznanmy później), czyli wszystkie\n  te elementy języka, które reprezentują wartości zgodnych typów. Oznacza to, że dodawać możemy tylko wartości liczbowe,\nale nie można do liczby dodać typu boolean. Łączyć możemy łańcuchy z wartościami liczbowymi, ale nie możemy\nmnożyć łańcuchów.\u003c/p\u003e\n\u003cp\u003eWartości w wyrażeniach nazywane są operandami. Liczba wymaganych operandów określa rodzaj operatora, stąd mamy\n  operatory:\n\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\n    unarne\n  \u003c/li\u003e\n  \u003cli\u003e\n    binarne\n  \u003c/li\u003e\n  \u003cli\u003e\n    ternarne\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNajwięcej jest operatorów binarnych, czyli takich które wymagają dwóch operandów,\n  ale są także operatory unarne (z jednym operandem) i ternarne (z trzema operandami).\u003c/p\u003e\n\u003cp\u003e\n  Umiejscowienie operatora względem operandów decyduje o jego rodzaju, stąd rozróźnia się:\n\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eprefiksowe - gdy operator występuje przed operandem np. +5\u003c/li\u003e\n  \u003cli\u003einfiksowe - gdy operator znajduje się miedzy operandami np. 2+4\u003c/li\u003e\n  \u003cli\u003epostfiksowe - gdy operator znajduje się za operandem np. i++\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOperatory posiadają priorytet, który określa w jakiej kolejności są wykonywane działania w wyrażeniu.\nJeśli operator * ma wyższy priorytet od + to w wyrażeniu \u003csamp\u003e 2*4+5\u003c/samp\u003e wykonane zostanie najpierw\n  działanie \u003csamp\u003e 2*4\u003c/samp\u003e, a potem dodawanie \u003csamp\u003e(2*4)+5.\u003c/samp\u003e\u003c/p\u003e\n\u003cp\u003e\n  Operatory określone mają także wiązanie, czyli kolejność jego operandów. Dzięki\n  wiązaniu można jednoznacznie zinterpretować wyrażenie w sytuacji, gdy występują operatory o\n  takim samym priorytecie np. w wyrażeniu \u003csamp\u003e2+5-4\u003c/samp\u003e przy lewostronnym wiązaniu wyrażenie zostanie zinterpretowane\n  jako \u003csamp\u003e(2+5)-4\u003c/samp\u003e. Dla wiązania prawostronnego otrzymalibyśmy \u003csamp\u003e2+(5-4)\u003c/samp\u003e\u003c/p\u003e\n\u003cp\u003eDo grupowamia wyrażeń i jawnego określania priorytetu możemy stosować nawiasy okrągłe \u003csamp\u003e()\u003c/samp\u003e.\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Operatory arytmetyczne",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eOperatory arytmetyczne\u003c/h1\u003e\n\u003cH2\u003eOperatory binarne\u003c/H2\u003e\nSą to głównie operatory powszechnie znane, realizujące podstawowe operacje takie jak:\n\u003cul\u003e\n \u003cli\u003e\n     dodawanie liczb i łańcuchów: \u003csamp\u003e+\u003c/samp\u003e\n \u003c/li\u003e\n  \u003cli\u003e\n    odejmowanie liczb: \u003csamp\u003e-\u003c/samp\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n      mnożenie liczb: \u003csamp\u003e*\u003c/samp\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n      dzielenie liczb: \u003csamp\u003e/\u003c/samp\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePriorytet dzielenia i mnożenia jest wyższy od dodawania i odejmowania. Wszystkie mają wiązanie lewostronne.\u003c/p\u003e\n\u003cp\u003eOperator dzielenia zwraca typ wyniku zgodny z typem operandów np. \u003csamp\u003e 10/3\u003c/samp\u003e zwróci wartość \u003csamp\u003e3\u003c/samp\u003e, bo\n    oba operandy są typu całkowitego więc i wynik jest całkowity. Jest to dzielenie całkowite. Dla \u003csamp\u003e 10/3.0\u003c/samp\u003e wynikiem będzie \u003csamp\u003e3.33333\u003c/samp\u003e,\nbo jeden z operandów jest typu zmiennoprzecinkowego.\u003c/p\u003e\n\n\u003cp\u003e Z dzieleniem całkowitym związany jest operator modulo \u003csamp\u003e%\u003c/samp\u003e, którego zadaniem jest wyznaczenie reszty\n    z dzielenia całkowitego. Wyrażenie \u003csamp\u003e10%3\u003c/samp\u003e zwróci wartość 1, gdyż w wyniku dzielenia 10/3 otrzymamy 3 i 1\n    reszty. \u003c/p\u003e\n\u003ch2\u003eInkrementacja i dekrementacja\u003c/h2\u003e\n\u003cp\u003eSą dwa operatory unarne występujce w dwóch formach:\u003c/p\u003e\n\u003cul\u003e\n    \u003cli\u003e\n        inkrementacja prefiksowa - zwiększenie o 1 \u003csamp\u003e++a\u003c/samp\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        inkrementacj postfiksowa - zwiększenie o 1 \u003csamp\u003ea++\u003c/samp\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        dekrementacja prefiskowa - zmniejszenie o 1 \u003csamp\u003e--a\u003c/samp\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        dekrementacja postfiksowa - zmniejszenie o 1 \u003csamp\u003ea--\u003c/samp\u003e\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOperandem moży być wyłącznie tzw. modyfikowalna l-wartość, co oznacza, że może to być wyłącznie zmienna typu\n    prostego liczbowego np.\n\u003c/p\u003e\n\u003ccode\u003e int a \u003d 10;\u003c/code\u003e \u003cbr\u003e\n\u003ccode\u003e a++; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e System.out.println(a);\u003c/code\u003e \u003cbr\u003e\u003cbr\u003e\n\u003csamp\u003e-11\u003c/samp\u003e\n\n\u003cp\u003eRóżnica miedzy postacią post- i prefiksową polega na wykonaniu modyfikacji operandu. W przypadku\n    postaci prefiksowej modyfikacja jest wykonywana jako pierwsza np:\u003c/p\u003e\n\u003ccode\u003eint a \u003d 10;\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eint b \u003d ++a + 5; \u003c/code\u003e\u003cbr\u003e\n\u003cp\u003ezmienna \u003ccode\u003eb\u003c/code\u003e będzie miała wartość 16, gdyż przed wykonaniem przypisania wartości nastąpi zwiększenie\n    \u003ccode\u003ea\u003c/code\u003e o 1, a dopiero potem obliczenia wyrażenia \u003ccode\u003ea + 5\u003c/code\u003e, czyli 11+5 \u003d 16\u003c/p\u003e\n\u003cp\u003ePostać postfiksowa powoduje modyfikację zmiennej na samym końcu opracowania wyrażenia np.:\u003c/p\u003e\n\u003ccode\u003eint a \u003d 10;\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eint b \u003d a-- + 5; \u003c/code\u003e\u003cbr\u003e\n\u003cp\u003ezmienna \u003ccode\u003eb\u003c/code\u003e będzie miała wartość 15, gdyż najpierw zostanie obliczone wyrażenie \u003ccode\u003ea + 5\u003c/code\u003e\n    i przypisana wartość do zmiennej \u003ccode\u003eb\u003c/code\u003e, a na końcu zmienna \u003ccode\u003ea\u003c/code\u003e zmniejszona o 1.\u003c/p\u003e\n\n\n",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Operatory przypisania",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eOperatory przypisania\u003c/h1\u003e\n\u003cp\u003ePodstawowym operatorem przypisania jest poznany już symbol równości \u003csamp\u003e\u003d\u003c/samp\u003e. Służy do\n  przeniesienia wartości operandu z prawej strony znaku \u003ccode\u003e\u003d\u003c/code\u003e do operandu po lewej. Z tego też względu lewy operand musi\n  być modyfikowalną l-wartością, czyli zmienną.\u003c/p\u003e\n\u003ccode\u003eint a \u003d 10;\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003ea \u003d a + 5 * a\u003c/code\u003e\u003cbr\u003e\n\u003cp\u003e Zmienna \u003ccode\u003ea\u003c/code\u003e po przypisaniu będzie miała wartość 60.\u003c/p\u003e\n\u003cp\u003ePowyższy przykład ilustruje dość często występującą modyfikację zmiennej o wartość wyrażenia z jej udziałem.\nKrótszy zapis takiej modyfikacji można uzyskać stosując operatory przypisania połączone z operatorami arytmetycznymi:\n\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ccode\u003ea +\u003d b\u003c/code\u003e, który odpowiada zapisowi \u003ccode\u003ea \u003d a + b\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003ea -\u003d b\u003c/code\u003e, który odpowiada zapisowi \u003ccode\u003ea \u003d a - b\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003ea *\u003d b\u003c/code\u003e, który odpowiada zapisowi \u003ccode\u003ea \u003d a * b\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003ea /\u003d b\u003c/code\u003e, który odpowiada zapisowi \u003ccode\u003ea \u003d a / b\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003ea %\u003d b\u003c/code\u003e, który odpowiada zapisowi \u003ccode\u003ea \u003d a % b\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Operatory logiczne i relacji",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eOperatory logiczne i relacji\u003c/h1\u003e\n\u003cp\u003eOperatory te służą do tworzenia wyrażeń zwracających wartość logiczną. Do \u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Podstawy programowania obiektowego",
          "task_list": [
            {
              "name": "Klasa",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cH1\u003eKlasa\u003c/H1\u003e\n\u003cp\u003e\nKlasa jest podstawowym i jedynym typem złożonym w Java. Określenie złożony dotyczy sytuacji, gdy zmienna\npozwala na przechowywanie wielu wartości różnych typów, zarówno prostych i złożonych.\nKlasa to także jedyne miejsce, w którym można umieszczać kod wykonywalny, więc każda instrukcja\nmusi być umieszczona w jakiejś klasie.\u003c/p\u003e\n\u003cp\u003e\nZ pojęciem klasy wiąże się także inne określenie - obiekt. Związek między klasą a obiektem jest taki jak między\n  planem budowy a budynkiem, schematem elektrycznym a komputerem itd. Klasa jest opisem budowy,\n  schematem konstrukcji i specyfikacją zachowań wszystkich obiektów, które będą tworzone na podstawie klasy.\n\u003c/p\u003e\n\u003cp\u003e\nObiekt to konkretny przedstawiciel rodziny obiektów, które mają wspólny opis w postaci klasy. Zatem klasa\nbędzie opisywać jakie cechy (np. kolor, długość) i zachowania (otwórz, zamknij, wyślij itd.) będą miały\nobiekty a obiekt posiada zestaw indywidualnych wartości tych cech (kolor: zielony, długość: 10).\n\u003c/p\u003e\n\u003cp\u003e\nDefinicja klasy zaczyna się od słowa kluczowego \u003ccode\u003eclass\u003c/code\u003e, po którym podajemy nazwę klasy:\n\u003c/p\u003e\n\u003cpre\u003e\u003csamp\u003e\n  class nazwa-klasy{\n    lista-definicji-pól\n    lista-definicji-metod\n  }\u003c/samp\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nW nawiasach klamrowych umieszcza się dwie listy: lista definicji (można też deklaracje) pól,\n  czyli zmiennych, które będą jakoś opisywać cechy obiektów, oraz lista definicji funkcji,\n  które nazywane są metodami, opisujących zachowania obiektów. Listy te nie muszą występować w\n  takiej kolejności, można przeplatać jedną listę z drugą np. pole 1, metoda2, pole3, metoda4 itd.\n  Jednak ze względu na czytelność jest powszechnie przyjęte stosowanie takiej kolejności i wydzielanie\n  osobno pól i metod.\n\u003c/p\u003e\n\u003cp\u003e\nKażda klasa jest definiowana w osobnym pliku, który musi mieć nazwę identyczną z nazwą klasy.\n  Rozszerzeniem plików źródłowych Javy jest \u003csamp\u003e.java\u003c/samp\u003e.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Pola",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003ePOLA\u003c/h1\u003e\n\u003cp\u003e\nZacznijmy od prostej klasy zawierającej tylko pola. Pole często jest także utożsamiane z atrybutem lub stanem.\n  Atrybut to jakaś dana charakteryzująca obiekt, gdy stan to zazwyczaj zmienna informująca o kondycji obiektu,\n  co często przekłada się na jego zachowanie. \u003c/p\u003e\n\u003cp\u003eTypowy przykład klasy, która jest wymagana w większości aplikacji czyli osoba, użytkownik, klient,\n  konsument itp.: \u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003e\n  class Person{\n    String firstName;\n    String lastName;\n    String education;\n    String address;\n    int height;\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  Utworzenie obiektu typu Person polega na zastosowaniu wspomnianego wcześniej operatora \u003csamp\u003enew\u003c/samp\u003e: \u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003e\n  Person user \u003d new Person();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\nObiekt został utworzony jako zmienna user typu \u003csamp\u003ePerson\u003c/samp\u003e, czyli dokładnie wg poznanego już schematu\n  deklaracji zmiennych typów prostych. Jednocześnie została ta zmienna zainicjowana wartością czyli został\n  przydzielony obszar pamięci na wszystkie pola. Wartości tych pól, czyli \u003csamp\u003efirstName, lastName \u003c/samp\u003eitd.\n  będą równe \u003csamp\u003enull\u003c/samp\u003e lub 0. Obiekty nazywane są także instancjami klasy.\u003c/p\u003e\n\u003cp\u003e\n  Odwołanie się do pól obiektu odbywa się przez operator dostępu w postaci kropki: \u003c/p\u003e\n  \u003cpre\u003e\u003ccode\u003e\n  user.firstName \u003d ”Adam”;\n  user.height \u003d 175;\n  System.out.prinln(“imię” + user.firstName);\n  \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\nSiła obiektów polega na zgromadzeniu wszystkich powiązanych ze sobą, a jednocześnie różnorodnych, informacji\n  w jednym miejscu.\n  W ten sposób nie można pomylić np. wzrostu Kowalskiego ze wzrostem Nowaka\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Metody",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003cbr\u003e\n\u003ch1\u003eFUNKCJA\u003c/h1\u003e\n\u003cp\u003e\nObiekt może posiadać także zbiór zachowań, które są metodami klasy. W przeciwieństwie do pól, wszystkie metody\n  danej klasy są wspólne dla obiektów.\u003c/p\u003e\n\u003cp\u003e\nCzym jest metoda? Metoda to szczególny rodzaj funkcji, czyli podprogramu. Podprogram, jak nazwa sugeruje to jakiś\n  fragment kodu programu, który często się powtarza. Porównując program do książki, podprogramem może być ciągle\n  powtarzający się cytat z innej książki. Jeśli za każdym razem w treści książki występowałaby treść takiego cytatu,\n  to objętość książki by rosła. Dodatkowo podczas składu książki istniałaby możliwość, że przy kolejnym cytowaniu\n  może wystąpić pomyłka. Zamiast tego można umieścić tylko odnośnik informujący, gdzie ten cytat został przytoczony\n  pierwszy raz. Wtedy każde wystąpienia takiego odnośnika byłoby wywołaniem podprogramu, numer strony z cytatem\n  byłby adresem podprogramu w pamięci.\u003c/p\u003e\n\u003cp\u003e\nWróćmy teraz do pojęcia funkcji, która jest szczególnym podprogramem. Po pierwsze może posiadać tzw.\n  argumenty oraz może zwracać wartość, podobnie jak znane funkcje matematyczne. Argumentami i wartością\n  zwracaną mogą być poznane dotąd typy, w tym także klasy.\u003c/p\u003e\n\u003cp\u003e\n  Na razie będziemy definiować funkcje (metody) zgodnie ze schematem:\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003e\n  typ-zwracany nazwa-funkcji(lista-parametrów){\n    lista-deklaracji-zmiennych-lokalnych\n    lista-instrukcji\n  }\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\nTutaj także kolejność obu list jest dowolna, przeplatanie definicji zmiennych z instrukcjami jest możliwe.\n  Dodatkowo wskazane jest deklarowanie zmiennych lokalnych tuż przed miejscem ich wykorzystania, w podblokach,\n  które ograniczają zasięg. Grupowanie zmiennych i instrukcji w funkcji nie ma znaczenia, ważne\n  aby kod był czytelny, spójny i zwięzły.\u003c/p\u003e\n\u003cp\u003e\nLista parametrów nie jest obowiązkowa. Jeśli występuje to lista ma postać deklaracji parametrów: \u003c/p\u003e\n\u003cpre\u003e\n\u003csamp\u003e\n  typ nazwa-parametru-1, typ nazwa-parametru-2, …\n\u003c/samp\u003e\u003c/pre\u003e\n\u003cp\u003e\nNależy też odróżniać termin parametr od argumentu. Parametr to zmienna, której używamy podczas definiowania funkcji,\n  gdy piszemy jej ciało. Argument to wartość przekazywana podczas wywołania funkcji. \u003c/p\u003e\n\u003ch1\u003eRETURN\u003c/h1\u003e\n\u003cp\u003e\nZ funkcją związany jest trzeci rodzaj skoku bezwarunkowego czyli instrukcja return. Dodatkowo instrukcja\n  ta może posiadać argument, który jest wartością zwracaną przez funkcję. Popatrzmy na prostą funkcję\n  dodającą dwie liczby:\n\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003e\n  int add(int a, int b) {\n    return a + b;\n  }\n  \u003c/code\u003e\u003c/pre\u003e\n\n  \u003cp\u003e\nFunkcja jest zdefiniowana dla dwóch parametrów typu całkowitego (a, b) i zwraca liczbę całkowitą.\n    Zgodnie z nazwą powinna zwrócić sumę obu argumentów dlatego mamy wyrażenie a+b poprzedzone instrukcją return,\n    która zwróci sumę.\n  \u003ch1\u003eVOID\u003c/h1\u003e\n  \u003cp\u003e\nJeśli nie chcemy wartości zwracanej przez funkcję to wtedy można zastosować typ void, który sygnalizuje\n    ignorowanie wartości funkcji. Przykładem będzie funkcja wyświetlająca elementy tablicy: \u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  void printArray(int[] arr){\n    for(int item: arr) {\n      System.out.prinln(item);\n    }\n  }\n  \u003c/code\u003e\u003c/pre\u003e\n  \u003cp\u003e\n    Brak instrukcji \u003csamp\u003ereturn\u003c/samp\u003e nie jest wymogiem dla funkcji, która nie zwraca wartości.\n    W takich funkcjach też można jej używać, ale bez argumentu. Poniższy przykład to modyfikacja poprzedniej\n    funkcji, która nie wyświetla tabeli jeśli jej rozmiar jest zbyt duży:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n  void printArray(int[] arr){\n    if (array.length \u003e 100)\n      return;\n    for(int item: arr) {\n      System.out.prinln(item);\n    }\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  W instrukcji \u003csamp\u003eif\u003c/samp\u003e znajduje się wywołanie \u003csamp\u003ereturn\u003c/samp\u003e, które spowoduje skok na koniec\n  funkcji i tym samym pominięcie całej pętli. Ponieważ nie ma argumentu nie zwróci wartości.\u003c/p\u003e\n\u003ch1\u003eMETODY I THIS\u003c/h1\u003e\n\u003cp\u003e\nMetoda to funkcja, która opisuje zachowanie danego obiektu. Dobrze zdefiniowana metoda powinna operować wyłącznie\n  na polach obiektu i swoich argumentach. Nie musi zawsze zwracać wartości i wtedy będzie zachowywać się jak procedura\n  z innych języków programowania. W języku Java można definiować wyłącznie funkcje, które są metodami jakiejś klasy.\u003c/p\u003e\n\u003cp\u003e\nPierwszym przykładem będzie zdefiniowanie tzw. getterów i setterów. Choć obecnie są głosy, że settery i gettery\n  są zbędne, to jest to technika nadal stosowana. Nazwa getter wzięła się od polecenia get czyli pobierz\n  a setter od set - ustaw. Ich zadaniem jest ustawianie i pobieranie wartości pól. \u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003e\n  class Person{\n    String firstName;\n    String lastName;\n    String education;\n    String address;\n    int height;\n\n    String getFirstName(){\n      return this.firstName;\n    }\n\n    void setFirstName(String firstName){\n      this.firstName \u003d firstName;\n    }\n  }\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\n  Pierwsza metoda nie posiada parametrów. Wykonuje tylko jedną czynność zwraca pole \u003csamp\u003efirstName\u003c/samp\u003e rozkazem\n  \u003csamp\u003ereturn\u003c/samp\u003e.\n  Zmienna \u003csamp\u003ethis\u003c/samp\u003e jest słowem kluczowym, które wskazuje na instancję klasy. Jest to trochę mylące,\n  bo definiujemy klasę,\n  jednak należy pamiętać, że metody są dzielone między wszystkie obiekty tej samej klasy. Definiując więc klasę musimy\n  sobie wyobrażać, jak ta funkcja będzie się wykonywać “na obiekcie”. Zmienna \u003csamp\u003ethis\u003c/samp\u003e jest takim właśnie\n  referencją na konkretny obiekt, który wywołuje metodę. Inaczej mówiąc, gdy wywołamy metodę \u003csamp\u003egetFirstName\u003c/samp\u003e\n  dla obiektu \u003csamp\u003euser\u003c/samp\u003e,\n  którego wartość pola \u003csamp\u003efirstName\u003c/samp\u003e jest ”KOWALSKI” to \u003csamp\u003ethis.firstName\u003c/samp\u003e jest polem tego\n  konkretnego obiektu i tam będzie nazwisko „KOWALSKI”. Co prawda bez słowa \u003csamp\u003ethis\u003c/samp\u003e funkcja działała by poprawnie,\n  gdyż referencja \u003csamp\u003ethis\u003c/samp\u003e\n  jest stosowana domyślnie, to dobrze jest ją umieszczać jawnie.\u003c/p\u003e\n\u003cp\u003e\nDruga metoda posiada jeden parametr, którym jest łańcuch. W ciele metody mamy tylko przypisanie do pola \u003csamp\u003e\n  this.firstName\u003c/samp\u003e parametru \u003csamp\u003efirstName\u003c/samp\u003e. Tutaj słowo \u003csamp\u003ethis\u003c/samp\u003e jest konieczne\n  gdyż pomijając go otrzymalibyśmy:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n  void setFirstName(String firstName){\n    firstName \u003d firstName;\n  }\n  …\u003c/code\u003e\n  \u003c/pre\u003e\n\u003cp\u003e\nW tej sytuacji kompilator przyjąłby nazwę \u003csamp\u003efirstName\u003c/samp\u003e, która jest najbliżej zdefiniowana czyli parametr\n  wywołania. Pole \u003csamp\u003efirstName\u003c/samp\u003e klasy nie zostałoby przypisane wartością parametru i nadal byłoby\n  równe \u003csamp\u003enull\u003c/samp\u003e. Możemy się o tym przekonać wywołując metodę: \u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003e\n  Person user \u003d new Person();\n  user.setFirstName(”KOWALSKI”); //wywołanie settera z argumentem\n  System.out.prinln(user.getFirstName()); //wywołanie gettera bezargumentowego\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\nDostęp do metody obiektu odbywa się tak samo jak do pól - poprzez kropkę. Wywołanie funkcji to podanie\n  jej nazwy z parą nawiasów okrągłych na końcu. Nawiasy są operatorem wywołania metody (funkcji).\n  Jeśli metoda wymaga podania argumentów to należy je podać w nawiasach, w tej samej kolejności jak\n  przy definicji.\u003c/p\u003e\n\u003cp\u003e\n  Wracając do ostatniej wersji settera to instrukcja\u003c/p\u003e\n\u003ccode\u003eSystem.out.println(user.getFirstName()) \u003c/code\u003e\u003cbr\u003e\n\u003cp\u003ewyświetli\n  \u003csamp\u003enull\u003c/samp\u003e,\n  gdyż pominęliśmy słowo \u003csamp\u003ethis\u003c/samp\u003e i po obu stronach przypisania mamy ten sam parametr\n  \u003csamp\u003efirstName\u003c/samp\u003e.\n  Więc argument wywołania przypisany zostanie do siebie samego, a nie do pola \u003csamp\u003efirstName\u003c/samp\u003e obiektu\n  \u003csamp\u003euser\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nUniknęlibyśmy takiej sytuacji, gdybyśmy inaczej nazwali parametr settera:\u003c/p\u003e\n\u003cpre\u003e  \u003ccode\u003e\n  function setFirstName(String fName){\n    firstName \u003d fName;\n  }\u003c/code\u003e\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Zadanie 1",
              "stepic_id": 0,
              "task_files": {
                "src/Book.java": {
                  "name": "src/Book.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": ""
                }
              },
              "test_files": {
                "test/TestBook.java": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class TestBook{\n\n  @Test\n  public void testSolution() {\n    Book b \u003d new Book();\n    assertEquals(\"Niepoprawne pole\", null, b.author);\n    assertEquals(\"Niepoprawne pole\", null, b.title);\n  }\n}"
              },
              "description_text": "\u003chtml\u003e\nW pliku Book.java zdefiniuj klasę Book, która posiada dwa pola: author i title.\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Zadanie 2",
              "stepic_id": 0,
              "task_files": {
                "src/Car.java": {
                  "name": "src/Car.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Car{\n  int power;\n  String id;\n\n  public String toString(){\n    return id +\" \"+power;\n  }\n}"
                }
              },
              "test_files": {
                "test/TestCar.java": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class TestCar{\n\n  @Test\n  public void testSolution() {\n    Car c \u003d new Car();\n    c.id \u003d \"TK 6798S\";\n    c.power \u003d 156;\n    assertEquals(\"Niewłaściwa funkcja toString()!\", \"id \u003d TK 6798S, power \u003d 156\", c.toString());\n  }\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\n    Zdefiniuj bezargumentową metodę \u003csamp\u003etoString()\u003c/samp\u003e, która zwróci łańcuch składający się\n    z wartości wszystkich pól. Przykładowo dla klasy \u003csamp\u003ePoint\u003c/samp\u003e, która ma dwa pola \n    \u003csamp\u003ex\u003c/samp\u003e i \u003csamp\u003ey\u003c/samp\u003e funkcja \u003csamp\u003etoString()\u003c/samp\u003e\n    może wyglądać tak:\n\u003c/p\u003e\n    \u003cpre\u003e\n        \u003ccode\u003e  \n    class Point{\n        int x, y;\n        \n        public String toString(){\n           return \"Point x \u003d \" + x + \" y \u003d \" + y;\n        }\n    }\n        \u003c/code\u003e\n        \n    \u003c/pre\u003e\n\u003cp\u003e\n    Dla auta o atrybutach: id \u003d \"TK 8914S\" i power \u003d 100 zwrócony przez funkcję łańcuch powinien mieć postać:\n\u003c/p\u003e\n\u003csamp\u003e\n    id \u003d TK 8914S, power \u003d 100\n\u003c/samp\u003e\n\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Konstruktory",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eKONSTRUKTOR\u003c/h1\u003e\n\u003cp\u003e\nSpecjalną metodą jest konstruktor, który jest niejawnie wywoływany podczas tworzenia każdego obiektu.\n  Konstruktor ma nazwę identyczną jak klasa, nie zwraca żadnej wartości (nawet void).\n  Jeśli nie zostanie zdefiniowany to zostanie utworzony bezargumentowy konstruktor domyślny.\n  Zadaniem konstruktora jest najczęściej nadanie polom wartości już podczas tworzenia obiektu. \u003c/p\u003e\n\u003cp\u003e\n  Aby to osiągnąć należy zdefiniować konstruktor parametryczny: \u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  class Person{\n    String firstName;\n    String lastName;\n    Person(String fName, String lName) {\n      this.firstName \u003d fName;\n      this.lastName \u003d lName;\n    }\n  }\n    \u003c/code\u003e\n  \u003c/pre\u003e\n\u003cp\u003e\nKonstruktor posiada dwa parametry, które są łańcuchami zawierającymi kolejno imię i nazwisko,\n  które przypisujemy do odpowiednich pól. \u003c/p\u003e\n\u003cp\u003e\nMożna teraz skorzystać z tego konstruktora podczas tworzenia obiektu:\n\u003c/p\u003e\n\u003ccode\u003e\nPerson userA \u003d new Person(\"LUCJAN\", \"NOWACKI\");\u003c/code\u003e\u003cbr\u003e\n\u003cp\u003e\nMożemy teraz spojrzeć na tworzenie obiektu jak na wywołanie specjalnej metody, która jest konstruktorem.\n  Operator new oznacza tworzenie obiektu, potem występuje nazwa klasy, która też jest nazwą\n  konstruktora za którym w nawiasach znajdują się argumenty wywoływanej metody. Wywołanie\n  konstruktora zwraca gotowy obiekt, który przypisywany jest do zmiennej userA.\u003c/p\u003e\n\u003cp\u003e\nPorównajmy obecny przykład z poprzednim tworzeniem obiektu, zanim zdefiniowaliśmy konstruktor.\n\u003c/p\u003e\n\u003ccode\u003e  Person user \u003d new Person();\u003c/code\u003e\u003cbr\u003e\n\u003cp\u003e\nTutaj też wywołujemy konstruktor, tylko jest to niejawnie utworzony konstruktor bezargumentowy.\n  Co robi taki domyślny konstruktor? Wywołuje odpowiedni konstruktor superklasy, a ponieważ\n  nie wskazaliśmy takiej superklasy (później wyjaśnimy to pojęcie) to zostanie wywołany\n  bezargumentowy konstruktor klasy Object.\u003c/p\u003e\n\u003cp\u003e\nKlasa Object jest podstawową klasą, która jest wbudowana w język Java. Każda klasa,\n  której nie wskażemy superklasy będzie posiadać klasę Object jako swoją superklasę.\n  A ponieważ w klasie Object jest zdefiniowany konstruktor bezargumentowy, dlatego i\n  nasza Person taki posiada. Konstruktor dostarczony z Object w istocie prawie nic nie\n  robi, choć można przyjąć, że nadaje polom wartości domyślne, dlatego obiekt userB będzie\n  miał pola z wartościami null.\u003c/p\u003e\n\u003cp\u003e\nOba przykłady pokazują, że klasa może posiadać wiele konstruktorów, a każdy może mieć inną listę parametrów.\n  Rozpoznawanie, który konstruktor wywołać podczas tworzenia obiektu odbywa się na podstawie typu argumentów.\n  Stąd nie można zdefiniować dwóch konstruktorów z identyczną listą parametrów. Jeśli podczas tworzenia\n  obiektu pomylimy typ argumentu to pojawi się błąd kompilacji:\u003c/p\u003e\n\u003ccode\u003ePerson user \u003d new Person(1,\"KOWAL\"); //to spowoduje błąd kompilacji\u003c/code\u003e\u003cbr\u003e\n\u003cp\u003e\nKompilator wyśle komunikat informujący, że podaliśmy typ argumentu, którego nie da się rzutować\n  na typ String. Istotnie 1 jest literałem całkowitym, który automatycznie nie może zostać poddany konwersji.\n\u003c/p\u003e\n\u003cp\u003e\nJeśli nasza klasa Person będzie inaczej zdefiniowana: \u003c/p\u003e\n\u003ccode\u003eclass Person{ \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eString firstName; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eString lastName; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eint age; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003ePerson(String firstName, String lastName) {\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003ethis.firstName \u003d firstName; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003ethis.lastName \u003d lastName; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e} \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003ePerson(int age, String firstName){ \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003ethis.firstName \u003d firstName; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003ethis.age \u003d age; \u003c/code\u003e\u003cbr\u003e}\n\u003ccode\u003e}\u003c/code\u003e\u003cbr\u003e\n\u003cp\u003e\nto jeden z konstruktorów będzie odpowiadał naszej liście argumentów: \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003ePerson user \u003d new Person(1,\"ADAM\"); //teraz nie będzie błędów, jest odpowiedni konstruktor\u003c/code\u003e\u003cbr\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Zadanie 3",
              "stepic_id": 0,
              "task_files": {
                "src/Box.java": {
                  "name": "src/Box.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Box {\n  int fill;\n}"
                }
              },
              "test_files": {
                "test/TestBox.java": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class TestBox{\n\n  @Test\n  public void testSolution() {\n    Box b \u003dnew Box();\n    assertEquals(\"Niewłaściwa wartość pola fill!\", 100, b.fill );\n  }\n}"
              },
              "description_text": "\u003chtml\u003e\nZdefiniuj bezargumentowy konstruktor klasy Box, który zainicjuje pole fill wartością 100;\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Zadanie 4",
              "stepic_id": 0,
              "task_files": {
                "src/Player.java": {
                  "name": "src/Player.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Player {\n  int health;\n  String name;\n}"
                }
              },
              "test_files": {
                "test/TestPlayer.java": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class TestPlayer{\n\n  @Test\n  public void testSolution() {\n    Player p \u003d new Player(-1);\n    assertEquals(\"Niepoprawny index środkowego znaku\", 100, p.health);\n    p \u003d new Player(89);\n    assertEquals(\"Niepoprawny index środkowego znaku\", 89, p.health);\n    p \u003d new Player(104);\n    assertEquals(\"Niepoprawny index środkowego znaku\", 100, p.health);\n    p \u003d new Player(\"Cipka\");\n    assertEquals(\"Niepoprawny index środkowego znaku\", \"Cipka\", p.name);\n  }\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\n  Zdefiniuj dwa konstruktory jednoargumentowe klasy \u003csamp\u003ePlayer\u003c/samp\u003e.\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e\n  Pierwszy z argumentem typu całkowitego\nma zainicjować pole \u003csamp\u003ehealth\u003c/samp\u003e wartością argumentu, którego wartość musi mieścić się w zakresie od 1 do 100.\n  Jeśli wartość argumentu nie mieści się w zakresie przypisz polu wartość 100.\u003c/li\u003e\n\u003cli\u003e\nDrugi konstruktor z argumentem typu \u003csamp\u003eString\u003c/samp\u003e powinien przypisać polu \u003csamp\u003ename\u003c/samp\u003e wartość argumentu.\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Modyfikatory static i final",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cH1\u003eModyfikator static\u003c/H1\u003e\n\u003cp\u003e\nModyfikator static może wystąpić przed:\n\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003edeklaracją klasy - klasa statyczna\u003c/li\u003e\n  \u003cli\u003edeklaracją pola – pole statyczne\u003c/li\u003e\n  \u003cli\u003edeklaracją metody– metoda statyczna\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\nKlasa statyczna może istnieć jedynie jako klasa wewnętrzna.\n  Ponieważ na razie nie będziemy się tego rodzaju klasami zajmować, wyjaśnimy później jej zastosowanie.\n\u003c/p\u003e\n\u003cp\u003e\nPole statyczne klasy to pole, które jest wspólne dla wszystkich obiektów tej klasy i\n  istnieje nawet w sytuacji, gdy nie istnieje żaden obiekt tej klasy.\n  Tym samym do pola statycznego można się odwołać poprzez samą klasę. Jest to trochę\n  złamanie idei klasy jako schematu, który tylko opisuje jak utworzyć rzeczywiste obiekty, ale\n  sama klasa nie jest żadnym rzeczywistym bytem.\nMetoda statyczna to metoda, którą można wywołać bez potrzeby tworzenia obiektu tej klasy.\n\u003c/p\u003e\n\u003cp\u003e\n  W metodzie statycznej nie wolno odwoływać się do niestatycznych składowych klasy.\n\u003c/p\u003e\n\u003ch1\u003eModyfikator final\u003c/h1\u003e\n\u003cp\u003e\nSłowo kluczowe final może wystąpić przed:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003edeklaracją klasy - nie można wyprowadzić z niej innej klasy (klasa nie może być dziedziczona)\u003c/li\u003e\n  \u003cli\u003edeklaracją pola – nie można go modyfikować, pole jest niezmienne\u003c/li\u003e\n  \u003cli\u003edeklaracją metody – nie można jej implementować w klasie pochodnej, metoda jest niezmienna\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\nNa obecnym etapie nauki zajmiemy się jedynie zastosowaniem final w odniesieniu do pola.\n  Pole niezmienne oznacza, że nie można będzie już do niego przypisać żadnej wartości.\n  Jednak tę wartość choć raz trzeba przypisać i można to zrobić:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003einicjując pole podczas deklaracji,\u003c/li\u003e\n  \u003cli\u003eprzypisując wartość pola w konstruktorze.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n  \u003ch1\u003ePrzykład wykorzystania\u003c/h1\u003e\n\u003cp\u003e\nWróćmy do przykładu obliczania cen brutto. Zadeklarujemy klasę reprezentującą cenę produktu:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  class Price{\n    //cena w groszach\n    private int price;\n    //vat w promilach\n    private int vat;\n\n    public Price(int price){\n      this.price \u003d price;\n    }\n\n    public long getBrutto(){\n      return price*(1000+vat)/1000;\n    }\n\n    public float getBruttoZL(){\n      return this.getBrutto()/100f;\n    }\n\n    public void setVat(int vat){\n      this.vat \u003d vat;\n    }\n  }\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nLiczba stawek VAT jest skończona, więc można by zastosować listę stałych,\nktóre miałyby wartości VAT-u. Dodatkowo uniknęlibyśmy pomyłek wynikających z faktu,\nże VAT w naszej klasie podawany jest w promilach, gdy zazwyczaj podawany jest w procentach.\n  Skorzystajmy z poznanych słów kluczowych \u003csamp\u003estatic\u003c/samp\u003e i \u003csamp\u003efinal\u003c/samp\u003e do zdefiniowania stałych ze stawkami VAT:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  class Price{\n    public static final int VAT_23 \u003d 230;\n    public static final int VAT_8 \u003d 80;\n    public static final int VAT_5 \u003d 50;\n    //cena w groszach\n    final public int price;\n    //vat w promilach private\n    int vat; public Price(int price, int vat){\n      this.price \u003d price; this.vat \u003d vat;\n    }\n\n    public long getBrutto(){\n      return price*(1000+vat)/1000;\n    }\n\n    public float getBruttoZL(){\n      return this.getBrutto()/100f;\n    }\n\n    public void setVat(int vat){\n      this.vat \u003d vat;\n    }\n  }\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nUtworzyliśmy trzy pola statyczne i jednocześnie niezmienne z dostępem publicznym, które\n  zawierają obowiązujące stawki VAT. Dodatkowo pole \u003csamp\u003eprice\u003c/samp\u003e zmieniliśmy na publiczne i finalne.\nPrzykład wykorzystania naszej klasy:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  Price priceApple \u003d new Price(300_000, Price.VAT_23);\n  System.out.println(\"Cena netto: \"+ priceApple.price/100f +\"; cena brutto: \" + priceApple.getBruttoZL());\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Możemy też zdefiniować metodę statyczną, która będzie liczyć cenę podaną jako argument wywołania: \u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n    class Price{\n      public static final int VAT_23 \u003d 230;\n      public static final int VAT_8 \u003d 80;\n      public static final int VAT_5 \u003d 50;\n      . . .\n      public static long getBrutto(int priceInGrosz, int vatInPromile) {\n        return priceInGrosz *(1000+vatInPromile)/1000;\n      }\n    }\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  W metodzie statycznej nie można odwoływać się do pól niestatycznych obiektu, bo\n  metoda statyczna wywoływana może być na rzecz klasy, a nie obiektu, która nie\n  posiada pól niestatycznych.\u003c/p\u003e\n\u003cp\u003e\nKorzystając tylko z klasy, bez tworzenia obiektu tej klasy, możemy obliczyć cenę brutto: \u003c/p\u003e\n\u003cpre\u003e \u003ccode\u003e\n  System.out.println(Price.getBrutto(3000, Price.VAT_5));\n    \u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\nMożna też wywołać metodę statyczną na rzecz obiektu:\n\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003e\n  System.out.println(priceApple.getBrutto(40040, Price.VAT_8));\n\u003c/code\u003e\n  \u003c/pre\u003e\n\u003cp\u003e\nJest to jednak dość mylące, gdyż korzystamy z metody obiektu bez związku z nim samym,\n  w tym przypadku cena wyświetlona przez metodę nie ma nic wspólnego z ceną przechowywaną w obiekcie.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Metody o zmiennej liczbie parametrów",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eMetody o zmiennej liczbie argumentów- VarArgs\u003c/h1\u003e\n\u003cp\u003e\nMożliwe jest zdefiniowanie metody o zmiennej liczbie argumentów. Oznacza to, że\n    tę samą metodę można wywołać raz tak:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\n    obiekt.metodaVarargs(3, 3);\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\na innym razem tak:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\n    obiekt.metodaVarargs(3, 3, 5, 7, 8);\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nSchemat definiowania takiej funkcji wygląda następująco: \u003c/p\u003e\n\u003cpre\u003e\n\u003csamp\u003e\n    typ-zwracany nazwa-metody(typ parametr-stały, typ ... parametry)\n\u003c/samp\u003e\n    \u003c/pre\u003e\n\u003cp\u003e\n    \u003csamp\u003eparametr-stały\u003c/samp\u003e – to ostatni parametr, który musi wystąpić jako argument podczas wywołania,\u003cbr\u003e\n    \u003csamp\u003eparametry\u003c/samp\u003e – to pozostałe parametry, których liczba może się zmieniać. Jest to tablica, po której\nmożna iterować.\n\u003c/p\u003e\n\u003cp\u003e\nZdefiniujmy prostą metodę, która obliczy sumę liczb podanych jako argumenty:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\n    class Operations {\n        public int add(int first, int ... numbers) {\n            int sum \u003d first;\n            for (int number: numbers){\n                sum+\u003dnumber;\n            }\n            return sum;\n        }\n    }\n        \u003c/code\u003e\n    \u003c/pre\u003e\n\u003cp\u003e\n    Listę parametrów \u003csamp\u003enumbers\u003c/samp\u003e traktujemy jak tablicę, którą możemy przeglądać\n    instrukcją \u003csamp\u003efor each\u003c/samp\u003e.\n    Parametr \u003csamp\u003efirst\u003c/samp\u003e jest ostatnim stałym parametrem.\nPrzykład wywołania: \u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\n    Operations op \u003d new Operations();\n    System.out.println(op.add(1,2,3,4,5,6,7,8,9));\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nMożna tę metodę wywołać z jednym argumentem:\n\u003cpre\u003e\n\u003ccode\u003e\n    op.add(5);\n\u003c/code\u003e\n    \u003c/pre\u003e\nnatomiast próba wywołania jej bez argumentów:\n\u003cpre\u003e\n\u003ccode\u003e\n    op.add(); \u003c/code\u003e\u003c/pre\u003e\nzakończy się wygenerowaniem błędu kompilacji.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Pakiety",
          "task_list": [
            {
              "name": "Wiadomości",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003ePodstawowe wiadomości\u003c/h1\u003e\n\u003cp\u003e\u003c/p\u003e\nRozbudowane programy mogą zawierać bardzie wiele klas, część tych klas będzie współpracować ze sobą,\ntworząc jakąś odrębną całość, dodatkowo można te klasy wykorzystać w innych aplikacjach.\nAby łatwiej zarządzać kodem w Java stworzono kolejny, wyższy poziom organizacji zwany pakietami.\nPakiet to po prostu zbiór klas, które powinny mieć coś wspólnego ze sobą.\n\u003c/p\u003e\n\u003cp\u003e\nNazwy pakietów budowane są podobnie jak adresy domenowe, z użyciem małych liter (łacińskich),\n    tylko w odwrotnej kolejności np.:\u003c/p\u003e\n\u003csamp\u003e pl.sdacademy.javaistqb\u003c/samp\u003e\n\u003cp\u003e\nPodobnie też jak adresy można budować hierarchie pakietów tzn. pakiet może zawierać inne pakiety\n\u003c/p\u003e\n   \u003csamp\u003epl.tarr.istqbjava.javapodstawy\u003c/samp\u003e \u003cbr\u003e\n\u003csamp\u003epl.tarr.istqbjava.javaprogramowanie\u003c/samp\u003e \u003cbr\u003e\n\u003csamp\u003epl.tarr.istqbjava.javaprogramowaniezaawansowane\u003c/samp\u003e\u003cbr\u003e\n\u003cp\u003e\nFrazy użyte w nazwie pakietu nie muszą mieć żadnego związku z istniejącymi adresami domenowy,\n    choć często się je wykorzystuje. Jednocześnie należy budować je tak, aby były unikalne\n    i nie wchodziły w konflikt z istniejącymi pakietami Javy. Nazwy też powinny coś znaczyć\n    i informować co znajduje się w pakiecie np.: java.util jasno wskazuje, że jest to pakiet Java\n    z klasami użytkowymi.\n    \u003cp\u003e\nKażda klasa musi być przypisana do jakiegoś pakietu. Jeśli go nie zdefiniujemy to zostanie\n    utworzony pakiet domyślny, nienazwany.\u003c/p\u003e\n\u003cp\u003e\nOdzwierciedleniem fizycznym pakietów jest struktura katalogów, choć specyfikacja Javy tego nie wymaga.\n    Wtedy związek między nazwą pakietu a strukturą katalogu byłby następujący:\u003c/p\u003e\npakiet: \u003csamp\u003e pl.com.tarr.istqbjava \u003c/samp\u003e \u003cbr\u003e\nkatalog pakietu: \u003csamp\u003epl\\com\\tarr\\istqbjava\u003c/samp\u003e\u003cbr\u003e\n\u003cp\u003e\nWiększość środowisk IDE wspierających Javę fizycznie przechowuje tworzony kod w ten sposób.\n\u003c/p\u003e\n\u003cp\u003e\nUtworzenie pakietu polega na nadaniu mu nazwy i umieszczeniu w pierwszej linii pliku klasy deklaracji\n    pakietu: \u003c/p\u003e\n\u003ccode\u003e\n    package nazwa-pakietu;\n\u003c/code\u003e\n\u003cp\u003e\n    Umieśćmy klasę \u003csamp\u003ePerson\u003c/samp\u003e w pakiecie \u003csamp\u003epl.sdacademy.javaistqb\u003c/samp\u003e: \u003c/p\u003e\n\u003ccode\u003e package pl.sdacademy.javaistqb; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eclass Person{ \u003c/code\u003e \u003cbr\u003e\n\u003ccode\u003eString firstName; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eString lastName; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eint age; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003ePerson(String firstName, String lastName) {\u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e this.firstName \u003d firstName; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e this.lastName \u003d lastName; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e} \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003ePerson(int age, String firstName){ \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e this.firstName \u003d firstName; this.age \u003d age; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e} \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003e}\u003c/code\u003e\u003cbr\u003e\n\u003cp\u003e\n    Aby skorzystać z \u003csamp\u003ePerson\u003c/samp\u003e w innej klasie należącej do innego pakietu, należy ją zaimportować:\n\u003c/p\u003e\n\u003ccode\u003eimport nazwa-pakietu.*; //import wszystkich typów z pakietu import \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003enazwa-pakietu.NazwaKlasy; //import danej klasy\u003c/code\u003e\u003cbr\u003e\n\u003cp\u003e\nGdyby poprawnie została zdefiniowana nasza klasa Person to można ją by zaimportować w innym pakiecie:\n\u003c/p\u003e\n\u003ccode\u003eimport pl.sdacademy.javaistqb.Person; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eclass User{ Person userData; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eString password; \u003c/code\u003e\u003cbr\u003e\n\u003ccode\u003eString login; \u003c/code\u003e\u003cbr\u003e\n\u003ccode}\u003c/code\u003e\u003cbr\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Modyfikatory dostępu",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eModyfikatory dostępu\u003c/h1\u003e\n\u003cp\u003e\nModyfikatory dostępu określają czy element danej klasy czy pakietu jest widoczny w innej klasie\n  lub pakiecie. Może się wydawać, że ograniczanie dostępu utrudnia pracę nad programem,\n  bo nie można się odwołać do każdego pola, metody czy klasy. W istocie jest odwrotnie,\n  odpowiednie sterowanie widocznością czyni program bardziej czytelnym, niezawodnym i bezpiecznym.\n\u003c/p\u003e\n\u003cp\u003e\nWszystkie modyfikatory są przedstawione w tabeli:\n\u003c/p\u003e\n\u003ctable border\u003d\"\" bgcolor\u003d\"#123456\" cellpadding\u003d\"4\" align\u003d\"center\"\u003e\n  \u003ctr bgcolor\u003d\"#455612\" align\u003d\"center\" \u003e\n    \u003ctd\u003emodyfikator\u003c/td\u003e\n    \u003ctd\u003eskładowe klasy\u003c/td\u003e\n    \u003ctd\u003eklasy w tym \u003cbr\u003esamym pakiecie\u003c/td\u003e\n    \u003ctd\u003epodklasy w \u003cbr\u003einnym pakiecie\u003c/td\u003e\n    \u003ctd\u003ereszta\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr align\u003d\"center\"\u003e\n    \u003ctd\u003epublic\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#009955\"\u003edostępny\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#009955\"\u003edostępny\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#009955\"\u003edostępny\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#009955\"\u003edostępny\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr align\u003d\"center\"\u003e\n    \u003ctd\u003eprotected\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#009955\"\u003edostępny\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#009955\"\u003edostępny\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#009955\"\u003edostępny\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#992211\"\u003enie dostępny\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr align\u003d\"center\"\u003e\n    \u003ctd\u003ebez modyfikatora\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#009955\"\u003edostępny\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#009955\"\u003edostępny\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#992211\"\u003enie dostępny\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#992211\"\u003enie dostępny\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr align\u003d\"center\"\u003e\n    \u003ctd\u003epublic\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#009955\"\u003edostępny\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#992211\"\u003enie dostępny\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#992211\"\u003enie dostępny\u003c/td\u003e\n    \u003ctd bgcolor\u003d\"#992211\"\u003enie dostępny\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003cp\u003e\nZ tabeli wynika, że dla każdego modyfikatora składowe klasy są widoczne wewnątrz niej samej,\n  czyli klasa zawsze widzi wszystkie swoje składowe.\n  Modyfikator \u003csamp\u003epublic\u003c/samp\u003e powoduje, że każda składowa klasy lub klasa jest widoczna we wszystkich pakietach.\u003c/p\u003e\n\u003cp\u003e\n  Słowo \u003csamp\u003eprotected\u003c/samp\u003e ogranicza widoczność dla wszystkich klas spoza pakietu, które nie są wyprowadzone z danej klasy.\nBez podawania modyfikatora składowe danej klasy są widoczne we wszystkich klasach swojego pakietu. W innych\n  pakietach są już niewidoczne.\u003c/p\u003e\n\u003cp\u003e\n  Modyfikator \u003csamp\u003eprivate\u003c/samp\u003e wprowadza najbardziej rygorystyczne ograniczenie, powodujące, że składowa jest widoczna\n  tylko wewnątrz swojej klasy.\n\u003c/p\u003e\n\u003cp\u003e\nW prezentowanych przykładach brak było jakichkolwiek modyfikatorów, czyli zdefiniowaliśmy wszystkie elementy\n  jako widoczne w obrębie pakietu, zatem próba importu pakietu z poprzedniej strony w innym pakiecie nie\n  odniosłaby skutku. Nasza klasa \u003csamp\u003ePerson\u003c/samp\u003e nie byłaby widoczna poza pakietem.\n  Należy zatem poprawić jej definicję:\n\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003e\npackage pl.sdacademy.javaistqb;\n\npublic class Person {\n    private String firstName;\n    private String lastName;\n    private int age;\n\n    public Person(String firstName, String lastName) {\n        this.firstName \u003d firstName;\n        this.lastName \u003d lastName;\n    }\n\n    public Person(int a, String firstName) {\n        this.firstName \u003d firstName;\n        this.age \u003d a;\n    }\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public void setFirstName(String firstName) {\n        firstName \u003d firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        this.lastName \u003d lastName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age \u003d age;\n    }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nWszystkie pola zostały zdefiniowane jako prywatne, są więc tylko widoczne wewnątrz klasy.\n  Klasa \u003csamp\u003ePerson\u003c/samp\u003e ma modyfikator \u003csamp\u003epublic\u003c/samp\u003e, więc jest widoczna wszędzie.\n  Wszystkie metody,   w tym konstruktor też są publiczne.\u003c/p\u003e\n\u003cp\u003e\nImportujmy klasę do innego pakietu: \u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n    package pl.com.recordit.java\n    import pl.sdacademy.javaistqb.Person;\n\u003c/code\u003e\n\u003c/pre\u003e\n  \u003cp\u003e\nSprawdźmy działanie modyfikatorów poprzez stworzenie obiektu i wywołanie metod: \u003cp\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n    Person userB \u003d new Person(”ADAM”,”CAŁA”);\n    userB.setAge(49);\n    System.out.println(userB.getLastName()+” ”+userB.getAge());\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nNa ekranie powinny poprawnie wyświetlić się dane użytkownika. Natomiast próba odwołania się bezpośrednio\n  do pól np. \u003csamp\u003efirstName\u003c/samp\u003e skończy się niepowodzeniem: \u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n    userB.firstName \u003d ”CAŁKA”;\n    System.out.prinln(userB.firstName);\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nZostanie wyświetlony błąd kompilacji z informacją, że pole firstName ma dostęp prywatny, co oznacza,\n  że nie można go odczytać ani zapisać poza klasą.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Data i czas",
          "task_list": [
            {
              "name": "LocalTime",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\nWrite your task text here.\n\u003cbr\u003e\n\u003cbr\u003e\n\u003cdiv class\u003d\"hint\"\u003e\n  You can add hints anywhere in task text. Copy all hint div block and change its content.\n\u003c/div\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "LoaclaDate",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\nWrite your task text here.\n\u003cbr\u003e\n\u003cbr\u003e\n\u003cdiv class\u003d\"hint\"\u003e\n  You can add hints anywhere in task text. Copy all hint div block and change its content.\n\u003c/div\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "LocalDateTime",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\nWrite your task text here.\n\u003cbr\u003e\n\u003cbr\u003e\n\u003cdiv class\u003d\"hint\"\u003e\n  You can add hints anywhere in task text. Copy all hint div block and change its content.\n\u003c/div\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Łańcuchy",
          "task_list": [
            {
              "name": "Klasa String",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eKlasa String\u003c/h1\u003e\n\u003cp\u003e\n    Często typ łańcuchowy \u003csamp\u003eString\u003c/samp\u003e postrzega się jako jeden z typów prostych. W rzeczywistości\n    jest to typ złożony czyli klasa, która służy do zapamiętywania dowolnych napisów.\u003c/p\u003e\n\u003cp\u003eŁańcuchy można tworzyć dwoma metodami:\n\u003cul\u003e\n    \u003cli\u003e\n        na wzór tworzenia zmiennych typów prostych:\n        \u003cpre\u003e\u003ccode\u003e\nString title \u003d \"Pierwszy program\";\n                \u003c/code\u003e\n            \u003c/pre\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        metodą tworzenia obiektów:\n        \u003cpre\u003e\u003ccode\u003e\nString title \u003d new String(\"Pierwszy program\");\n                \u003c/code\u003e\n            \u003c/pre\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Łańcuchy tworzone pierwszą metodą umieszczane są w specjalnej puli łańcuchów. Gdy tworzona jest\n    zmienna łańcuchowa, która jest identyczny z jednym z łańcuchów w puli, to wykorzystywany jest łańcuch z puli,\n    a zmiennej jest przypisywana referenja do niego. W tej sposób wszystkie identyczne łańcuchy mają tę samą\n    referencję.\n\u003c/p\u003e\n\u003cp\u003e\n    Gdy łańcuch tworzony jest operatorem \u003csamp\u003enew\u003c/samp\u003e, to traktowany jest tak, jak wszystkie inne obiekty, i bez\n    względu na zawartość, każdej zmiennej przypisywana jest inna referencja.\n\u003c/p\u003e\n\u003cp\u003e\n    Jest to jedyna klasa, dla której przedefiniowano działanie operatora ‘+’: \u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\n    String text \u003d message +\" Tomek\";\n    \u003c/code\u003e\n    \u003c/pre\u003e\n\u003cp\u003e\n    Łączenie dotyczy także łańcuchów z typami prostymi, przy czym wartość takiego typu zamieniana jest na łańcuch\n    reprezentujący wartość:\n\u003c/p\u003e\n\u003cpre\u003e\n        \u003ccode\u003e\n    int radius \u003d 10;\n    float PI \u003d 3.14f;\n    System.out.println(\"Pole powierzchni koła o r \u003d\"+radius+\" wynosi \"+ radius*radius*PI);\n        \u003c/code\u003e\n    \u003c/pre\u003e\n\u003cp\u003e\n    Cechą charakterystyczną klasy \u003csamp\u003eString\u003c/samp\u003e jest też to, że jej obiekty są niemodyfikowalne. Mając dostęp do\n    referencji obiektu nie można zmienić zawartości łańcucha. Jeśli łączymy łańcuchy to tworzony jest nowy\n    obiekt z połączonych napisów. Jeśli istnieje potrzeba modyfikacji łańcucha to należy skorzystać ze\n    specjalizowanych klas StringBuilder lub StringBufor. Dają one możliwość modyfikowania każdego znaku obiektu.\n\u003c/p\u003e\n\u003cp\u003e\n    Klasa \u003csamp\u003eString\u003c/samp\u003e posiada wiele metod do przetwarzania łańcuchów:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003csamp\u003estr.length()\u003c/samp\u003e - zwraca liczbę znaków w łańcuchu str,\u003c/li\u003e\n\u003cli\u003e\u003csamp\u003estr.charAt(index)\u003c/samp\u003e - zwraca znak znajdujący się na pozycji index w str (pierwszy znak ma indeks 0)\u003c/li\u003e\n\u003cli\u003e\u003csamp\u003estr.contains(text)\u003c/samp\u003e - zwraca true, jeśli w łańcuchu str zawarty jest text\u003c/li\u003e\n\u003cli\u003e\u003csamp\u003estr.indexOf(ch)\u003c/samp\u003e - zwraca indeks pierwszego wystąpienia w łańcuchu str znaku ch\u003c/li\u003e\n\u003cli\u003e\u003csamp\u003estr.indexOf(substr)\u003c/samp\u003e - zwraca indeks pierwszego wystąpienia w łańcuchu str podłańcucha substr\u003c/li\u003e\n\u003cli\u003e\u003csamp\u003estr.indexOf(ch, index)\u003c/samp\u003e – zwraca indeks pierwszego wystąpienia we fragmencie łańcucha str, zaczynającego się od indeksu\nindex, znaku ch\u003c/li\u003e\n\u003cli\u003e\u003csamp\u003estr.indexOf(substr, index)\u003c/samp\u003e - zwraca indeks pierwszego wystąpienia we fragmencie łańcucha str, zaczynającego się od\nindeksu index, podłańcucha substr\u003c/li\u003e\n\u003cli\u003e\u003csamp\u003estr.lastIndexOf(ch), str.lastIndexOf(ch,index), str.lastIndexOf(substr), str.lastIndexOf(substr,index)\u003c/samp\u003e – działają7\npodobnie jak indexOf, z tą różnicą, że przeszukują łańcuch str od końca.\u003c/li\u003e\n\u003cli\u003e\u003csamp\u003estr.startsWith(prefix), str.endsWith(postfix) \u003c/samp\u003e– testują odpowiednio czy str zaczyna się, czy kończy się przekazanym\nargumentem.\u003c/li\u003e\n\u003cli\u003e\u003csamp\u003estr.substring(startIndex) str.substring(startIndex, endIndex)\u003c/samp\u003e – zwracają podłańcuchy z str odpowiednio: pierwsza\npocząwszy od podanego indeksu do końca, druga od podanego indeksu startIndex do indeksu endIndex.\u003c/li\u003e\n\u003cli\u003e\u003csamp\u003estr.replace(oldCh, newCh), str.replace(targetStr, replacementStr)\u003c/samp\u003e – zwracają łańcuch z zamienionymi znakami lub\npodłańcuchami\u003c/li\u003e\n\u003cli\u003e\u003csamp\u003estr.toLowerCase() \u003c/samp\u003e– zamienia wszystkie litery na małe\u003c/li\u003e\n\u003cli\u003e\u003csamp\u003estr.toUpperCase() \u003c/samp\u003e– zamienia wszystkie litery na duże\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n    Żadna z metod nie modyfikuje łańcucha, który je wywołuje. Jeśli zwracany jest łańcuch to jest to kopia odpowiednio\n    zmodyfikowanego łańcucha wywołującego metodę.\n\u003c/p\u003e\n\u003cp\u003e\nKilka przykładów wykorzystania przedstawionych metod:\n    \u003cpre\u003e\n        \u003ccode\u003e\n    final String str \u003d \"\u0026lt;p\u0026gt;Tekst w kilku \\nwierszach zwierający\\nznacznik HTML\u0026lt;/p\u0026gt;\";\n\n    System.out.println(str.codePointAt(0));\n    --\n    60\n\n    System.out.println(str.contains(\"\u0026lt;p\u0026gt;\"));\n    --\n    True\n\n    System.out.println(str.indexOf(\u0027T\u0027));\n    --\n    3\n\n    System.out.println(str.indexOf(\u0027t\u0027,3));\n    --\n    7\n\n    System.out.println(str.indexOf(\"kilku\"));\n    --\n    11\n\n    System.out.println(str.lastIndexOf(\u0027L\u0027));\n    --\n    52\n\n    System.out.println(str.startsWith(\"\u0026lt;p\u0026gt;\"));\n    --\n    true\n\n    System.out.println(str.substring(1,11));\n    --\n    p\u003eTekst w\n\n    System.out.println(str.replace(\u0027a\u0027, \u0027@\u0027));\n    --\n    \u0026lt;p\u0026gt;Tekst w kilku wiersz@ch zwier@jący zn@cznik HTML \u0026lt;/p\u0026gt;\n\n    System.out.println(str.toLowerCase());\n    --\n    \u0026lt;p\u0026gt;tekst w kilku wierszach zwierający znacznik html \u0026lt;/p\u0026gt;\n\n    System.out.println(str.toUpperCase());\n    --\n    \u0026lt;p\u0026gt;TEKST W KILKU WIERSZACH ZWIERAJĄCY ZNACZNIK HTML \u0026lt;/p\u0026gt;\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Zadanie 1",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n\n  //Funkcja 1\n  static public char getMiddleChar(String s){\n    char result \u003d \u0027 \u0027;\n    //napisz funkcję, która zwróci środkowy znak łańcucha s\n\n    return result;\n  }\n\n  //Funckja 2\n  static public boolean hasHexDigit(String s){\n    boolean result \u003d false;\n    //napisz funkcję, która zwróći prawdę jeśli w łańcuchu s występuje litera A B C D E F\n    return result;\n  }\n\n  //Funkcja 3\n  static public int countBetween(String s, char symbol){\n    int result \u003d 0;\n    //napisz funkcję, która zwróci ile znaków znajduję się w łańcuchy s między pierwsza i ostatnim znakiem symbol\n    return result;\n  }\n\n  static public void main(String[] args){\n\n  }\n}"
                }
              },
              "test_files": {
                "test/TestTask.java": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class TestTask{\n\n  @Test\n  public void testSolution() {\n    assertEquals(\"Niepoprawny index środkowego znaku\", \u0027d\u0027, Task.getMiddleChar(\"abcdefg\") );\n    assertEquals(\"Ten łańcuh zawiera cyfrę Hex\", true, Task.hasHexDigit(\"adhjkdf$%F\"));\n    assertEquals(\"Ten łańcuh nie zawiera znaku HEX\", false, Task.hasHexDigit(\"adhjkdf$%hjua\"));\n    assertEquals(\"Niepoprawna liczba\", 5, Task.countBetween(\"gbcaedfjhagb\", \u0027a\u0027) );\n    assertEquals(\"Niepoprawna liczba\", 0, Task.countBetween(\"gbcaedfjhagb\", \u0027z\u0027) );\n    assertEquals(\"Niepoprawna liczba\", 0, Task.countBetween(\"gbcaezfjhagb\", \u0027z\u0027) );\n  }\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003eUzupełnij trzy funkcje. Wpisz kod tylko wewnątrz funkcji, wyznacz wartość zmiennej result.\u003c/p\u003e\n\u003ch3\u003eFunkcja 1\u003c/h3\u003e\n\u003cp\u003e\nZwróć środkowy znak łańcucha np. dla łańcucha \"1234567\" funkcja powinna zwrócić znak \u00274\u0027. Przyjmij, że łańcuch\ns zawsze zawiera nieparzystą liczbę n znaków, przy czym n \u003e 2.\n\u003c/p\u003e\n\u003ch3\u003eFunkcja 2\u003c/h3\u003e\n\u003cp\u003e\n   Zwróć wartość logiczną true, jeśli w łańcuch s występuje choć jedna z cyfr szesntastkowych A, B, C, D, E ,F\n    np. dla łańcucha s \u003d \"a78984\" powinna zwrócić false, dla s \u003d \"7896aHF\" wynikiem jest true.\n\u003c/p\u003e\n\u003ch3\u003eFunkcja 3\u003c/h3\u003e\n\u003cp\u003e\n    Zwróć liczbę znaków występujących w s między pierwszym i ostanim znakiem symbol np. dla\n    łańcucha s \u003d \"abcadfg\" i symbol \u003d \u0027a\u0027 funkcja powinna zwrócić 2. Jeśli znak symbol nie występuje, lub jest tylko\n    jeden taki znak to funkcja powinna zwrócić 0.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Wyrażenia regularne",
              "stepic_id": 0,
              "task_files": {
                "src/RegExpExamples.java": {
                  "name": "src/RegExpExamples.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.regex.Pattern;\n\nclass RegExpExamples {\n  public static void main(String[] args){\n    System.out.println(Pattern.matches(\"^B.*\",\"Beata\"));\n    System.out.println(Pattern.matches(\".*ala.*\",\"balaton\"));\n    System.out.println(Pattern.matches(\".*\\\\d.*\",\"a9a\"));\n    System.out.println(Pattern.matches(\"^[ab\\\\s]+$\",\"aabaabba\"));\n    System.out.println(Pattern.matches(\"\\\\d{2}-\\\\d{3}\",\"22-456\"));\n    System.out.println(Pattern.matches(\"^\\\\b.*[aA]\\\\b$\",\"Tomek Alina\"));\n    System.out.println(Pattern.matches(\"\\\\d{2}\\\\s+\\\\d{9}\",\"48 567812386\"));\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eWyrażenia regularne\u003c/h1\u003e\n\u003cp\u003e\nW praktyce tworzenia programów dość często trzeba operować na łańcuchach, w których przechowuje\n  się wiele różnorodnych danych. Przykładem może być np. nr rejestracyjny samochodu, który\n  może składać się z liter i cyfr. Jak rozpoznać, czy zapisany w zmiennej String numer jest poprawny?\n  Czy zaczyna się od dwóch liter? Czy kombinacja tych liter jest właściwa? Oczywiście takich pytań można\n  stawiać wiele i muszą istnieć odpowiednie narzędzia do uzyskania na nie odpowiedzi.\n\u003c/p\u003e\n\u003cp\u003e\nWłaściwym narzędziem do przetwarzania łańcuchów są wyrażenia regularne. Wyrażenie kojarzy się z\n  ciągiem działań i dokładnie tak jest: wyrażenie regularne jest zapisem ciągu działań jakie\n  należy podjąć na łańcuchu, aby stwierdzić, czy łańcuch pasuje do wzorca.\n  A gdzie zapisujemy ten wzór? Właśnie w tym wyrażeniu.\u003c/p\u003e\n\u003cp\u003e\n  Popatrzmy na pierwszy przykład testujący czy w zmiennych strA i StrB jest napis ”ab”: \u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  import java.util.regex.Pattern;\n  String strA \u003d \"ab\";\n  String strB \u003d \"abc\";\n  boolean isPattern \u003d Pattern.matches(\"ab\", strA);\n  System.out.println(isPattern);\n  isPattern \u003d Pattern.matches(\"ab\", strB);\n  System.out.println(isPattern);\n  --\n  true\n  false\n  \u003c/code\u003e\n  \u003c/pre\u003e\n  \u003cp\u003e\n    Jest to najbardziej prymitywny sposób porównywania łańcuchów. Nasze wyrażenie zawierało\n  dokładnie te znaki jakie chcemy, aby występowały w testowanym łańcuchu.\n  Wykorzystaliśmy klasę Pattern posiadająca metodę statyczną, która potrzebuje dwóch\n  argumentów: wyrażenia regularnego i łańcucha testowanego. Metoda zwraca true jeśli\n  wynik porównania jest pozytywny.\n\u003c/p\u003e\n\u003cp\u003e\nTworzenie bardziej rozbudowanych wyrażeń wymaga stosowania oprócz znaków także specjalnych symboli:\n\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eZnaki\u003c/li\u003e\n  \u003cul\u003e\n    \u003cli\u003eX - dowolny znak\u003c/li\u003e\n    \u003cli\u003e\\\\ - znak backslash\u003c/li\u003e\n    \u003cli\u003e\\0n - znak o kodzie w postaci liczby ósemkowa 0n (0\u003c\u003dn\u003c\u003d7)\u003c/li\u003e\n    \u003cli\u003e\\0nn - znak o kodzie w postaci liczby ósemkowa 0nn (0\u003c\u003dn\u003c\u003d7)\u003c/li\u003e\n    \u003cli\u003e\\0mnn - znak o kodzie w postaci liczby ósemkowa 0mnn (0\u003c\u003dn\u003c\u003d7, 0\u003c\u003d m \u003c\u003d 3)\u003c/li\u003e\n    \u003cli\u003e\\xhh - znak o kodzie w postaci liczby heksadecymalnej 0xhh\u003c/li\u003e\n    \u003cli\u003e\\uhhhh - znak o kodzie w postaci liczby heksadecymalnej 0xhhhh\u003c/li\u003e\n    \u003cli\u003e\\x{h.. h} - znak o kodzie w postaci liczby heksadecymalnej 0xh..h\u003c/li\u003e\n    \u003cli\u003e\\t - znak tabulatora (‘\\u0009’)\u003c/li\u003e\n    \u003cli\u003e\\n - znak nowej linii (‘\\u000A’)\u003c/li\u003e\n    \u003cli\u003e\\r - znak powrotu karetki (kursora tekstowego) (‘\\u000D’)\u003c/li\u003e\n    \u003cli\u003e\\f - znak przesunięcia (‘\\u000C’)\u003c/li\u003e\n    \u003cli\u003e\\a - znak dzwonka (alarmu) (‘\\u0007’)\u003c/li\u003e\n    \u003cli\u003e\\e - znak ucieczki (escape) (‘\\u001B’)\u003c/li\u003e\n    \u003cli\u003e\\cx - znak kontrolny x\u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cli\u003e\n    Symbole powtórzeń, występują za dowolnym znakiem X, który ma się powtarzać we wzorcu\n  \u003c/li\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      X? - X może wystąpić raz lub wcale\n    \u003c/li\u003e\n    \u003cli\u003e\n      X* - X może powtarzać się wielokrotnie lub wcale\n    \u003c/li\u003e\n    \u003cli\u003e\n      X+ - X może powtarzać się wielokrotnie albo wystąpić chociaż raz\n    \u003c/li\u003e\n    \u003cli\u003e\n      X{n} - X musi się powtórzyć dokładnie n razy\n    \u003c/li\u003e\n    \u003cli\u003e\n      X{n,} - X musi powtórzyć się co najmniej n razy\n    \u003c/li\u003e\n    \u003cli\u003e\n      X{n. m} - X może się powtarzać od n do m razy\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cli\u003e\n    Predefiniowane symbole klas znaków, zastępują pewne typowe grupy znaków\n  \u003c/li\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      . - dowolny znak\n    \u003c/li\u003e\n    \u003cli\u003e\n      \\d - znak cyfry: [0:9]\n    \u003c/li\u003e\n    \u003cli\u003e\n      \\D - znak nie będący cyfrą\n    \u003c/li\u003e\n    \u003cli\u003e\n      \\s - znak biały: spacja, tabulator, nowa linia\n    \u003c/li\u003e\n    \u003cli\u003e\n      \\w - dowolny znak słowa, czyli znak alfabetu\n    \u003c/li\u003e\n    \u003cli\u003e\n      \\W - znak nie należący do alfabetu\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cli\u003e\n    Klasy znaków, czyli własne grupy znaków\n  \u003c/li\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      [abc] - grupa składająca się ze znaków a, b, c\n    \u003c/li\u003e\n    \u003cli\u003e\n      [^abc] - każdy znak nie będący znakiem a, b, c, neguje podany zbiór\n    \u003c/li\u003e\n    \u003cli\u003e\n      [a-zA-z] - znaki należące do przedziału od a do z i od A do Z\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cli\u003e\n    Asercje (kotwice), czyli znaczniki miejsca, w którym musi wystąpić dopasowanie:\n  \u003c/li\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      ^ - początek tekstu, linii\n    \u003c/li\u003e\n    \u003cli\u003e\n      $ - koniec tekstu. Linii\n    \u003c/li\u003e\n    \u003cli\u003e\n      \\A - początek tekstu\n    \u003c/li\u003e\n    \u003cli\u003e\n      \\Z - koniec tekstu\n    \u003c/li\u003e\n    \u003cli\u003e\n      \\b - granice słowa, koniec lub początek\n    \u003c/li\u003e\n    \u003cli\u003e\n      \\B - wnętrze słowa, nie koniec ani nie początek\n    \u003c/li\u003e\n    \u003cli\u003e\n      \\G - koniec poprzedniego dopasowania\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cli\u003e\n    Operatory\n  \u003c/li\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      | - alternatywa np. X|Y oznacza X lub Y\n    \u003c/li\u003e\n    \u003cli\u003e\n      XY - X przed Y\n    \u003c/li\u003e\n    \u003cli\u003e\n      (X) - X jest grupą przechwytywaną, wyłuskaną\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cli\u003e\n    Referencje wsteczne\n  \u003c/li\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \\n - odniesienie do przechwyconej grupy o numerze n (numery od 1)\n    \u003c/li\u003e\n    \u003cli\u003e\n      \\k\u0026lt;nazwa\u0026gt; - odniesienie do przechwyconej grupy nazwanej\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cli\u003eKonstrukcje grup\u003c/li\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      (?\u0026lt;nazwa\u0026gt;X) - nazwana grupa do wyłuskania\n    \u003c/li\u003e\n    \u003cli\u003e\n      (?:X) - grupa nie przychwytywana\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/ul\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Przykłady",
              "stepic_id": 0,
              "task_files": {
                "src/RegExpExamples.java": {
                  "name": "src/RegExpExamples.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.regex.Pattern;\n\nclass RegExpExamples {\n  public static void main(String[] args){\n    System.out.println(Pattern.matches(\"^B.*\",\"Beata\"));\n    System.out.println(Pattern.matches(\".*ala.*\",\"balaton\"));\n    System.out.println(Pattern.matches(\".*\\\\d.*\",\"a9a\"));\n    System.out.println(Pattern.matches(\"^[ab\\\\s]+$\",\"aabaabba\"));\n    System.out.println(Pattern.matches(\"\\\\d{2}-\\\\d{3}\",\"22-456\"));\n    System.out.println(Pattern.matches(\"^\\\\b.*[aA]\\\\b$\",\"Tomek Alina\"));\n    System.out.println(Pattern.matches(\"\\\\d{2}\\\\s+\\\\d{9}\",\"48 567812386\"));\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003ePrzykłady\u003c/h1\u003e\n\u003cp\u003e\nCzy łańcuch zaczyna się literą B:\n\u003c/p\u003e\n\u003csamp\u003e^B.*\u003c/samp\u003e\n\u003cp\u003e\n  Czy łańcuch zawiera frazę \"ala\"\n\u003c/p\u003e\n\u003csamp\u003e.*ala.*\u003c/samp\u003e\n\u003cp\u003e\n  Czy w łańcuchu znajduje się cyfra\n\u003c/p\u003e\n\u003csamp\u003e\n  .*\\d.*\n\u003c/samp\u003e\n\u003cp\u003e\n  Czy łańcuch składa się tylko z liter a i b\n\u003c/p\u003e\n\u003csamp\u003e\n  ^[ab\\s]+$\n\u003c/samp\u003e\n\u003cp\u003e\n  Czy łańcuch jest kodem pocztowym\n\u003c/p\u003e\n\u003csamp\u003e\n  \\d{2}-\\d{3}\n\u003c/samp\u003e\n\u003cp\u003e\n  Czy ostatni wyraz jest imieniem żeńskim lub kończy się literą a\n\u003c/p\u003e\n\u003csamp\u003e\n  ^\\b.*[aA]\\b$\n\u003c/samp\u003e\n\u003cp\u003e\n  Czy łańcuch zawiera nr telefonu\n\u003c/p\u003e\n\u003csamp\u003e\n  \\d{2}\\s+\\d{9}\n\u003c/samp\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        }
      ],
      "type": "section"
    },
    {
      "title": "Java - programowanie podstawowe",
      "id": 0,
      "update_date": "Jan 1, 1970 1:00:00 AM",
      "items": [
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Rekurencja",
          "task_list": [
            {
              "name": "MergeSort",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "  class Main {\n    //\n    static void mergeSort(int[] arr, int start, int end){\n      int m;\n      if (start \u003c end){\n        m \u003d (end - start) / 2;\n        mergeSort(arr, start , start + m);\n        mergeSort(arr, start + m + 1, end);\n        merge(arr, start, end, start + m);\n      }\n    }\n\n    // start - index of the first element in subarray\n    // end - index of the last element in subarray\n    static void merge(int[] arr, int start, int end, int m){\n      int[] t \u003d new int[1 + end - start];\n      int a \u003d start;\n      int b \u003d m + 1;\n      for (int j \u003d 0; j \u003c t.length; j++) {\n        if (a \u003c\u003d m \u0026\u0026 b \u003c\u003d end) {\n          t[j] \u003d arr[a] \u003c arr[b] ? arr[a++] : arr[b++];\n          continue;\n        }\n        if (a \u003c\u003d m) {\n          t[j] \u003d arr[a++];\n          continue;\n        }\n        if (b \u003c\u003d end){\n          t[j] \u003d arr[b++];\n          continue;\n        }\n      }\n      int j \u003d 0;\n      for (int i \u003d start; i \u003c\u003d end; i++){\n        arr[i] \u003d t[j++];\n      }\n    }\n\n    public static void main(String[] args) {\n      int[] arr \u003d { 2, 6, 6, 8, 4, 3, 1, 2, 4 , 5, 6};\n      mergeSort(arr,0 ,arr.length-1);\n      for (int e: arr){\n        System.out.print(e+\" \");\n      }\n    }\n  }"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\nWrite your task text here.\n\u003cbr\u003e\n\u003cbr\u003e\n\u003cdiv class\u003d\"hint\"\u003e\n  You can add hints anywhere in task text. Copy all hint div block and change its content.\n\u003c/div\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        }
      ],
      "type": "section"
    },
    {
      "title": "Java zaawansowana",
      "id": 0,
      "update_date": "Jan 1, 1970 1:00:00 AM",
      "items": [
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Dziedziczenie",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Person.java": "",
                "test/Customer.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003ePodstawy\u003c/h1\u003e\n\u003cp\u003e\nDziedziczenie jest przejmowaniem przez klasę właściwości innej klasy. Dana jest klasa \u003csamp\u003ePerson\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\npublic class Person {\n  public String firstName;\n  public String lastName;\n  public LocalDate birthDate;\n\n  public Person(String firstName, String lastName, LocalDate birthDate) {\n    this.firstName \u003d firstName;\n    this.lastName \u003d lastName;\n    this.birthDate \u003d birthDate;\n  }\n\n  public String toString(){\n  return firstName +\" \"+lastName+\" \"+birthDate;\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nUtworzenie klasy \u003csamp\u003eWorker\u003c/samp\u003e, w której chcemy przechowywać informacje osobowe jak i dodatkowe np.: stanowisko, pensja,\n    data zatrudnienia itd., może być łatwiejsze\njeśli zastosuje się dziedziczenie:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\npublic class Worker extends Person{\n  public String position;\n  public double salary;\n\n  public Worker(String firstName, String lastName, LocalDate birthDate, String position, double salary) {\n    this.lastName \u003d lastName;\n    this.firstName \u003d firstName;\n    this.birthDate \u003d birthDate;\n    this.position \u003d position;\n    this.salary \u003d salary;\n  }\n\n  public String toString(){\n    return super.toString()+\" \"+position+\" \"+salary;\n  }\n}\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Słowo kluczowe \u003csamp\u003eextend\u003c/samp\u003e powoduje, że do definiowanej klasy \u003csamp\u003eWorker\u003c/samp\u003e dołączane są pola i metody\n    klasy \u003csamp\u003ePerson\u003c/samp\u003e. Dziedziczenie dotyczy wszystkich składowych, ale w klasie pochodnej dostępne\n    są tylko składowe nieprywatne. W Java można dziedziczyć tylko po jednej klasie.\n\u003c/p\u003e\n\u003cp\u003e\n    W przedstawionym przykładzie \u003csamp\u003ePerson\u003c/samp\u003e jest klasą bazową, nadklasą, superklasą a \u003csamp\u003eWorker\u003c/samp\u003e\n    klasą wyprowadzoną, pochodną lub podklasą.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Zadanie 1",
              "stepic_id": 0,
              "task_files": {
                "src/Customer.java": {
                  "name": "src/Customer.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "\n"
                },
                "src/Person.java": {
                  "name": "src/Person.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\n\nclass Person{\n  public String firstName;\n  public String lastName;\n  public LocalDate birthDate;\n\n  public Person(String firstName, String lastName, LocalDate birthDate) {\n    this.firstName \u003d firstName;\n    this.lastName \u003d lastName;\n    this.birthDate \u003d birthDate;\n  }\n\n  @Override\n  public String toString() {\n    return \"Person{\" +\n            \"firstName\u003d\u0027\" + firstName + \u0027\\\u0027\u0027 +\n            \", lastName\u003d\u0027\" + lastName + \u0027\\\u0027\u0027 +\n            \", birthDate\u003d\" + birthDate +\n            \u0027}\u0027;\n  }\n}"
                }
              },
              "test_files": {
                "test/TestCustomer.java": "import org.junit.Test;\n\nimport java.time.LocalDate;\n\nimport static org.junit.Assert.*;\n\npublic class TestCustomer{\n  @Test\n  public void testCustomer() {\n    Person c \u003d new Customer(\"A\",\"B\", LocalDate.of(2000,10,10),\"AA 12 234\",\"23457643GB\");\n    assertTrue(\"Klasa worker nie dziedziczy po Person\", c instanceof Person);\n    assertEquals(\"Brak pola shippingAddress\", \"AA 12 234\",((Customer) c).shippingAddress);\n    assertEquals(\"Brak pola creditCard\", \"23457643GB\",((Customer) c).creditCard);\n    assertEquals(\"Brak pola firstName\", \"A\", c.firstName);\n    assertEquals(\"Brak pola lastName\", \"B\", c.lastName);\n    assertEquals(\"Brak pola birthDate\", LocalDate.of(2000,10,10).toString(), c.birthDate.toString());\n  }\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eZadanie 1\u003c/h1\u003e\n\u003cp\u003eZdefiniuj klasę \u003csamp\u003eCustomer\u003c/samp\u003e wyprowadzoną z klasy \u003csamp\u003ePerson\u003c/samp\u003e. W klasie \u003csamp\u003eCustomer\u003c/samp\u003e dodaj pola:\n  \u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003eString shippingAddress;\u003c/code\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n       \u003ccode\u003eString creditCard;\u003c/code\u003e\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Cześć 2",
              "stepic_id": 0,
              "task_files": {
                "src/Person.java": {
                  "name": "src/Person.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\n\nclass Person{\n  public String firstName;\n  public String lastName;\n  public LocalDate birthDate;\n\n  public Person(String firstName, String lastName, LocalDate birthDate) {\n    this.firstName \u003d firstName;\n    this.lastName \u003d lastName;\n    this.birthDate \u003d birthDate;\n  }\n\n  @Override\n  public String toString() {\n    return \"Person{\" +\n            \"firstName\u003d\u0027\" + firstName + \u0027\\\u0027\u0027 +\n            \", lastName\u003d\u0027\" + lastName + \u0027\\\u0027\u0027 +\n            \", birthDate\u003d\" + birthDate +\n            \u0027}\u0027;\n  }\n}"
                },
                "src/ReferenceInheritanceDemo.java": {
                  "name": "src/ReferenceInheritanceDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\n\nclass Task {\n  public static void main(String[] args) {\n    Person employee \u003d new Worker(\n            \"Adam\",\n            \"Kowalski\",\n            LocalDate.of(1978, 10,19),\n            \"magazynier\",\n            2400.0);\n    Person wife \u003d new Person(\n            \"Zofia\",\n            \"Nowak\",\n            LocalDate.of(1978, 10,19));\n    System.out.println(employee);\n    System.out.println(wife);\n    Worker w \u003d (Worker) employee;\n    System.out.println(employee);\n  }\n}"
                },
                "src/Worker.java": {
                  "name": "src/Worker.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\n\npublic class Worker extends Person{\n  public String position;\n  public double salary;\n\n  public Worker(String firstName, String lastName, LocalDate birthDate, String position, double salary) {\n    super(firstName, lastName, birthDate);\n    this.position \u003d position;\n    this.salary \u003d salary;\n  }\n\n  @Override\n  public String toString() {\n    return \"Worker{\" +\n            \"salary\u003d\" + salary +\n            \", firstName\u003d\u0027\" + firstName + \u0027\\\u0027\u0027 +\n            \", lastName\u003d\u0027\" + lastName + \u0027\\\u0027\u0027 +\n            \", birthDate\u003d\" + birthDate +\n            \u0027}\u0027;\n  }\n}\n"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eDziedziczenie \"miejsca\"\u003c/h1\u003e\n\u003cp\u003eKonsekwencją dziedziczenia jest możliwość umieszczenia w zmiennych typu bazowego obiektu (referencji) klasy wyprowadzonej. Można to porównać do dziedziczenia miejsca: tam gdzie przewidujemy przechowywać obiekty klasy rodzica można umieścić także obiekty klas potomnych:\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nPerson employee \u003d new Worker(\n                  \"Adam\",\n                  \"Kowalski\",\n                  LocalDate.of(1978, 10,19),\n                  \"magazynier\",\n                  2400.0);\nPerson wife \u003d new Person(\n              \"Zofia\",\n              \"Nowak\",\n              LocalDate.of(1978, 10,19));\nSystem.out.println(w);\nSystem.out.println(p);\n  \u003c/code\u003e\n\u003c/pre\u003e\n  \u003cp\u003e\n    Obie zmienne są typu \u003csamp\u003ePerson\u003c/samp\u003e, ale dzięki dziedziczeniu do zmiennej\n    \u003csamp\u003eemployee\u003c/samp\u003e można przypisać obiekt klasy wyprowadzonej z \u003csamp\u003ePerson\u003c/samp\u003e czyli \u003csamp\u003eWorker\u003c/samp\u003e.\n \u003cp\u003e\n    Referencja \u003ccode\u003eemployee\u003c/code\u003e ma typ \u003ccode\u003ePerson\u003c/code\u003e, ale przechowuje obiekt \u003ccode\u003eWorker\u003c/code\u003e. Nie mamy dostępu do pola \u003ccode\u003esalary\u003c/code\u003e. Żeby móc się odowołać do  składowych klasy \u003ccode\u003eWorker\u003c/code\u003e musimy zrzutować zmienną referencyjną \u003ccode\u003eemployee\u003c/code\u003e na rzeczywisty typ tej zmiennej:\n  \u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nWorker w \u003d (Worker) employee;\nSystem.out.println(w.salary);\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003ch1\u003eKlasa Object i nadpisywanie - overriding\u003c/h1\u003e\n\u003cp\u003e\n  Podobny efekt ja w poprzedniej cześci, możemy uzyskać inną metodą:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  Object employee \u003d new Worker(\n                    \"Adam\",\n                    \"Kowalski\",\n                    LocalDate.of(1978, 10,19),\n                    \"magazynier\",\n                    2400.0);\n  Object wife \u003d new Person(\n                \"Zofia\",\n                \"Nowak\",\n                LocalDate.of(1978, 10,19));\n  System.out.println(employee);\n  System.out.println(wife);\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Typ \u003csamp\u003eObject\u003c/samp\u003e jest klasą, którą niejawnie dziedzczy każda definiowana klasa, dlatego działanie tego przykładu jest identyczne z poprzednim. Klasa \u003csamp\u003eObject\u003c/samp\u003e ma metodę \u003csamp\u003etoString()\u003c/samp\u003e, którą\n  zdefiniowaliśmy także w klasach \u003csamp\u003ePerson\u003c/samp\u003e i \u003csamp\u003eWorker\u003c/samp\u003e. Definiowanie\n  odziedziczonych metod w klasach potomnych to \u003ci\u003e\u003cb\u003enadpisywanie\u003c/b\u003e\u003c/i\u003e (ang. \u003ci\u003emethod overriding\u003c/i\u003e).\n    Stosowane są także inne określenia jak przesłanianie lub przedefiniowanie.\n  Aby nadpisanie się powiodło sygnatura nadpisywanej metody, czyli nazwa funkcji, argumenty i typ zwracany, muszą pasować do metody z klasy bazowej.\n  W przypadku pomyłki zostanie zdefiniowana nowa metoda, a nie przedefiniowanie odziedziczonej.\n    Popatrzmy\n  na przykład takiej pomyłki:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  public class Person {\n    public String firstName;\n    public String lastName;\n    public LocalDate birthDate;\n\n      public Person(String firstName, String lastName, LocalDate birthDate) {\n        this.firstName \u003d firstName;\n        this.lastName \u003d lastName;\n        this.birthDate \u003d birthDate;\n      }\n\n      public String tostring(){\n      return firstName +\" \"+lastName+\" \"+birthDate;\n}\n...\nObject wife \u003d new Person(\n                \"Zofia\",\n                \"Nowak\",\n                LocalDate.of(1978, 10,19));\nSystem.out.println(wife);\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    W efekcie tej pomyłki zostanie wyświetlony komunikat:\n\u003c/p\u003e\n\u003csamp\u003ePerson@4aa298b7\u003c/samp\u003e\n\u003cp\u003eJest to wynikiem działania metody \u003csamp\u003etoString()\u003c/samp\u003e odziedziczonej i zdefiniowanej w klasie\n    \u003csamp\u003eObject\u003c/samp\u003e, a nie naszej nadpisanej w klasie \u003csamp\u003ePerson\u003c/samp\u003e.\nTego typu pomyłki są trudne czasem do wykrycia, dlatego w celu zasygnalizowania intencji programisty,\nczy dana metoda jest nadpisywana czy też nowo definiowana stosuje się adnotację \u003csamp\u003e@Override\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  public class Person {\n    public String firstName;\n    public String lastName;\n    public LocalDate birthDate;\n\n      public Person(String firstName, String lastName, LocalDate birthDate) {\n        this.firstName \u003d firstName;\n        this.lastName \u003d lastName;\n        this.birthDate \u003d birthDate;\n      }\n      @Override\n      public String tostring(){\n      return firstName +\" \"+lastName+\" \"+birthDate;\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eUmieszczenie adnotacji spowoduje wygenerowanie błędu podczas uruchomienia programu z komunikatem, że\nmetoda oznaczona adnotacją nie nadpisuje metody z superklasy. Nie pozostaje nic innego jak poprawić błąd:\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  public class Person {\n    public String firstName;\n    public String lastName;\n    public LocalDate birthDate;\n\n      public Person(String firstName, String lastName, LocalDate birthDate) {\n        this.firstName \u003d firstName;\n        this.lastName \u003d lastName;\n        this.birthDate \u003d birthDate;\n      }\n      @Override\n      public String toString(){\n        return firstName +\" \"+lastName+\" \"+birthDate;\n      }\n    }\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Zadanie 2",
              "stepic_id": 0,
              "task_files": {
                "src/Employee.java": {
                  "name": "src/Employee.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\n\npublic class Employee extends Person{\n  private String position;\n  private double salary;\n\n  public Employee(String firstName, String lastName, LocalDate birthDate, String position, double salary) {\n    super(firstName, lastName, birthDate);\n    this.position \u003d position;\n    this.salary \u003d salary;\n  }\n\n  public double getSalary(){\n    return salary;\n  }\n\n  @Override\n  public String toString() {\n    return \"Employee{\" +\n            \"position\u003d\u0027\" + position + \u0027\\\u0027\u0027 +\n            \", salary\u003d\" + salary +\n            \", firstName\u003d\u0027\" + firstName + \u0027\\\u0027\u0027 +\n            \", lastName\u003d\u0027\" + lastName + \u0027\\\u0027\u0027 +\n            \", birthDate\u003d\" + birthDate +\n            \u0027}\u0027;\n  }\n}\n"
                },
                "src/Person.java": {
                  "name": "src/Person.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\n\nclass Person{\n  public String firstName;\n  public String lastName;\n  public LocalDate birthDate;\n\n  public Person(String firstName, String lastName, LocalDate birthDate) {\n    this.firstName \u003d firstName;\n    this.lastName \u003d lastName;\n    this.birthDate \u003d birthDate;\n  }\n\n  @Override\n  public String toString() {\n    return \"Person{\" +\n            \"firstName\u003d\u0027\" + firstName + \u0027\\\u0027\u0027 +\n            \", lastName\u003d\u0027\" + lastName + \u0027\\\u0027\u0027 +\n            \", birthDate\u003d\" + birthDate +\n            \u0027}\u0027;\n  }\n}"
                },
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\n\npublic class Task {\n  public static \u003ctyp\u003e team[] \u003d \u003cutwórz tablicę\u003e;\n  public static Employee wife;\n\n  public static void main(String[] args) {\n    team[0] \u003d new Person(\"ADAM\",\"KOŁEK\", LocalDate.of(2000,10,10));\n    team[1] \u003d new Employee(\"IRENA\",\"OCHÓCKA\", LocalDate.of(1960,11,23),\"żona prezesa\",20000);\n    System.out.println(team[0]);\n    System.out.println(team[1]);\n    //przypisz do zmiennej wife obiekt z team[1]\n\n    System.out.println(wife.getSalary());\n  }\n}\n"
                }
              },
              "test_files": {
                "test/TestTask.java": "import org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class TestTask{\n  @Test\n  public void testCustomer() {\n    assertTrue(\"Typ tablicy team niepoprawny.\", Task.team instanceof Person[]);\n    assertEquals(\"Niepoprawna wartość zmiennej wife.\",Task.wife, Task.team[1]);\n  }\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\n   Zdefiniowane są dwie klasy; \u003ccode\u003ePerson\u003c/code\u003e i  wyprowadzona z niej \u003ccode\u003eEmployee\u003c/code\u003e.\n   W pliku \u003csamp\u003eTask\u003c/samp\u003e w miejscu znacznika \u003csamp\u003e\u0026lt;typ\u0026gt;\u003c/samp\u003e wstaw odpowiedni typ tablicy \u003ccode\u003eteam\u003c/code\u003e a po drugiej stronie uzupełnij kod tworzący tablicę, tak aby pozostała część kodu wykonała się poprawnie. Następnie w miejscu komentarza lub pod nim przypisz wartość pola \u003ccode\u003ewife\u003c/code\u003e drugim elementem tablicy \u003ccode\u003eteam\u003c/code\u003e.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 3",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eOdwołanie do klasy bazowej - słowo \u003csamp\u003esuper\u003c/samp\u003e\u003c/h1\u003e\n\u003cp\u003e\nPrzyjrzyjmy się konstruktorowi klasy \u003csamp\u003eWorker\u003c/samp\u003e:\n\u003c/p\u003e\n  \u003cpre\u003e\n  \u003ccode\u003e\n  class Worker extends Person{\n    ...\n\n    public Worker(String firstName, String lastName, LocalDate birthDate, String position, double salary) {\n    this.lastName \u003d lastName;\n    this.firstName \u003d firstName;\n    this.birthDate \u003d birthDate;\n    this.position \u003d position;\n    this.salary \u003d salary;\n    }\n\n    ...\n  }\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Pierwsze trzy wiersze to powtórzenie zawartości konstruktora klasy \u003csamp\u003ePerson\u003c/samp\u003e, który\n  można wywołać stosując słowo kluczowe \u003csamp\u003esuper\u003c/samp\u003e, które zastępuje nazwę klasy, z której następuje dziedziczenie:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  class Worker extends Person{\n    ...\n\n    public Worker(String firstName, String lastName, LocalDate birthDate, String position, double salary) {\n    super(firstName, lastName, birthDate);\n    this.position \u003d position;\n    this.salary \u003d salary;\n    }\n\n    ...\n  }\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Posługując sie tym słowem, można także uprościć ciało metody \u003csamp\u003etoString()\u003c/samp\u003e wywołując\n  metodę \u003csamp\u003etoString()\u003c/samp\u003e zdefiniowaną w klasie \u003csamp\u003ePerson\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  class Worker extends Person{\n    ...\n    public String toString(){\n        return super.toString()+\" \"+position+\" \"+salary;\n    }\n\n  }\n  \u003c/code\u003e\n  \u003cp\u003e\n  \u003c/p\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Cześć 4",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Person {\n  protected String firstName;\n  protected String lastName;\n\n  public Person(){\n    firstName \u003d \"brak\";\n    lastName \u003d \"brak\";\n  }\n\n  public Person(String firstName, String lastName){\n    this.firstName \u003d firstName;\n    this.lastName \u003d lastName;\n  }\n}\n\nclass Worker extends Person{\n  String position;\n\n\n  public Worker(String position){\n    this.position \u003d position;\n  }\n\n  public String toString(){\n    return firstName+\" \"+lastName+\" \"+position;\n  }\n}\n\nclass Task {\n public static void main(String[] args){\n   Worker w \u003d new Worker(\"magazynier\");\n   System.out.println(w);\n }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eTworzenie obiektów klas pochodnych\u003c/h1\u003e\n\u003cp\u003e\n  Kolejność operacji wykonywanych w trakcie inicjacji obiektu klasy pochodnej jest następująca:\n  \u003cul\u003e\n  \u003cli\u003e\n    wywołanie konstruktora klasy pochodnej,\n  \u003c/li\u003e\n  \u003cli\u003e\n    jeśli pierwszą instrukcją konstruktora jest \u003csamp\u003esuper(args) \u003c/samp\u003eto wykonywany\n    jest odpowiedni konstruktor klasy bazowej,\n  \u003c/li\u003e\n  \u003cli\u003e\n    w przypadku braku \u003csamp\u003esuper\u003c/samp\u003e wykonywany jest niejawnie konstruktor\n    bezparametrowy klasy bazowej,\n  \u003c/li\u003e\n  \u003cli\u003e\n    wykonywane są instrukje konstruktora klasy pochodnej.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n  Popatrzmy na przykład klasy \u003csamp\u003ePerson\u003c/samp\u003e i \u003csamp\u003eWorker\u003c/samp\u003e\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  class Person {\n    String firstName;\n    String lastName;\n\n    public Person(){\n      firstName \u003d \"brak\";\n      lastName \u003d \"brak\"\n    }\n\n    public Person(String firstName, String lastName){\n      this.firstName \u003d firstName;\n      this.lastName \u003d lastName;\n    }\n  }\n\n  class Worker extends Person{\n    String position;\n\n    public Worker(String position){\n      this.position \u003d position;\n    }\n\n    @Override\n    public String toString(){\n      return firstName+\" \"+lastName+\" \"+position;\n    }\n  }\n\n  ...\n\n  Worker w \u003d new Worker(\"magazynier\");\n  System.out.println(w);\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  W efekcie zostanie wyświetlony napis:\n\u003c/p\u003e\n\u003csamp\u003e\n  brak brak magazynier\n\u003c/samp\u003e\n\u003cp\u003e\n  Ponieważ w konstruktorze klasy \u003csamp\u003eWorker\u003c/samp\u003e brak wywołania konstruktora klasy\n  \u003csamp\u003ePerson\u003c/samp\u003e przez \u003csamp\u003esuper(firstName, lastName)\u003c/samp\u003e, to niejawnie został\n  wywołany konstruktor bezparametrowy, w którym polom \u003csamp\u003efirstName\u003c/samp\u003e i\n  \u003csamp\u003elastName\u003c/samp\u003e przypisany został napis \"brak\" i stąd taki efekt.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Cześć 5",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Person{\n  protected String name;\n\n  public Person(String name){\n    this.name \u003d name;\n  }\n\n  public Person(){\n  }\n\n  public String getName(){\n    return name;\n  }\n}\n\nclass Worker extends Person{\n  protected char[] name;\n\n  public Worker(char[] name){\n    this.name \u003d name;\n  }\n\n  public String getName(){\n    return new String(name);\n  }\n}\n\nclass Task {\n  public static void main(String[] args) {\n    Person p \u003d new Worker(\"Adam\".toCharArray());\n    System.out.println(p.getName());\n    System.out.println(p.name);\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003ePokrywanie składowych\u003c/h1\u003e\n\u003cp\u003e\n    Kolejnym elementem dziedziczenia jest możliwość pokrywania pól i metod statycznych.\n    W klasie pochodnej możemy dodać pole o identycznej nazwie ale innym typie i tym samym\n    tracimy możliwość odwoływania się do odpowiedniego pola z klasy bazowej.\n    W przypadku metod statycznych pokrycie polega na zdefiniowaniu metody z klasy bazowej o takiej samej sygnaturze w klasie pochodnej.\n\u003c/p\u003e\n\u003cp\u003e\n    Możliwe jest także zadeklarowanie pola o tej samej nazwie co w klasie bazowej.\n    W klasie \u003csamp\u003eWorker\u003c/samp\u003e zmienimy typ odziedziczonego pola \u003csamp\u003ename\u003c/samp\u003e na \u003csamp\u003echar[]\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass Person{\n  protected String name;\n  public Person(String name){\n    this.name \u003d name;\n  }\n\n  public Person(){\n  }\n\n  public String getName(){\n    return name;\n  }\n}\n\nclass Worker extends Person{\n  protected char[] name;\n  public Worker(char[] name){\n    this.name \u003d name;\n  }\n\n  public String getName(){\n    return new String(name);\n  }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    Person p \u003d new Worker(\"Adam\".toCharArray());\n    System.out.println(p.getName());\n    System.out.println(p.name);\n  }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Efektem programu jest są napisy:\n\u003c/p\u003e\n\u003csamp\u003e\n    Adam\u003cbr\u003e\n    null\n\u003c/samp\u003e\n\u003cp\u003e\n    Przykład ten ilustruje, że pole \u003csamp\u003ename\u003c/samp\u003e klasy \u003csamp\u003eWorker\u003c/samp\u003e to inne pole niż \u003csamp\u003ename\u003c/samp\u003e\n    z klasy \u003csamp\u003ePerson\u003c/samp\u003e. Przykrycie powoduje, że chociaż zostało ono odziedziczone, to nie można się do\n    niego odwołać dla obiektu klasy \u003csamp\u003eWorker\u003c/samp\u003e. Ponieważ referencja \u003csamp\u003ep\u003c/samp\u003e jest typu\n    \u003csamp\u003ePerson\u003c/samp\u003e, więc odwołanie \u003csamp\u003ep.name\u003c/samp\u003e dotyczyło pola z klasy \u003csamp\u003ePerson\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n    Gdy odwołaliśmy się do metody \u003csamp\u003egetName()\u003c/samp\u003e to wybrana została metoda zgodna nie z typem referencji\n    ale z typem obiektu, dlatego została wywołana metoda należąca do klasy \u003csamp\u003eWorker\u003c/samp\u003e i\n    otrzymaliśmy poprawny wynik, pomimo przykrycia pola \u003csamp\u003ename\u003c/samp\u003e.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 6",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Box{\n  final int width;\n  final int height;\n\n  public Box(int width, int height){\n    this.width \u003d width;\n    this.height \u003d height;\n  }\n\n  final public Box extend(int dw, int dh){\n    return new Box(width+dw, height+dh);\n  }\n}\n\nclass Cube extends Box{\n  final int depth;\n\n  public Cube(int w, int h, int d){\n    super(w, h);\n    this.depth \u003d d;\n  }\n  //to nie jest metoda odziedziczona - inny typ zwracany\n  public Cube extend(int dw, int dh, int dd){\n    return new Cube(width + dw, height+dh, depth + dd);\n  }\n  //sygnatura metody odziedziczonej - nie można nadpisać bo jest\n  public Box extend(int dw, int dd){\n      return new Box( width + dw, depth + dd);\n  }\n}\n\nclass Task {\n  static public void main(String[] args){\n    Box b \u003d new Box(1, 4);\n    b \u003d b.extend(2,5);\n    System.out.println(b.height+\" \"+ b.width);\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eBlokowanie dziedziczenia\u003c/h1\u003e\n\u003cp\u003e\n    Posługując się słowem kluczowym \u003csamp\u003efinal\u003c/samp\u003e można zablokować możliwość\n    dziedziczenia klasy lub nadpisywania metod. Wiele klas bibliotecznych jest definniowanych\n    jako \u003csamp\u003efinal\u003c/samp\u003e np. java.lang.String.\n\u003c/p\u003e\n\u003cp\u003e\n    Przykład klasy finalnej:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nfinal class Point {\n    final int x;\n    final int y;\n    public Point(int x, int y){\n        this.x \u003d x;\n        this.y \u003d y;\n    }\n}\n        \u003c/code\u003e\n    \u003c/pre\u003e\n\u003cp\u003e\n    Przykład klasy z metodą finalną:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass Box{\n  final int width;\n  final int height;\n\n  public Box(int width, int height){\n    this.width \u003d width;\n    this.height \u003d height;\n  }\n\n  final public Box extend(int dw, int dh){\n    return new Box(width+dw, height+dh);\n  }\n}\n\nclass Cube extends Box{\n  final int depth;\n\n  public Cube(int w, int h, int d){\n    super(w, h);\n    this.depth \u003d d;\n  }\n\n  public Cube extend(int dw, int dh, int dd){\n    return new Cube(width + dw, height+dh, depth + dd);\n  }\n\n  public Box extend(int dw, int dd){\n      return new Box( width + dw, depth + dd);\n  }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eW przykładzie zablokowana została metoda \u003csamp\u003eextend\u003c/samp\u003e przed nadpisaniem w\nklasach pochodnych. W klasie \u003csamp\u003eCube\u003c/samp\u003e wyprowadzonej z \u003csamp\u003eBox\u003c/samp\u003e\n    zdefiniowano \u003csamp\u003eextend\u003c/samp\u003e, ale nie jest to nadpisanie, gdyż ma inną sygnaturę.\u003c/p\u003e\n\u003cp\u003ePróba nadpisania metody finalnej spowoduje wygenerowanie błędu kompilacji:\u003c/p\u003e\n\u003csamp\u003e\n    Error:(27, 14) java: extend(int,int) in Cube cannot override extend(int,int) in Box\n    overridden method is final\n\u003c/samp\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Podsumowanie",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\n  Podsumowanie wiadomości o dziedziczeniu w Java:\n  \u003cul\u003e\n  \u003cli\u003e\n    powoduje przejmowanie wszystkich pól i metod.\n  \u003c/li\u003e\n  \u003cli\u003e\n    w klasie pochodnej dostępne są tylko nieprywatne składowe,\n  \u003c/li\u003e\n  \u003cli\u003e\n    umożliwia przejmowanie składowych tylko z jednej klasy, nie można dziedziczyć po wielu klasach,\n  \u003c/li\u003e\n  \u003cli\u003e\n    każda klasa, której nie wskażemy klasy bazowej, dziedziczy domyślnie po klasie \u003csamp\u003eObject\u003c/samp\u003e,\n  \u003c/li\u003e\n  \u003cli\u003e\n    w zmiennych typu bazowego można umieszczać obiekty klasy wyprowadzonej, czyli w miejscu rodzica\n    można umieścić obiekty potomne,\n  \u003c/li\u003e\n  \u003cli\u003e\n    przedefiniowanie odziedziczonych metod następuje przez nadpisywanie, metody nadpisywane oznaczamy\n    adnotacją \u003csamp\u003e@Override\u003c/samp\u003e a sygnatura metody w klasie pochodnej musi być identyczna\n    z metodą nadpisywaną.\n  \u003c/li\u003e\n  \u003cli\u003e\n    W klasie potomnej można odwoływać się do klasy bazowej słowem kluczowym \u003csamp\u003esuper\u003c/samp\u003e np. \u003csamp\u003e\n    super() to wywołanie konstruktora, a \u003csamp\u003esuper.metoda\u003c/samp\u003e to wywołanie metody.\n  \u003c/samp\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    Przy inicjowaniu obiektów klas pochodnych jest niejawnie wywoływany bezparametrowy konstruktor klasy\n    bazowej, jeśli w konstuktorze klasy wyprowadzonej nie ma jawnego wywołania poprzez \u003csamp\u003esuper()\u003c/samp\u003e.\n  \u003c/li\u003e\n  \u003cli\u003e\n    zablokowanie możliwości dziedziczenia z danej klasy polega na dodaniu słowa kluczowego \u003csamp\u003efinal\u003c/samp\u003e\n    przy deklaracji klasy.\n  \u003c/li\u003e\n  \u003cli\u003e\n    zablokowanie nadpisywania metody w klasie potomnje powoduje dodanie słowa kluczowego\n    \u003csamp\u003efinal\u003c/samp\u003e w sygnaturze metody klasy bazowej.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Klasy abstrakcyjne",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "abstract class Vehicle {\n  protected final double weight;\n  protected double mileage;\n\n  public Vehicle(double weight){\n    this.weight \u003d weight;\n  }\n  public double getMileage(){\n    return mileage;\n  }\n\n  public double getWeigth(){\n    return weight;\n  }\n}\n\nclass Car extends Vehicle{\n  private final double power;\n  private final double fuelCapacity;\n  private double fuelLevel;\n\n  public Car(double weight, double power, double fuelCapacity) {\n    super(weight);\n    this.fuelCapacity \u003d fuelCapacity;\n    this.power \u003d power;\n  }\n\n  public double getFuelLevel(){\n    return fuelLevel;\n  }\n}\n\npublic class Task{\n  static public void main(String[] args){\n    Vehicle car \u003d new Car(1000, 100, 50);\n    System.out.println(car.getWeigth());\n  }\n}\n"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\n    KLasy abtrakcyjne to inaczej klasy uogólniające, które służą jedynie do budowy klasa bazowych. nie jest\n    możliwe tworzenie obiektów takich klas, można jedynie ich używać do dziedziczenia.\n\u003c/p\u003e\n\u003cp\u003e\n    Przykład klasy abstrakcyjnej:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\npublic abstract class Vehicle {\n  protected final double weight;\n  protected double mileage;\n\n  public Vehicle(double weight){\n     this.weight \u003d weight;\n  }\n  public double getMileage(){\n    return mileage;\n  }\n\n  public double getWeigth(){\n   return weigth;\n  }\n}\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Klasa \u003csamp\u003eVehicle\u003c/samp\u003e posłuży do budowy klas konkretnych pojazdów:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\npublic class Car extends Vehicle{\n  private final double power;\n  private final double fuelCapacity;\n  private double fuelLevel;\n\n  public Car(double weight, double power, double fuelCapacity) {\n    super(weight);\n    this.fuelCapacity \u003d fuelCapacity;\n    this.power \u003d power;\n  }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    W klasie abtrakcyjnej pola, które mają być dziedziczone nie mogą być prywatne, dlatego pola\n    \u003csamp\u003eweight\u003c/samp\u003e i \u003csamp\u003emileage\u003c/samp\u003e są typu \u003csamp\u003eprotected\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n    Aby utworzyć obiekt typu \u003csamp\u003eCar\u003c/samp\u003e można posłużyć się referencją do klasy bazowej:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nVehicle car \u003d new Car(10, 100, 45);\nSystem.out.println(car.getWeigth());\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Każda próba zastosowania operatora new dla klasy abstrakcyjnej spowoduje wygenerowanie błędu podczas kompilacji:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\n        Vehicle car \u003d new Vahicle(1000);\n\n        --\n        Error:(35, 19) java: Vehicle is abstract; cannot be instantiated\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Zadanie 1",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\nWrite your task text here.\n\u003cbr\u003e\n\u003cbr\u003e\n\u003cdiv class\u003d\"hint\"\u003e\n  You can add hints anywhere in task text. Copy all hint div block and change its content.\n\u003c/div\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 2",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\n  W klasach abtrakcyjnych można także umieszczać metody abtrakcyjne, które nie są w niej definiowane.\n  Klasa dziedzicząca po klasie abtrakcyjne ma obowiązek zdefiniować wszyskie takie metody.\n  Metody abtrakcyjne są metodą tworzenia interfejsu, czy zbioru zachowań, które muszą realizować\n  wszystkie klasy potomne.\n\u003c/p\u003e\n\u003cp\u003e\n  Wróćmy do klasy \u003csamp\u003eVehicle\u003c/samp\u003e, w której zdefiniujmy dwie metody abstrakcyjne \u003csamp\u003estart()\u003c/samp\u003e i \u003csamp\u003estop()\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\npublic abstract class Vehicle {\n  protected double weight;\n  protected double mileage;\n\n  public Vehicle(double weight){\n    this.weight \u003d weight;\n  }\n\n  public abstract void start();\n\n  public abstract void stop();\n\n  public double getMileage(){\n    return mileage;\n  }\n\n  public double getWeigth(){\n    return weigth;\n  }\n}\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Metoda abstrakcyjna zawiera jedynie nagłówek zawierający typ zwracany, nazwę i listę argumentów, nie\n  ma natomiast bloku z instrukcjami.\n\u003c/p\u003e\n\u003cp\u003eKlasa \u003csamp\u003eCar\u003c/samp\u003e musi teraz zdefiniować obie metody abstrakcyjne:\n\u003cpre\u003e\n  \u003ccode\u003e\npublic class Car extends Vehicle{\n  private double power;\n  private double fuelCapacity;\n  private double fuelLevel;\n\n  public Car(double weight, double power, double fuelCapacity) {\n      super(weight);\n      this.fuelCapacity \u003d fuelCapacity;\n      this.power \u003d power;\n  }\n\n  @Override\n  public void start() {\n      System.out.println(\"The car is moving\");\n  }\n\n  @Override\n  public void stop() {\n      System.out.println(\"The car stops\");\n  }\n}\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Jeśli utworzymy kolejne klasy konkretnych pojazdów jak \u003csamp\u003eBicycle\u003c/samp\u003e, \u003csamp\u003eTrain\u003c/samp\u003e,\n  to każda z klas, będzie musiała zdefiniować obie metody abstrakcyjne (przyjmijmy, że będzie to\n  tylko wyświetlanie podobnego komunkatu jak w klasie Car).\n\u003c/p\u003e\n\u003cp\u003e\n  Wszystie metody zdefiniowane w klasie abtrakcyjnej pełnią rolę interfejsowych, gdyż możemy teraz tworzyć\n  obiekty każdej konkretnej klasy i przypisać je do referencji typu klasy bazowej \u003csamp\u003eVehicle\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n    Vehicle[] vehicles \u003d new Vehicle[3];\n    vehicle[0] \u003d new Car(1200, 100, 45);\n    vehicle[1] \u003d new Bicycle(15);\n    vehicle[2] \u003d new Train(25000);\n    for(Vehicle v: vehicles){\n      System.out.println(v.start());\n      System.out.println(v.stop());\n      System.out.println(v.getWeight());\n    }\n\n    ---\n    The car is moving\n    The car stops\n    1200\n    The bicycle is moving\n    The bicycle stops\n    15\n    The train is moving\n    The train stops\n    25000\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Zadanie 2",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\nWrite your task text here.\n\u003cbr\u003e\n\u003cbr\u003e\n\u003cdiv class\u003d\"hint\"\u003e\n  You can add hints anywhere in task text. Copy all hint div block and change its content.\n\u003c/div\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 3",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "abstract class Vehicle {\n  protected final double weight;\n  protected double mileage;\n\n  public Vehicle(double weight){\n    this.weight \u003d weight;\n  }\n  public double getMileage(){\n    return mileage;\n  }\n\n  public double getWeigth(){\n    return weight;\n  }\n  public abstract void start();\n  public abstract void stop();\n}\n\nclass Car extends Vehicle{\n  private final double power;\n  private final double fuelCapacity;\n  private double fuelLevel;\n\n  public Car(double weight, double power, double fuelCapacity) {\n    super(weight);\n    this.fuelCapacity \u003d fuelCapacity;\n    this.power \u003d power;\n  }\n\n  public double getFuelLevel(){\n    return fuelLevel;\n  }\n\n  @Override\n  public void start() {\n    System.out.println(\"The car starts moving\");\n  }\n\n  @Override\n  public void stop() {\n    System.out.println(\"The car stops\");\n  }\n}\n\nclass Bicycle extends Vehicle{\n  private int gears;\n\n  public Bicycle(double weight, int gears) {\n    super(weight);\n    this.gears \u003d gears;\n  }\n\n  @Override\n  public void start() {\n    System.out.println(\"The bike starts moving\");\n  }\n\n  @Override\n  public void stop() {\n    System.out.println(\"The bike stops\");\n  }\n}\n\nclass Train extends Vehicle{\n\n  private double power;\n\n  public Train(double weight, double power) {\n    super(weight);\n    this.power \u003d power;\n  }\n\n  @Override\n  public void start() {\n    System.out.println(\"The train starts moving\");\n  }\n\n  @Override\n  public void stop() {\n    System.out.println(\"The train stops\");\n  }\n}\n\npublic class Task{\n  static public void main(String[] args){\n    Vehicle[] vehicles \u003d new Vehicle[3];\n    vehicles[0] \u003d new Car(1200, 100, 50);\n    vehicles[1] \u003d new Bicycle(15, 5);\n    vehicles[2] \u003d new Train(250000, 1000);\n    for(Vehicle v: vehicles){\n      v.start();\n      if (v instanceof Car)\n        System.out.println(\"The fule level in car \u003d \" +((Car) v).getFuelLevel());\n    }\n  }\n}\n"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003einstanceof\u003c/h1\u003e\n\u003cp\u003e\n  Po przypisaniu do referencji klasy bazowej obiekt klasy potomnej, możemy odwoływać się tylko do metod\n  klasy bazowej ale tracimy dostęp do metod dadonych klasie potomnej.\n  Można przywrócić właściwą referencję poprzez rzutowanie. Pojawia się jednak pytanie skąd zdobyć informację\n  jakiego właściwego typu jest referencja. Do testowania czy referencja jest danego typu służy operator\n  \u003csamp\u003einstanceof\u003c/samp\u003e\n\u003c/p\u003e\n\u003cp\u003e\n  Klasa \u003csamp\u003eCar\u003c/samp\u003e ma dodaną metodę \u003csamp\u003egetFuelLevel()\u003c/samp\u003e do odczytywania poziomu zatankowanego paliwa\u003c/p\u003e\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  public class Car extends Vehicle{\n    private double power;\n    private double fuelCapacity;\n    private double fuelLevel;\n\n    public Car(double weight, double power, double fuelCapacity) {\n        super(weight);\n        this.fuelCapacity \u003d fuelCapacity;\n        this.power \u003d power;\n    }\n\n    @Override\n    public void start() {\n        System.out.println(\"The car is moving\");\n    }\n\n    @Override\n    public void stop() {\n        System.out.println(\"The car stops\");\n    }\n\n    public double getFuelLevel(){\n      return fuelLevel;\n    }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eW poprzednim przykładzie umieścilismy obiekty wszystkich klas wyprowadzonych z \u003csamp\u003eVehicle\u003c/samp\u003e w tablicy\ntego typu:\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n    Vehicle[] vehicles \u003d new Vehicle[3];\n    vehicle[0] \u003d new Car(1200, 100, 45);\n    vehicle[1] \u003d new Bicycle(15);\n    vehicle[2] \u003d new Train(25000);\n    for(Vehicle v: vehicles){\n      System.out.println(v.start());\n      System.out.println(v.stop());\n      System.out.println(v.getWeight());\n    }\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  W pętli \u003csamp\u003eforeach\u003c/samp\u003e odczytujemy kolejne obiekty i wywołujemy metody z klasy bazowej. Jeśli\n  chcielibyśmy odczytać stan paliwa to możliwe będzie to tylko dla obietów typu \u003csamp\u003eCar\u003c/samp\u003e. Żeby rozpoznać\n  który z elmentów tablicy \u003csamp\u003evehicle\u003c/samp\u003e jest takim obiektem zsotujemy operator \u003csamp\u003einstanceof\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  for(Vehicle v: vehicles){\n    v.start();\n    if (v instanceof Car)\n      System.out.println(\"The fule level in car \u003d \" +((Car) v).getFuelLevel());\n  }\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  wyrażenie \u003csamp\u003ev instanceof Car\u003c/samp\u003e zwraca wartość \u003csamp\u003etrue\u003c/samp\u003e, gdy obiet \u003csamp\u003ev\u003c/samp\u003e jest klasy\n  \u003csamp\u003eCar\u003c/samp\u003e. Po upewnieniu się jakiej klasy jest obiekt możemy wykonać rzutowanie na właściwą klasę\n  \u003csamp\u003e(Car) v\u003c/samp\u003e, a potem wywołać metodę tej klasy \u003csamp\u003e((Car) v).getFuelLevel()\u003c/samp\u003e.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Polimorfizm",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\nPolimorfizm, inaczej wielopostaciowość, to mechanizm, z którym już spotkaliśmy się.\n    Popatrzmy na prosty przykład dwóch wyrażeń:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\n    int liczba \u003d 12;\n    String str \u003d \"12\";\n    System.out.println(liczba + 12);\n    System.out.println(str+12);\n\n    --\n    24\n    1212\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nW obu wyrażeniach wykorzystaliśmy ten sam operator \u0027+\u0027, ale wyniki obu działń są różne.\nOperator + jest polimorficzny, gdyż wykonuje dwa różne działania: dla typów prostych\n    liczbowych wykonuje arytemtyczne dodawania, a w sytuacji, gdy jednym z operandów\n    jest łańcuch wykonywana jest konkatenacja z zamienionym na łańcuch drugim operandem.\nZatem polimorfizm do różne działanie tego samego operatora lub metody w zależności od kontekstu.\n\u003c/p\u003e\n\u003cp\u003e\n    Z polimorfizmem metod spotkaliśmy się już kilkukrotnie omawiając dziedziczenie i klasy abstrakcyjne.\n    Dla przypomnienia wywoływanie metod toString() obiektów róznych klas jest przykładem polimorfizmu,\n    gdyż każdy z obiektów innaczej ją realizuje. Także metody start() i stop() w klasie abstrakcyjne, a następnie\n    definiowane w klasach Car, Bicycle i Train są także polimorficzne.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 2",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eRodzaje polimorfizmu\u003c/h1\u003e\n\u003cp\u003e\n  Rozróżnia się dwa rodzaje polimorfizmu:\n  \u003cul\u003e\n  \u003cli\u003e\n    statyczny\n  \u003c/li\u003e\n  \u003cli\u003e\n    dynamiczny\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/html\u003e\n\u003cp\u003e\n  Przykładem polimorfizmu statycznego jest opisany operator \u0027+\u0027, gdyż już\n  na podstawie wyrażenia i typu jego operandów można przewidzić jakie zostanie wykonane zachowanie\n  i to zachowanie nie zmieni się w trakcie działania programu.\n\u003cp\u003e\n  Szczególnym rodzajem polimorfizmu jest przeładowanie metody (ang. overriding), z czym skotkaliśmy się\n  przy okazji definiowania konstruktorów. Tam określenie, który konstruktor jest wywoływany,\n  następowało na podstawie typu argumentu.\n\u003c/p\u003e\n  W przypadku polimorfizm dynamicznego określenie, które działanie dla danej metody jest wywoływane,\nnastępuje dopiero podczas działania programu. Wnioskowanie następuje na podstawie rzeczywistej klasy\nobiektu, na rzecz którego wywoływan jest metoda polimorficzna.\n\u003c/p\u003e\n\u003cp\u003e\n  Popatrzmy na poniższy przykład:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n    Scanner input \u003d new Scanner(System.in);\n    System.out.println(\"Wpisz nazwę klasy:\");\n    String klasa \u003d input.nextLine();\n    Vehicle pojazd \u003d null;\n    switch(klasa){\n      case \"Car\":\n        pojazd \u003d new Car(1200, 145, 50);\n        break;\n      case \"Bicycle\":\n        pojazd \u003d new Bicycle(15, 3);\n        break;\n    }\n\n    if (pojazd !\u003d null)\n      pojazd.start();\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003c/p\u003e\n\u003cp\u003e\n  To co znajdzie się w zmiennej \u003csamp\u003epojazd\u003c/samp\u003e, zależy od użytkownika, więc na etapie opacowywania programu\n  nie wiadomo, która metoda \u003csamp\u003epojazd.start()\u003c/samp\u003e zostanie wywołana. Dopiero w trakcie działania programu\n  zostanie utworzony obiekt i przypisany do zmiennej. Wtedy też zostanie wybrana właściwa metoda\n  \u003csamp\u003estart()\u003c/samp\u003e. Informacji tej dostarcza rzeczywisty typ obiektu zwrócony przez operator \u003csamp\u003enew\u003c/samp\u003e.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Agregacja i kompozycja",
          "task_list": [
            {
              "name": "Agregacja",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\nChoć z terminem tym dotąd nie spotkaliśmy się, to wiele\nprzykładów klas korzystało z tego rozwiązania.\nPrzypomnijmy klasę \u003csamp\u003ePerson\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003e\npublic class Person {\n    public String firstName;\n    public String lastName;\n    public LocalDate birthDate;\n\n    public Person(String firstName, String lastName, LocalDate birthDate) {\n        this.firstName \u003d firstName;\n        this.lastName \u003d lastName;\n        this.birthDate \u003d birthDate;\n    }\n\n    public String toString(){\n        return firstName +\" \"+lastName+\" \"+birthDate;\n    }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Agregacja to zawieranie się obiektów innych\n    klas w definiowanej klasie. W przykładzie\n    wszystkie pola są obiektami klas: \u003csamp\u003eString\u003c/samp\u003e i \u003csamp\u003eLocalDate\u003c/samp\u003e.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Kompozycja",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Engine{\n  final double nominalPwer;\n  public Engine(double pnominalPower){\n    this.nominalPwer \u003d pnominalPower;\n  }\n}\n\nclass Car{\n  private Engine engine;\n  String name;\n  public Car(double power){\n    this.engine \u003d new Engine(power);\n  }\n\n  public String start(){\n    if (engine !\u003d null){\n      return \"Start\";\n    } else {\n      return \"Can\u0027t start,no engine\";\n    }\n  }\n}\n\nclass Task {\n  public static void main(String[] args) {\n\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\nSzczególnym rodzajem agregacji jest kompozycja, gdy obiekty składowe mogą istnieć tylko\nw obiekcie je zawierającym, tak jak i istnienie obiektu nadrzędnego nie ma sensu bez\njego obiektów składowych. Przykładem może być silnik i samochód. Istnienie silnika\nbez samochodu nie ma sensu, bo jego przeznaczeniem jest napędzanie samochodu, jest\njego składnikiem. Samochód bez silnika przestaje być samochodem, jest niekompletny.\n\u003c/p\u003e\n\u003cp\u003e\n  Jednocześnie nie należy mylić kompozycji z agregacją. Przykładowo klasa \u003csamp\u003ekontener na butelki\u003c/samp\u003e\n  i \u003csamp\u003epiwo w butelkach\u003c/samp\u003e nie są dobrym przykładem kompozycji. Sam kontener\n  może przechowywać różne butelki,\n  niekoniecznie zawierające piwo, wystarczy, że butelka będzie miała odpowiedni\n  wymiar. Piwo w butelce nie musi być przechowywane ciągle w kontenerze, może\n  potem znaleźć się w lodówce, więc może istnieć bez tego obiektu i tym samym klasy.\n\u003c/p\u003e\n\u003cp\u003e\n  W prezentowanym w poprzedniej części przykładzie zarówno typ String jak i LocalDate\n  są bardzo uniwrsalne i moga stanowić zarówno składowe innych klas jak i istnieć\n  samodzielnie, więc klasa Person jest przykładem agregacji.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Kompozycja jako alternatywa dziedziczenia",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\n\nclass Person {\n  protected String firstName;\n  protected String lastName;\n\n  public Person(String firstName, String lastName) {\n    this.firstName \u003d firstName;\n    this.lastName \u003d lastName;\n  }\n}\n\nclass Worker extends Person{\n  protected String position;\n  protected double salary;\n\n  public Worker(String firstName, String lastName, String position, double salary){\n    super(firstName, lastName);\n    this.position \u003d position;\n    this.salary \u003d salary;\n  }\n}\n\n\nclass Task {\n  public static void main(String[] args) {\n  Person adam \u003d new Worker(\"ADAM\", \"KOWAL\", \"magazynier\", 2000);\n  System.out.println(adam.firstName);\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\n  Kompozycja (agregacja) może być częściowo alternatywą dla dziedziczenia. Popatrzmy na\n  przykład rozszerzenia klasy \u003csamp\u003eWorker\u003c/samp\u003e przy pomocy klasy \u003csamp\u003ePerson\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  class Worker {\n    private Person personalData;\n    String position;\n    double salary;\n\n    public Worker(String firstName, String lastName, String position, double salary){\n      personalData \u003d new Person(firstName. lastName);\n      this.position \u003d position;\n      this.salary \u003d salary;\n    }\n  }\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Dane osobowe są polem typu \u003csamp\u003ePerson\u003c/samp\u003e i aby odczytać jej składowe mamy dwie możliwości:\n  \u003col\u003e\n    \u003cli\u003e\n      dodać getter zwracający cały obiekt personlData, wtedy dostęp do jego\n      pól zależy od getterów klasy \u003csamp\u003ePerson\u003c/samp\u003e.\n    \u003c/li\u003e\n  \u003cli\u003e\n    dodać gettery dla każdego pola klasy \u003csamp\u003ePerson\u003c/samp\u003e, wtedy klasa Worker\n    w pełni kontroluje dane.\n  \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eW pierwszym przypadku definiujemy getter getPersonlaData, który zwraca obiekt klasy Person\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  class Worker {\n    private Person personalData;\n    String position;\n    double salary;\n\n    public Worker(String firstName, String lastName, String position, double salary){\n      personalData \u003d new Person(firstName. lastName);\n      this.position \u003d position;\n      this.salary \u003d salary;\n    }\n\n    public Person getPersonalData(){\n      return personalData;\n    }\n  }\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Odczyt imienia lub nazwiska wymaga teraz znajomości metod obiektu \u003csamp\u003ePerson\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n    Worker builder \u003d new Worker(\"ADAM\", \"NOWAK\", \"mistrz\", 2500);\n    System.out.println(builder.getPersonlaData().getFistName());\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eW drugim przypadku tworzymy dla każdego pola \u003csamp\u003epersonalData\u003c/samp\u003e metodę odczytującą każde pole\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  class Worker {\n    private Person personalData;\n    String position;\n    double salary;\n\n    public Worker(String firstName, String lastName, String position, double salary){\n      personalData \u003d new Person(firstName. lastName);\n      this.position \u003d position;\n      this.salary \u003d salary;\n    }\n\n    public String getFirstName(){\n      return personalData.getFirstName();\n    }\n\n    public String getLastName(){\n      return personalData.getLastName();\n    }\n  }\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eDrugie rozwiązanie wymaga więcej tworzenia kodu, ale z punktu widzenia klienta klasy jest bardzie przejrzyste.\nMa też inne zalety które, omówimy w następnym rozdziale.\u003c/p\u003e\n\u003cp\u003eStosując kompozycję utraciliśmy pewne właściwości wynikające z dziedziczenia i polimorfizmu,\nstosując interfejsy możemy odzyskać te własności.\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Hermetyzacja",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class User{\n  private String name;\n\n  public User(String name){\n    this.name \u003d name;\n  }\n\n  public String getName(){\n    return name;\n  }\n}\n\n\nclass Admin extends User{\n  private String rights;\n  public Admin(String name, String rights){\n    super(name);\n    this.rights \u003d rights;\n  }\n\n  public String getName(){\n    return super.getName();\n  }\n}\n\nclass Task {\n  public static void main(String[] args){\n    User p1 \u003d new User(\"MISIEK\");\n    User p2 \u003d new Admin(\"SUPER\", \"AAAE\");\n    System.out.println(p1.getName());\n    System.out.println(p2.getName());\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\n  Hermetyzacja to ukrywanie i zamykanie wewnętrznych mechanizmów klasy przed światem zewnętrznym. Klient korzystający\n  z naszej klasy nie powinien zaburzać działania tego co się dzieje wenątrz klasy, dlatego ukrycie i zablokowanie\n  dostępu do części pól i metod jest bardzo ważne. Celem jest stworzenie klas, które zachowują się\n  jak czarne, magiczne pudełko, które właściwie reagują tylko na udostępnione przyciski, nie dając możliwości\n  zajrzenia do środka, co mogłoby zaburzyć właściwe działanie.\n\u003c/p\u003e\n\u003cp\u003e\n  Podstawową metodą ukrywania jest stosowanie modyfikatora \u003csamp\u003eprivate\u003c/samp\u003e. Problem pojawia się\n  jednak w sytuacji, gdy chcemy budować hierarchie klas z użyciem dziedziczenia, bo mamy dostęp do odziedziczonych\n  pól z modyfiaktorem \u003csamp\u003epublic\u003c/samp\u003e lub \u003csamp\u003eprotected\u003c/samp\u003e. Tym samym dostęp do tych pól\n  mają nie tylko klasy potomne, ale także wszystkie klasy tego samego pakietu.\n\u003c/p\u003e\n\u003cp\u003eMożemy ograniczyć dostęp do wybranych pól klas bazowych definiując je jako\n  pole prywatne dodając tylko akcesor publiczny dający możliwość tylko odczytu.\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass User{\n  private String name;\n\n  public User(String name){\n    this.name \u003d name;\n  }\n\n  public String getName(){\n    return name;\n  }\n}\n\n\nclass Admin extends User{\n  private String rights;\n  public Admin(String name, String rights){\n    super(name);\n    this.rights \u003d rights;\n  }\n\n  public String getName(){\n    return super.getName();\n  }\n}\n\n...\nUser p1 \u003d new User(\"MISIEK\");\nUser p2 \u003d new Admin(\"SUPER\", \"AAAE\");\nSystem.out.println(p1.getName());\nSystem.out.println(p2.getName());\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Pomimo, że w klasie \u003csamp\u003eUser\u003c/samp\u003e pole \u003csamp\u003ename\u003c/samp\u003e jest prywatne, to widoczność zapewniliśmy definiując metodę\n  publiczną \u003csamp\u003egetName()\u003c/samp\u003e. Pole to jest dziedziczone i inicjowane konstuktorem klasy bazowej.\n  Ponieważ nie mamy żadnego bezpośredniego dostępu do tego pola w klasie \u003csamp\u003eAdmin\u003c/samp\u003e, więc dostęp\n  do niego kontroluje wyłącznie klasa bazowa. Tym samym zapewniona jest hermetyczność tego pola w klasie potomnej\n  jak i wszystkich pozostałych klasach na tym samym poziomie, a jednocześnie wykorzystaliśmy dziedziczenie.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Interfejsy",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": ""
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003e\n    Podstawy\n\u003c/h1\u003e\n\u003cp\u003e\n  Interfejsy możemy traktować jak wyspecjalizowane klasy, których zadaniem jest tylko wskazywanie innym\n  klasom jakie muszą posiadać zachowania (metody), ale nie określają jak te zachowania mają być realizowane.\n  \u003cp\u003e\n  Interfejs można porównać do klasy abstrakcyjnej, kóra posiada tylko metody abstrakcyjne. Każdy typ wyprowadzony\n  z takiej klasy musi implementować odziedziczone metody. Każda klasa wyprowadzona z takiej klasy abstrakcyjnej, posługuje\n  się tym samym językiem metod, które zostały wymienione w abstrakcyjnym typie bazowym.\n\u003c/p\u003e\n  Istotną jednak różnicą w stosunku do klasy abstrakcyjnej jest to, że klasy mogą \u0027dziedziczyć\" wiele interfejsów,\njak i to, że same interfejsy moga dziedziczyć wiele innych. Interfejsy mogą posiadać pola, jednak są on domyślnie\nstałymi.\n\u003c/p\u003e\n\u003cp\u003e\n  Rola interfejsów jest jednak znacznie szersza. O ile w dziedziczeniu klas, ten wspólny język dotyczył klas silnie ze\n  sobą związanych i bliskich, to interfejsy mogą łączyć klasy bardzo odległe. Możliwość zapewnienia drukowania,\n  zapisywania do pliku, transmisji siecią itd. może dotyczyć różnych klas.\n\u003c/p\u003e\n\u003cp\u003e\n  Zbudujmy interfejs, który będzie realizował jednolite sterowanie pojazdami:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\ninterface Driveable {\n  void start();\n  void stop();\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Słowo kluczowe \u003csamp\u003einterface\u003c/samp\u003e służy do definiowania  interfejsu, który\n  zawiera tylko sygnatury metod. Metody wymienione w intefejsie są abstrakcyjne i zawsze publiczne.\n\u003c/p\u003e\n\u003cp\u003e\n  Klasy pojazdów, którymi chcemy kierować, możemy tworzyć bez potrzeby dziedziczenia.\n  Pojazd, który ma reagować na polecenia interfejsu, musi go implementować:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  class Car implements Driveable{\n    double power;\n    double fuelLevel;\n    double fuelCapacity;\n    public Car(double power, double fuelCapacity){\n      this.power \u003d power;\n      this.fuelCapacity \u003d fuelCapacity;\n    }\n\n    @Override\n    public void start(){\n      System.out.println(\"The car starts moving\");\n    }\n\n    @Override\n    public void stop(){\n      System.out.println(\"The car stops\");\n    }\n  }\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Wskazanie jaki interfejs klasa ma zaimplementować odbywa się słowem kluczowym \u003csamp\u003eimplements\u003c/samp\u003e,\n  po którym możemy podawać dowolną liczbę interfejsów. W klasie obowiązkowo\n  należy zdefiniować wszystkie metody każdego podanego interfejsu. Metody implementowane\n  powinny być poprzedzone adnotacją \u003csamp\u003e@Override\u003c/samp\u003e, aby uniknąć pomyłki przy podaniu sygnatury metody.\n\u003c/p\u003e\n\u003cp\u003e\n  Zdefiniujmy kolejną klasę, która będzie implementować ten sam interfejs. Ty razem będzie to\n  klasa, której trudno by wyprowdzić z klasy \u003csamp\u003eVehicle\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  class Horse implements Driveable{\n    String name;\n\n    public Horse(String horse){\n      this.name \u003d name;\n    }\n\n    @Override\n    public void start(){\n      System.out.println(\"The horse starts moving\");\n    }\n\n    @Override\n    public void stop(){\n      System.out.println(\"The horse stops\");\n    }\n  }\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Podobnie jak przy dziedziczeniu, obiekty ze wspólnym interfejsem mogą być przypisane do jego referencji.\n  Popatrzmy na poniższy przykład:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  Driveable porsche \u003d new Car(245, 45);\n  Driveable horse \u003d new Horse(\"kasztanka\");\n  porsche.start();\n  horse.start();\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Auto jak i koń mogą być typu ineterfejsu, choć obu zmiennym przypisane zostaną obiekty\n  różnych typów.\n\u003c/p\u003e\n\u003cp\u003e\n  Przykład ilustruje, że interfejsy wymuszają takie same działanie jak\n  dziedziczenie z klasy bazowej. Także tutaj działa polimorfizm, bo wywoływane są metody zgodne z typem obiektu,\n  a nie referencji. Istotną różnicą jest to, że metody interfejsowe w klasie bazowej moga być definiowane,\n  a w interfejsie nie. Interfejs raczej narzuca  na klasę implementującą obowiązek\n  zdefiniowanie swoich metod, podobnie jak klasa abstrakcyjna z wyłącznie metodami abstrakcyjnymi.\n\u003c/p\u003e\n\u003cp\u003eKorzyści wynikającę z interfejsu ilustruje poniższy przykład:\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\ninterface Soundable{\n    String getSound();\n}\n\nclass Car implements Driveable, Soundable{\n    double power;\n    double fuelLevel;\n    double fuelCapacity;\n    public Car(double power, double fuelCapacity){\n      this.power \u003d power;\n      this.fuelCapacity \u003d fuelCapacity;\n    }\n\n    @Override\n    public void start(){\n      System.out.println(\"The car starts moving\");\n    }\n\n    @Override\n    public void stop(){\n      System.out.println(\"The car stops\");\n    }\n\n    @Override\n    public String getSound(){\n        return \"BEEB\";\n    }\n  }\n\nclass Horse implements Driveable, Soundable{\n    String name;\n\n    public Horse(String horse){\n      this.name \u003d name;\n    }\n\n    @Override\n    public void start(){\n      System.out.println(\"The horse starts moving\");\n    }\n\n    @Override\n    public void stop(){\n      System.out.println(\"The horse stops\");\n    }\n\n    @Override\n    public String getSound(){\n        return \"IHAA\";\n    }\n  }\n\n  ..\n\n  Soundable porsche \u003d new Car(245, 45);\n  Soundable horse \u003d new Horse(\"kasztanka\");\n  System.out.println(porsche.getSound());\n  System.out.println(horse.getSound());\n  ((Driveable)porsche).start();\n  ((Driveable)horse).start();\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Klasy moga implementować wiele interfejsów, co daje możliwość obiektom\n  reagować na wiele różnych zachowań.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Zadanie 1",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "interface Radiusable {\n\n  double getRadius();\n\n  double getAngle();\n\n  default double getPerimeter(){\n    return normalizeAngle(getAngle())*2 * Math.PI * getRadius() / (2 * Math.PI);\n  }\n\n  static double normalizeAngle(double a){\n    a \u003d Math.abs(a);\n    return a \u003e Math.PI*2 ? a - Math.round(a/(Math.PI*2)-1)*2*Math.PI : a;\n  }\n}\n\nclass Circle implements Radiusable{\n  private double radius;\n\n  public Circle(double radius){\n    this.radius \u003d radius;\n  }\n\n  @Override\n  public double getRadius() {\n    return radius;\n  }\n\n  @Override\n  public double getAngle() {\n    return Math.PI * 2;\n  }\n}\n\nclass Arc extends Circle{\n  private double angle;\n\n  public Arc(double radius, double angle){\n    super(radius);\n    this.angle \u003d angle;\n  }\n\n  public Arc(double radius){\n    super(radius);\n    this.angle \u003d 2 * Math.PI;\n  }\n\n  @Override\n  public double getAngle(){\n    return angle;\n  }\n}\n\nclass Ellipse extends Circle{\n  private double focusDistance;\n\n  public Ellipse(double radius, double focusDistance){\n    super(radius);\n    this.focusDistance \u003d focusDistance;\n  }\n\n  public Ellipse(double radius){\n    super(radius);\n    this.focusDistance \u003d radius;\n  }\n\n  @Override\n  public double getPerimeter() {\n    double a \u003d getVertex();\n    double b \u003d getCoVertex();\n    if (getRadius() \u003d\u003d focusDistance){\n      return super.getPerimeter();\n    }\n    return Math.PI * ( 3.0/2.0 * (a+b) - Math.sqrt(a*b));\n  }\n\n  public double getFocusDistance() {\n    return focusDistance;\n  }\n\n  public double getCoVertex(){\n    return Math.sqrt(getRadius()*getRadius()+focusDistance*focusDistance);\n  }\n\n  public double getVertex(){\n    return getRadius();\n  }\n}\n\nclass BestWishes{\n\n}\n\nclass Task {\n  static public void main(String[] args){\n    Circle a \u003d new Circle(10);\n    Circle b \u003d new Arc(10, Math.PI/4);\n    Radiusable c \u003d new Circle(10);\n    Radiusable d \u003d new Arc(10, Math.PI /4);\n    Radiusable e \u003d new Ellipse(10);\n    Circle f \u003d new Ellipse(10, 0);\n\n    System.out.println(a.getPerimeter());\n    System.out.println(b.getPerimeter());\n    System.out.println(c.getPerimeter());\n    System.out.println(d.getPerimeter());\n    System.out.println(e.getPerimeter());\n    System.out.println(f.getPerimeter());\n    System.out.println(((Ellipse) f).getCoVertex());\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\nWrite your task text here.\n\u003cbr\u003e\n\u003cbr\u003e\n\u003cdiv class\u003d\"hint\"\u003e\n  You can add hints anywhere in task text. Copy all hint div block and change its content.\n\u003c/div\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 2",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cH1\u003e\n  Dziedziczenie interfejsów\n\u003c/H1\u003e\n\u003cp\u003e\n\n  Cechą odróżniającą interfejsy od klas abstrakcyjnych jest możliwość tworzenia jednych drogą\n  dziedziczenia z kilku innych. W poprzedniej części utworzyliśmy dwa interfejsy, które\n  były implementowane przez klasy Car i Horse. Jeśli wiele klas musi implementować oba, to można\n  utworzyć jeden interfejs korzystając z wielodziedziczenia:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n    interface DriveAndSound extends Driveable, Soundable{\n    }\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  W ten sposób utworzyliśmy jeden interfejs, więc łatwiej będzie się odwoływać\n  do metod obu interfejsów dla obiektów z referencją:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n    class Car implements DriveAndSound{\n      ...\n    }\n\n    class Horse implements DriveAndSound{\n      ...\n    }\n\n    ...\n\n    DriveAndSound porsche \u003d new Porsche(250, 50);\n    DriveAndSound horse \u003d new Horse(\"kasztanka\");\n    System.out.println(porsche.getSound());\n    System.out.println(horse.getSound());\n    porsche.start();\n    horse.start();\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 3",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.ArrayList;\nimport java.util.List;\n\ninterface Grid{\n\n  String getAt(int row, int column);\n  int getColumns();\n  int getRows();\n\n  static String toString(String[] arr){\n    String result \u003d \"|\";\n    for (String s: arr){\n      result +\u003d s +\"|\";\n    }\n    return result;\n  }\n\n  default String[] getRow(int row){\n    String[] rowValues \u003d new String[getColumns()];\n    for(int column \u003d 0; column \u003c rowValues.length; column++){\n      rowValues[column] \u003d getAt(row, column);\n    }\n    return rowValues;\n  }\n\n  default String[] getColumn(int column){\n    String[] values \u003d new String[getRows()];\n    for(int row \u003d 0; row \u003c values.length; row++){\n      values[row] \u003d getAt(row, column);\n    }\n    return values;\n  }\n}\n\nclass Diagram implements Grid {\n  private String[][] grid;\n\n  public Diagram(int rows, int columns){\n    grid \u003d new String[rows][columns];\n  }\n\n  public void fill(String pattern){\n    for(int row \u003d 0; row \u003c getRows(); row++){\n      for (int column \u003d 0; column \u003c getColumns(); column++){\n        grid[row][column] \u003d pattern+\" \"+row+\" \"+column;\n      }\n    }\n  }\n\n  @Override\n  public String getAt(int row , int column) {\n    return grid[row][column];\n  }\n\n  @Override\n  public int getColumns() {\n    return grid[0].length;\n  }\n\n  @Override\n  public int getRows() {\n    return grid.length;\n  }\n}\nclass Task {\n  public static void main(String[] args) {\n    Grid diagram \u003d new Diagram(5, 10);\n    System.out.println(diagram.getColumns());\n    ((Diagram)diagram).fill(\"\");\n    String[] row5 \u003d diagram.getRow(4);\n    System.out.println(Grid.toString(row5));\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cH1\u003e\n  Interfejsy dla zaawansowanych\n\u003c/H1\u003e\n\u003cp\u003e\n  Począwszy od wersji 8 interfejsy mogą posiadać, oprócz metod abstrakcyjnych, zdefiniowane\n  metody statyczne i domyślne.\n\u003c/p\u003e\n\u003cp\u003e\n  Przykładowy interfejs służy do implementacji siatki dwuwymiarowej łańcuchów. Posługując się\n  numerem kolumny i wiersza można odczytać znajdujący się tam łańcuch. Interfejs\n  dostarcza także metod zwracających liczbę kolumn i wierszy.\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\ninterface Grid{\n\n  String getAt(int row, int column);\n  int getColumns();\n  int getRows();\n\n  static String toString(String[] arr){\n    String result \u003d \"|\";\n    for (String s: arr){\n      result +\u003d s +\"|\";\n    }\n    return result;\n  }\n\n  default String[] getRow(int row){\n    String[] rowValues \u003d new String[getColumns()];\n    for(int column \u003d 0; column \u003c rowValues.length; column++){\n      rowValues[column] \u003d getAt(row, column);\n    }\n    return rowValues;\n  }\n\n  default String[] getColumn(int column){\n    String[] values \u003d new String[getRows()];\n    for(int row \u003d 0; row \u003c values.length; row++){\n      values[row] \u003d getAt(row, column);\n    }\n    return values;\n  }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\n  Oprócz trzech metod abstakcyjnych interfejs zawiera dwie metody domyślne, sygnalizowane słowem \u003csamp\u003edefault\n\u003c/samp\u003e, które zwracają tablicę łańcuchów dla podanego wiersza lub kolumny. W obu metodach domyślnych posługujemy się\n  zadeklarowanymi metodami abstrakcyjnymi \u003csamp\u003egetAt()\u003c/samp\u003e, \u003csamp\u003egetColumns()\u003c/samp\u003e\n  i \u003csamp\u003egetRows()\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n  Obie metody domyślne są tak zdefiniowane, że ich kod zależy tylko od metod interfejsu \u003csamp\u003eGrid\u003c/samp\u003e.\n  Żeby z nich skorzystać, trzeba interfejs zaimplementować, a klasa je implementująca\n  musi zdefiniować wszystkie metody abstrakcyjne, więc, gdy wywołamy np. metodę\n  \u003csamp\u003egetRow(int row)\u003c/samp\u003e, to wszystkie w niej wykorzystane metody będą już zdefiniowane.\n\u003c/p\u003e\n\u003cp\u003e\n  Tak zdefiniowany interfejs jest niezależny do metody implementacji samej siatki.\n  Możne to być dwuwymiarowa tablica, kolekcja w postaci listy list lub jeszcze inne rozwiązanie.\n\u003c/p\u003e\n\u003cp\u003e\n  Wykorzystamy interfejs do stworzenia diagramu, który będzie przechowywał łańcuchy w\n  tablicy dwuwymiarowej:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass ArrayDiagram implements Grid {\n  private String[][] grid;\n\n  public Diagram(int rows, int columns){\n    grid \u003d new String[rows][columns];\n  }\n\n  public void fill(String pattern){\n    for(int row \u003d 0; row \u003c getRows(); row++){\n      for (int column \u003d 0; column \u003c getColumns(); column++){\n        grid[row][column] \u003d pattern+\" \"+row+\" \"+column;\n      }\n    }\n  }\n\n  @Override\n  public String getAt(int row , int column) {\n    return grid[row][column];\n  }\n\n  @Override\n  public int getColumns() {\n    return grid[0].length;\n  }\n\n  @Override\n  public int getRows() {\n    return grid.length;\n  }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nPrzedstawiona klasa musi implementować wszystkie abstrakcyjne metody, natomiast metody\n  domyślne są dziedziczone. Jeśli działanie metod domyślnych byłoby niewystarczające,\n  to można je ponownie zaimplementować w klasie \u003csamp\u003eDiagram\u003c/samp\u003e.\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nGrid diagram \u003d new ArrayDiagram(5, 10);\n((ArrayDiagram)diagram).fill(\"\");\n\nSystem.out.println(diagram.getColumns());\nString[] row5 \u003d diagram.getRow(4);\nSystem.out.println(Grid.toString(row5));\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  W przykładzie wykorzystaliśmy także metodę statyczną interfejsu, której kod musi być\n  niezależny od składowych  niestatycznych interfejsu. W przypadku funkcji\n  \u003csamp\u003etoString(String[] arr)\u003c/samp\u003e, jej zadanie, jest zwrócenie w postaci łańcucha\n  argumentu czyli tablicy łańcuchów.\n\u003c/p\u003e\n\u003cp\u003e\n  Istotną cechą typów interfejsowych jest łatwa możliwość wymiany klas je implemntujących.\n  Trzy ostatnie wiersze  są niezalezne od klas implementujących interfejs, więc jeśli\n  zmienna \u003csamp\u003ediagram\u003c/samp\u003e byłaby\n  klasy \u003csamp\u003eListDiagram\u003c/samp\u003e, która implementowałaby \u003csamp\u003eGrid\u003c/samp\u003e, to te trzy ostatnie\n  wiersze działały by poprawnie.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Podsumowanie",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\n  Właściwości interfejsów w Java:\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n   składowymi interfejsów mogą być pola, które są statycznymi stałymi, i metody abstrakcyjne,\n\u003c/li\u003e\n\u003cli\u003e\n   domyślnie składowe są publiczne,\n\u003c/li\u003e\n\u003cli\u003e\n   klasy mogą implementować wiele interfejsów,\n\u003c/li\u003e\n\u003cli\u003e\n  interfejsy mogą dziedziczyć z wielu innych inerfejsów,\n\u003c/li\u003e\n\u003cli\u003e\n   obiekty klas implementujących interfejs mogą być umieszczane w zmiennych typu tego interfejsu,\n\u003c/li\u003e\n\u003cli\u003e\n  metody interfejsu są wywoływane polimorficznie\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Klasy wewnętrzne i anonimowe",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Car {\n  private Engine engine \u003d null;\n  private String registerNumber;\n\n  public Car(double power, int pistonNumber, String registerNumber){\n    this.engine \u003d new Engine(power, pistonNumber);\n    this.registerNumber \u003d registerNumber;\n  }\n\n  @Override\n  public String toString() {\n    return engine.power+\" \"+engine.pistonNumber+\" \"+registerNumber;\n  }\n\n  public class Engine{\n    private double power;\n    private int pistonNumber;\n\n    public Engine(double  power, int pistonNumber){\n      this.power \u003d power;\n      this.pistonNumber \u003d pistonNumber;\n    }\n\n    double getPower(){\n      return power;\n    }\n\n    int getPistonNumber(){\n      return pistonNumber;\n    }\n\n    @Override\n    public String toString() {\n      return \"należy do: \"+registerNumber+\", moc: \"+this.power+\", liczba cylindrów: \"+this.pistonNumber;\n    }\n  }\n}\n\nclass Task {\n  public static void main(String[] args){\n    Car porsche \u003d new Car(250, 8, \"TK 6789E\");\n    System.out.println(porsche);\n    Car.Engine engine \u003d porsche. new Engine(405, 12);\n    System.out.println(engine);\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\nKlasa wewnętrza to typ definiowany wewnątrz definicji innej klasy. Ponieważ taka klasa może być deklarowana\n    także ze słowem kluczowym \u003csamp\u003estatic\u003c/samp\u003e więc rozróżniane są następujące rodzaje klas wewnętrznych:\n\u003c/p\u003e\n\u003cul\u003e\n    \u003cli\u003e\n        Klasy zagnieżdżone (ang. \u003ci\u003enested class\u003c/i\u003e), które są klasami wewnętrznymi statycznymi\n    \u003c/li\u003e\n    \u003cli\u003e\n        Klasy wewnętrzne (ang. \u003ci\u003einner class\u003c/i\u003e), które są klasami wewnętrznymi niestatycznymi\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n    W tej części zajmiemy się klasami wewnętrznymi niestatycznymi. Klasy takie można deklarować z wszystkimi\n    modyfikatorami zasięgu. Poniższy przykład ilustruje zastosowanie klasy wewnętrznej publicznej:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass Car {\n  private Engine engine \u003d null;\n  private String registerNumber;\n\n  public Car(double power, int pistonNumber, String registerNumber){\n    this.engine \u003d new Engine(power, pistonNumber);\n    this.registerNumber \u003d registerNumber;\n  }\n\n  @Override\n  public String toString() {\n    return engine.power+\" \"+engine.pistonNumber+\" \"+registerNumber;\n  }\n\n  public class Engine{\n    private double power;\n    private int pistonNumber;\n\n    public Engine(double  power, int pistonNumber){\n      this.power \u003d power;\n      this.pistonNumber \u003d pistonNumber;\n    }\n\n    double getPower(){\n      return power;\n    }\n\n    int getPistonNumber(){\n      return pistonNumber;\n    }\n\n    @Override\n    public String toString() {\n      return \"należy do: \"+registerNumber+\", moc: \"+this.power+\", liczba cylindrów: \"+this.pistonNumber;\n    }\n  }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Przykład ilustruje kilka istotnych właściwości klas wewnętrznych. Klasa zewnętrzna \u003csamp\u003eCar\u003c/samp\u003e ma dostęp\n    do wszystkich składowych klasy wewnętrznej \u003csamp\u003eEngine\u003c/samp\u003e, także do prywatnych, a klasa\n    wewnętrzna ma również dostęp do wszystkich składowych klasy zewnętrznej. Widać to w metodach \u003csamp\u003etoString()\u003c/samp\u003e\n    obu klas.\n\u003c/p\u003e\n\u003cp\u003e\n   Klasy wewnętrzne służą do tworzenia obiektów wewnątrz klasy zewnętrznej, możliwe jest\n    jednak tworzenie obiektów klas wewnętrznych poza, pod warunkiem, że są publiczne.\n    W przykładzie pokazano jak tworzyć obiekty klas wewnętrznych.\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\n    Car porsche \u003d new Car(250, 8, \"TK 6789E\");\n    System.out.println(porsche);\n    Car.Engine engine \u003d porsche.new Engine(405, 12);\n    System.out.println(engine);\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Obiekt klasy wewnętrznej może powstać tylko wtedy, gdy istnieje obiekt klasy zewnętrznej. W przykładzie\n    wykorzystaliśmy obiekt \u003csamp\u003eporsche\u003c/samp\u003e, dla którego wywołaliśmy operator \u003csamp\u003enew\u003c/samp\u003e.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 2",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Diagram {\n  private Field[] fields;\n\n  public Diagram(String theme) {\n    fields \u003d new Field[theme.length()];\n    int i \u003d 0;\n    for(char c: theme.toCharArray()){\n      fields[i++] \u003d new Field(c, i);\n    }\n  }\n\n  public Field fieldAt(int i){\n    return i \u003e -1 \u0026\u0026 i \u003c fields.length ? fields[i]: null;\n  }\n\n  public char letterAt(int i){\n    return fields[i].letter;\n  }\n\n  public static class Field{\n    private final char letter;\n    private final int number;\n\n    public Field(char letter, int number){\n      this.letter \u003d letter;\n      this.number \u003d number;\n    }\n\n    @Override\n    public String toString() {\n      return letter+\" \"+number;\n    }\n  }\n}\n\nclass Task {\n  public static void main(String[] args) {\n    Diagram diagram \u003d new Diagram(\"JAVA\");\n    System.out.println(diagram.fieldAt(2));\n    System.out.println(diagram.letterAt(2));\n    Diagram.Field f \u003d new Diagram.Field(\u0027D\u0027, 8);\n    System.out.println(f);\n}\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\n  Klasy zagnieżdźone deklarowane są ze słowem \u003csamp\u003estatic\u003c/samp\u003e. Klasa statyczna nie ma dostępu do pól\n  klasy zewnętrznej, bo można do tej klasy odwoływać się bezpośrednio:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass Diagram {\n  private Field[] fields;\n\n  public Diagram(String theme) {\n    fields \u003d new Field[theme.length()];\n    int i \u003d 0;\n    for(char c: theme.toCharArray()){\n      fields[i++] \u003d new Field(c, i);\n    }\n  }\n\n  public Field fieldAt(int i){\n    return i \u003e -1 \u0026\u0026 i \u003c fields.length ? fields[i]: null;\n  }\n\n  public char letterAt(int i){\n    return fields[i].letter;\n  }\n\n  public static class Field{\n    private final char letter;\n    private final int number;\n\n    public Field(char letter, int number){\n      this.letter \u003d letter;\n      this.number \u003d number;\n    }\n\n    @Override\n    public String toString() {\n      return letter+\" \"+number;\n    }\n  }\n}\n\n...\n\nDiagram diagram \u003d new Diagram(\"JAVA\");\nSystem.out.println(diagram.fieldAt(2));\nSystem.out.println(diagram.letterAt(2));\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  W konstruktorze klasy \u003csamp\u003eDiagram\u003c/samp\u003e utworzyliśmy obiekty klasy wewnętrznej \u003csamp\u003eField\u003c/samp\u003e.\n  Klasa zagnieżdżona nie może odwoływać się do pól klasy zewnętrznej, ale klasa zewnętrzna\n    ma prawo dostępu do wszystkich składowych.\n\u003c/p\u003e\n\u003cp\u003e\n    Tworzenie obiektów publicznej klasy zagnieżdżonej wymaga podania\n    nazwy klasy poprzedzonej klasą zewnętrzną:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nDiagram.Field f \u003d new Diagram.Field(\u0027D\u0027, 8);\nSystem.out.println(f);\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 3",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "interface Message{\n  String getMessage();\n}\n\nclass EnglishMessage implements Message {\n\n  @Override\n  public String getMessage() {\n    return \"Programming in JAVA\";\n  }\n}\n\nclass Task {\n\n  public static void main(String[] args) {\n    Message polishMessage \u003d new Message() {\n      @Override\n      public String getMessage() {\n        return \"Programowanie w JAVA\";\n      }\n    };\n\n    Message englishMessage \u003d new Message() {\n      @Override\n      public String getMessage() {\n        return \"Programming in JAVA\";\n      }\n    };\n    System.out.println(polishMessage.getMessage());\n    System.out.println(englishMessage.getMessage());\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eKlasa anonimowa\u003c/h1\u003e\n\u003cp\u003e\n  Klasa anonimowa to kolejny szczególny rodzaj klasy. Służy do \"natychmiastowego\" tworzenia obiektów, bez osobnej\n  definicji klasy. Określenie \"anonimowa\" dość jasnow skazuje, że klasa taka nie posiada nazwy. Jest ona\n  zbędna, bo celem takiej klasy jest utworzenie tylko jednej jej instancji.\n\u003c/p\u003e\n\u003cp\u003e\n  Głównym celem takich klas, jest implementowanie metod interfejsowych. Przy definiowaniu klas anomimowych\n  podajemy jaki interfejs ma implementować lub jaką klasę ma rozszerzać.\n\u003c/p\u003e\n\u003cp\u003e\n  Przykład interfejs, który zwraca komunikat:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\ninterface Message{\n  String getMessage();\n}\n \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Możemy teraz zdefiniować zmienne zwracające komunikat w różnych językach.\n  Tradycyjnie zrobiliśmy to definiując klasy dla każdego języka i tworząc potem obiekty:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass EnglishMessage implements Message {\n\n  @Override\n  public String getMessage() {\n    return \"Programming in JAVA\";\n  }\n}\n\n...\n\nMessage englishMessage \u003d new EnglishMessage();\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Stosując klasę anonimową możemy zrobić to krócej:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  Message englishMessage \u003d new Message() {\n      @Override\n      public String getMessage() {\n        return \"Programming in JAVA\";\n      }\n  };\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 4",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "abstract class Operation{\n  abstract public double apply(double a);\n}\n\nclass Task {\n  static void apply(double[] arr, Operation a){\n    for (int i \u003d 0; i \u003c arr.length; i++) {\n      arr[i] \u003d a.apply(arr[i]);\n    }\n  }\n\n  static void printArray(double[] arr){\n    for(double d: arr){\n      System.out.println(d);\n    }\n  }\n\n  public static void main(String[] args) {\n\n    Operation vat \u003d new Operation() {\n      @Override\n      public double apply(double a) {\n        return a*1.23;\n      }\n    };\n\n    double[] values \u003d {1.34, 34.6 , 455, 78.56};\n    apply(values, vat);\n    printArray(values);\n\n    apply(values, new Operation() {\n      @Override\n      public double apply(double a) {\n        return Math.sqrt(a);\n      }\n    });\n\n    printArray(values);\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eKlasa anonimowa a argument funkcyjny\u003c/h1\u003e\n\u003cp\u003e\nKlasy anonimowe służa najczęściej do realizacji przekazywania argumentu funkcyjnego.\nPonieważ w JAVA nie ma możliwości zdefiniowania funkcji bez klasy, więc argumentem funkcji\nnie może być funkcja. Możemy przekazywać tylko obiekty klas, które posiadają metody funkcyjne.\n\u003c/p\u003e\n\u003cp\u003e\n  Tym razem zadeklarujemy klasę abstrakcyjną, która posiada jedną metodę abstrakcyjną:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nabstract class Operation{\n  abstract public double apply(double a);\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Klasa posiada interfejs w postaci metody \u003csamp\u003eapply\u003c/samp\u003e z jednym argumentem. Klasy\n    potomne będą implementować tę metodę dostarczając konkretną operację na argumencie i zwracając wynik.\n\u003c/p\u003e\n\u003cp\u003e\n  Wykorzystamy utworzoną klasę do zdefiniowania metody przetwarzającej tablicę wartości:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nstatic void recalc(double[] arr, Operation a){\n    for (int i \u003d 0; i \u003c arr.length; i++) {\n        arr[i] \u003d a.apply(arr[i]);\n    }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Aby skorzystać z tej metody musimy zdefiniować operację wykonywaną na każdej wartości. Wykorzystamy\n    metodę tworzenia klasy anonimowej:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nOperation vat \u003d new Operation() {\n    @Override\n    public double calc(double a) {\n        return a*1.23;\n    }\n};\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Wywołanie metody wykorzystującej interfejs  \u003csamp\u003eAction\u003c/samp\u003e i metodę \u003csamp\u003ecalc()\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\ndouble[] values \u003d {1.34, 34.6 , 455, 78.56};\nrecalc(values, vat);\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nMożna też zdefiniować akcję podczas wywołania metody \u003csamp\u003erecalc()\u003c/samp\u003e, tak jak zdefiniowane\n    poniżej pierwiastkowanie:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\napply(values, new Operation() {\n      @Override\n      public double calc(double a) {\n        return Math.sqrt(a);\n      }\n    });\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Typ wyliczeniowy",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.Scanner;\nenum Kolor{\n  PIK, KIER, KARO, TREFL;\n}\n\nclass Task {\n  public static void main(String[] args){\n    Kolor card;\n    Scanner scan \u003d new Scanner(System.in);\n    System.out.println(\"Wpisz jeden z kolorów kart: PIK, KIER, KARO, TREFL: \");\n    card \u003d Kolor.valueOf(scan.nextLine());\n    System.out.println(card \u003d\u003d Kolor.KIER);\n    switch(card){\n      case PIK:\n        System.out.println(\"Pik ma 40 punktów\");\n        break;\n      case KIER:\n        System.out.println(\"Kier 30 punktów\");\n        break;\n      case KARO:\n        System.out.println(\"Karo 20 punktów\");\n        break;\n      case TREFL:\n        System.out.println(\"Trefl 10 punktów\");\n        break;\n    }\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\nTyp wyliczeniowy służy do przechowywania skończonej liczby wartości. Typowym przykładem zastosowania\ntypu wyliczeniowego są dni tygodnia, miesiące, figury szachowe itd.\n\u003c/p\u003e\n\u003cp\u003eDo definiowania wyliczeń służy słowo kluczowe \u003csamp\u003eenum\u003c/samp\u003e. Typ wyliczeniowy przypomina definiowanie klasy, która\n    zwiera tylko stałe. Zwyczajowo stałe pisane są wielkimi literami.\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nenum Suits{\n     SPIDES, HEARTS, DIAMONDS, CLUBS\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e Zmienna typu wyliczeniowego może przyjąć jedną z wymienionych w typie wartości:\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nSuits deck1 \u003d Suits.SPADES;\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Przykład wykorzystania zmiennej wyliczeniowej:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\npublic static void main(String[] args){\n    Suits card;\n    Scanner scan \u003d new Scanner(System.in);\n    System.out.println(\"Wpisz jeden z kolorów kart: SPADES, HEARTS, DIAMONDS, CLUBS: \");\n    card \u003d Suits.valueOf(scan.nextLine());\n    switch(card){\n      case SPADES:\n        System.out.println(\"Pik ma 40 punktów\");\n        break;\n      case HEARTS:\n        System.out.println(\"Kier 30 punktów\");\n        break;\n      case DIAMONDS:\n        System.out.println(\"Karo 20 punktów\");\n        break;\n      case CLUBS:\n        System.out.println(\"Trefl 10 punktów\");\n        break;\n    }\n}\n        \u003c/code\u003e\n    \u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 2",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "enum Team {\n  ADAM, ROMAN, KAROLINA;\n}\nclass Task {\n  public static void main(String[] args) {\n    Team member \u003d Team.KAROLINA;\n    System.out.println(member.name());\n    System.out.println(member.ordinal());\n    System.out.println(member.compareTo(Team.ROMAN));\n    System.out.println(member.getDeclaringClass());\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\n  Zmienne typu wyliczeniowego są obiektami, które posiadają kilka użytecznych metod:\n\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\n    \u003csamp\u003ename()\u003c/samp\u003e - zwraca nazwę stałej,\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003csamp\u003eordinal()\u003c/samp\u003e - zwraca numer pozycji na liście stałych,\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003csamp\u003ecompareTo(wartość_enum)\u003c/samp\u003e- porównuje wartość zmiennej wyliczeniowej z inną tego samego typu\n    i zwraca różnicę pozycji.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePopatrzmy na przykład wykorzystania metod:\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n    enum Team {\n      ADAM, TOMEK, KASIA, KAROLINA, BASIA\n    }\n\n    ...\n\n    Team member \u003d Team.KASIA;\n    System.out.println(member.name());\n    System.out.println(member.ordinal());\n    System.out.println(member.compareTo(Team.TOMEK));\n    System.out.println(member.getDeclaringClass());\n\n    ---\n    KASIA\n    2\n    1\n    class Team\n    \u003c/pre\u003e\n  \u003c/code\u003e\n  \u003cp\u003e\n    Znaczenie kolejnych wartości:\n  \u003c/p\u003e\n    \u003cul\u003e\n      \u003cli\u003e\n        \u003csamp\u003eKASIA\u003c/samp\u003e - nazwa stałej wyliczeniowej,\n      \u003c/li\u003e\n      \u003cli\u003e\n        \u003csamp\u003e2\u003c/samp\u003e - stała KASIA znajduje się na pozycji nr 2 (pierwsza ma pozycję 0),\n      \u003c/li\u003e\n      \u003cli\u003e\n        \u003csamp\u003e1\u003c/samp\u003e - stała KASIA znajduje się 1 pozycję za stałą TOMEK,\n      \u003c/li\u003e\n      \u003cli\u003e\n        \u003csamp\u003eclass Team\u003c/samp\u003e - nazwa typu zmiennej,\n      \u003c/li\u003e\n    \u003c/ul\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "CZęść 3",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.Scanner;\n\n/**\n * Typ wyliczeniowy wykorzystujący możliwości klasy\n */\nenum Suits{\n  SPADES(40),\n  HEARTS(30),\n  DIMAONDS(20),\n  CLUBS(10);\n\n  private int points;\n\n  private Suits(int points){\n    this.points \u003d points;\n  }\n\n  public int getPoints(){\n    return points;\n  }\n\n  public static boolean contains(String name){\n    for(Suits c: Suits.values()){\n      if (name.equals(c.name()))\n        return true;\n    }\n    return false;\n  }\n}\n\nclass Task {\n  public static void main(String[] args){\n    Suits card1 \u003d Suits.DIMAONDS;\n    Suits card2 \u003d Suits.HEARTS;\n    Suits card3 \u003d Suits.DIMAONDS;\n    System.out.println(card1 \u003d\u003d card3);\n    for(Suits c: Suits.values()){\n      System.out.println(c);\n    }\n\n    Scanner scan \u003d new Scanner(System.in);\n    System.out.print(\"Wpisz jedną z nazw poniższych kolorów: \");\n    for(Suits c: Suits.values()){\n      System.out.print(c+\" \");\n    }\n    String cName \u003d scan.next();\n    Suits card;\n    if (Suits.contains(cName)) {\n      card \u003d Suits.valueOf(cName);\n      System.out.println(card.getPoints());\n    } else {\n      System.out.println(\"Wpisałeś niepoprawny kolor\");\n    }\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eMożliwości dodatkowe klasy enum\u003c/h1\u003e\n\u003cp\u003e\nDeklarowany typ wyliczeniowy jest w istocie klasą, dla której możemy zdefiniować konstruktory, metody i pola. To co odróżnia\ntyp \u003csamp\u003eenum\u003c/samp\u003e od klas właściwych jest fakt, że nie tworzymy obiektów tego typu, bo stałe\nwyliczeniowe są obiektami jego typu. Można założyć, że typ \u003csamp\u003eenum\u003c/samp\u003e jest klasą, która zawiera statyczne\n    pola typu wyliczeniowego.\n\u003c/p\u003e\n\u003cp\u003e\n  Rozbudujmy typ \u003csamp\u003eKolor\u003c/samp\u003e tak, aby przechowywać liczbę punktów każdego koloru:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nenum Kolor{\n    PIK(40),\n    KIER(30),\n    KARO(20),\n    TREFL(10);\n\n    private int points;\n\n    Kolor(int points){\n        this.points \u003d points;\n    }\n\n    public int getPoints(){\n        return points;\n    }\n}\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Konstruktory typu wyliczeniowego musza być prywatne (aby nie można było tworzyć obiektów tego typu). Jawne\n  podawanie modyfikatora zasięgu \u003csamp\u003eprivate\u003c/samp\u003e nie jest potrzebne, jest przyjmowany domyślnie.\n    Metody i pola mogą posiadać dowolny typ zasięgu, choć \u003csamp\u003eprotected\u003c/samp\u003e jest nieużyteczny, gdyż\n    nie można dziedziczyć typu \u003csamp\u003eenum\u003c/samp\u003e.\n  Dzięki takiej rozbudowie przykład z części 1 znacznie się uprości:\n\u003c/sampprotected\u003e\n\u003cpre\u003e\n\u003ccode\u003e\npublic static void main(String[] args){\n    Kolor card;\n    Scanner scan \u003d new Scanner(System.in);\n    System.out.println(\"Wpisz jeden z kolorów kart: PIK, KIER, KARO, TREFL: \");\n    card \u003d Kolor.valueOf(scan.nextLine());\n    System.out.println(\"Pik ma \" + card.getPoints() + \" punktów\");\n}\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Typ \u003csamp\u003eenum\u003c/samp\u003e wyposażony jest w kilka dość istotnych metod statycznych:\n\u003c/p\u003e\n\u003col\u003e\n    \u003cli\u003e\n       \u003csamp\u003evalueOf(nazwa_stałej)\u003c/samp\u003e - zwraca stałą wyliczeniową o podanej nazwie,\n    \u003c/li\u003e\n    \u003cli\u003e\n       \u003csamp\u003evalues()\u003c/samp\u003e - zwraca tablicę wszystkich stałych\n    \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n    Poprzedni przykład można teraz rozbudować o sprawdzanie, czy wpisana wartość stałej jest poprawna:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nenum Color{\n  PIK(40),\n  KIER(30),\n  KARO(20),\n  TREFL(10);\n\n  private int points;\n\n  private Color(int points){\n    this.points \u003d points;\n  }\n\n  public int getPoints(){\n    return points;\n  }\n\n  public static boolean contains(String name){\n    for(Color c: Color.values()){\n      if (name.equals(c.name()))\n        return true;\n    }\n    return false;\n  }\n}\n\n...\n\nScanner scan \u003d new Scanner(System.in);\nSystem.out.print(\"Wpisz jedną z nazw poniższych kolorów: \");\nfor(Color c: Color.values()){\n  System.out.print(c+\" \");\n}\nString cName \u003d scan.next();\nColor card;\nif (Color.contains(cName)) {\n  card \u003d Color.valueOf(cName);\n  System.out.println(card.getPoints());\n} else {\n  System.out.println(\"Wpisałeś niepoprawny kolor\");\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Typ wyliczeniowy wyposażyliśmy w dodatkową metodę \u003csamp\u003econtaints(name)\u003c/samp\u003e, która sprawdza\n    czy typ zawiera stałą o podanej nazwie. Stosując tę metodę sprawdzamy, czy wpisany\n    z klawiatury łańcuch jest jedną ze stałych wyliczenia.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 4",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDateTime;\nimport java.util.*;\n\n/**\n * Klasa udająca typ enum\n */\nclass SuitsC {\n  public static SuitsC SPADES   \u003d new SuitsC(\"SPADES\", 40);\n  public static SuitsC HEARTS   \u003d new SuitsC(\"HEARTS\", 40);\n  public static SuitsC DIAMONDS \u003d new SuitsC(\"DIAMONDS\", 40);\n  public static SuitsC CLUBS    \u003d new SuitsC(\"CLUBS\", 40);\n\n  private int points;\n  private String name;\n\n  private SuitsC(String name, int points){\n    this.points \u003d points;\n    this.name \u003d name;\n  }\n\n  public String name(){\n    return name;\n  }\n\n  public int getPoints(){\n    return points;\n  }\n\n  public String toString(){\n    return name;\n  }\n}\n\n/**\n * Klasa enum\n */\nenum SuitsE {\n  SPADES(40),\n  HEARTS(30),\n  DIAMONDS(20),\n  CLUBS(10);\n\n  private int points;\n\n  SuitsE(int points){\n    this.points \u003d points;\n  }\n\n  public int getPoints(){\n    return points;\n  }\n}\n\n\n\nclass Task{\n  public static void main(String[] args){\n    SuitsE pe1 \u003d SuitsE.SPADES;\n    SuitsE pe2 \u003d SuitsE.SPADES;\n    SuitsC pc1 \u003d SuitsC.SPADES;\n    SuitsC pc2 \u003d SuitsC.SPADES;\n\n    System.out.println(pe1 \u003d\u003d pe2);\n    System.out.println(pc1 \u003d\u003d pc2);\n\n    System.out.println(pc1.name());\n    System.out.println(pe2.name());\n\n    System.out.println(pc1.getPoints());\n    System.out.println(pe2.getPoints());\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eSubstytu typu enum\u003c/h1\u003e\n\u003cp\u003e\n Aby łatwiej zrozumieć zaawansowane definiowanie typu \u003csamp\u003eenum\u003c/samp\u003e stworzymy tradycyjną klasę, której obiekty\n    będa zachowywać się jak taki typ. Wykorzystamy przykład kolorów kart do gry.\n\u003c/p\u003e\n\u003cp\u003e\n    Na początek wyposażymy nasz typ tylko w stałe:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nfinal class Suit{\n    public static Suit SPADES \u003d new Suit(\"SPADES\");\n    public static Suit DIAMONDS \u003d new Suit(\"DIAMONDS\");\n    public static Suit CLUBS \u003d new Suit(\"CLUBS\");\n    public static Suit HEARTS \u003d new Suit(\"HEARTS\");\n\n    private String name;\n\n    private Suit(String name){\n        this.name \u003d name;\n    }\n\n    public String name(){\n        return name;\n    }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Stworzona klasa zachowuje się podobnie jak typ \u003csamp\u003eenum\u003c/samp\u003e:\n\u003cp\u003e\n\u003col\u003e\n    \u003cli\u003e\n        ma prywatny konstruktor, nie można tworzyć obiektów tej klasy,\n    \u003c/li\u003e\n    \u003cli\u003e\n        posiada stałe, które są obiektami typu definiowanej klasy,\n    \u003c/li\u003e\n    \u003cli\u003e\n        posiada metodę \u003csamp\u003ename()\u003c/samp\u003e, która zwraca nazwę stałej,\n    \u003c/li\u003e\n    \u003cli\u003e\n        modyfikator \u003csamp\u003efinal\u003c/samp\u003e uniemożliwia dziedziczenie.\n    \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n    Ponieważ nasza klasa udaje tylko typ wyliczeniowy, więc jej używanie może narazić nas na kilka\n    kłopotów, jak pomyłkę w nazwie stałej i różnicę z zawartością pola \u003csamp\u003ename\u003c/samp\u003e np.\n    \u003ccode\u003epublic static Suit SPADS \u003d new Suit(\"SPADES\");\u003c/code\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Substytut działa bardzo podobnie jak prawdziwy typ wyliczeniowy:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\n    Suits player1 \u003d Suits.SPADES;\n    Suits player2 \u003d Suits.HEARTS;\n    Suits player3 \u003d Suits.SPADES;\n    System.out.println(player1 \u003d\u003d player2);\n    System.out.println(player1 \u003d\u003d player3);\n    System.out.println(player1.name());\n    \u003c/code\u003e\n\u003c/pre\u003e\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n    Dodajmy kolejne właściwości do klasy \u003csamp\u003eSuits\u003c/samp\u003e: liczbę punktów i metodę do jej odczytu:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\n final class Suit{\n    public static Suit SPADES \u003d new Suit(\"SPADES\", 40);\n    public static Suit HEARTS \u003d new Suit(\"HEARTS\", 30);\n    public static Suit DIAMONDS \u003d new Suit(\"DIAMONDS\", 20);\n    public static Suit CLUBS \u003d new Suit(\"CLUBS\", 10);\n\n    private String name;\n    private int points;\n\n    private Suit(String name, int points){\n        this.name \u003d name;\n        this.points \u003d points;\n    }\n\n    public String name(){\n        return name;\n    }\n\n    public int getPoints(){\n        return points;\n    }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n    \u003cp\u003e\n        Porównajmy tworzenie stałych w naszej klasie ze stałymi typu \u003csamp\u003eenum\u003c/samp\u003e:\n    \u003c/p\u003e\n\n        \u003ctable border\u003d\"\" bgcolor\u003d\"#123456\" cellpadding\u003d\"4\" align\u003d\"center\"\u003e\n            \u003ctr\u003e\n                \u003ctd\u003e\n            Substytut\n        \u003c/td\u003e\n            \u003ctd\u003e\n            Typ enum\n            \u003c/td\u003e\n            \u003c/tr\u003e\n            \u003ctr\u003e\n                \u003ctd\u003e\n                    \u003ccode\u003e\n                 public static Suit SPADES \u003d new Suit(\"SPADES\", 40);\n                    \u003c/code\u003e\n                \u003c/td\u003e\n                \u003ctd\u003e\n                    \u003ccode\u003e\n                  SPADES(40);\n                    \u003c/code\u003e\n                \u003c/td\u003e\n            \u003c/tr\u003e\n        \u003c/table\u003e\n        \u003cp\u003ePorównanie pokazuje, że dodanie nawiasów z liczbą pubktów za nazwą stałej w \u003csamp\u003eenum\u003c/samp\u003e\n        jest w istocie  wywołaniem konstruktora jednoargumentowego, który zwróci obiekt i przypisze go do tej  stałej.\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Podsumowanie",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cp\u003e\n  Własności typu \u003csamp\u003eenum\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cul\u003e\n    \u003cli\u003e\n        Typ \u003csamp\u003eenum\u003c/samp\u003e jest specyficzną klasą, która ma szereg ograniczeń,\n    \u003c/li\u003e\n    \u003cli\u003e\n        Stałe wyliczeniowe to obiekty klasy \u003csamp\u003eenum\u003c/samp\u003e, które są jednocześnie statycznymi polami klasy,\n    \u003c/li\u003e\n    \u003cli\u003e\n        Nie można dziedziczyć po typie \u003csamp\u003eenum\u003c/samp\u003e,\n    \u003c/li\u003e\n    \u003cli\u003e\n        Nie można rozszerzać typów wyliczeniowych,\n    \u003c/li\u003e\n    \u003cli\u003e\n        Typ \u003csamp\u003eenum\u003c/samp\u003e może implementować interfejsy,\n    \u003c/li\u003e\n    \u003cli\u003e\n        Konstruktor typu \u003csamp\u003eenum\u003c/samp\u003e jest prywatny, nie można tworzyć obiektów klasy \u003csamp\u003eenum\u003c/samp\u003e poza ciałem\n        klasy,\n    \u003c/li\u003e\n    \u003cli\u003e\n        Typ \u003csamp\u003eenum\u003c/samp\u003e może posiadać pola i metody z modyfikatorami zasięgu \u003csamp\u003eprivate\u003c/samp\u003e lub\n        \u003csamp\u003epublic\u003c/samp\u003e,\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Wyjątki",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/ExceptionDemo.java": {
                  "name": "src/ExceptionDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class ExceptionDemo {\n  public static void main(String[] args) {\n    int[] array \u003d {1, 2, 3};\n    try {\n      System.out.println(array[0]);\n      System.out.println(array[1]);\n      System.out.println(array[2]);\n      System.out.println(array[3]);\n    } catch(ArrayIndexOutOfBoundsException e){\n      System.out.println(\"Nieładnie, indeks poza zakresem\");\n    }\n    System.out.println(\"KONIEC\");\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eCzym jest wyjątek?\u003c/h1\u003e\n\u003cp\u003e\n  Wyjątek (ang. \u003ci\u003eexception\u003c/i\u003e) to zdarzenie występujące podczas wykonywania programu, które zaburza\n  normalną kolejność wykonywanych instrukcji. Z występowaniem takich zdarzeń już spotkaliśmy się, chociażby\n  podczas wykonania takiego programu:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass ExceptionDemo {\n  public static void main(String[] args) {\n    int[] array \u003d {1, 2, 3, 4};\n    System.out.println(array[4]);\n  }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Efektem jest zgłoszenie wyjątku programu:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003csamp\u003e\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4\n\tat Task.main(ExceptionDemo.java:4)\n  \u003c/samp\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\n  Reakcja na błąd powoduje stworzenie specjalnego obiektu, który jest przekazywany do systemu wykonawczego (ang. \u003ci\u003eruntime\n  system\u003c/i\u003e). Obiekt ten, zwany obiektem wyjątku, zawiera informacje o błędzie, w tym jego typ i stan programu po błędzie.\n  Sytuacja utworzenia wyjątku i przekazania go do systemu wykonawczego nazywana jest wyrzucaniem lub zgłaszaniem wyjątku (ang.\n  \u003ci\u003ethrowing an exception\u003c/i\u003e).\n\u003c/p\u003e\n\u003cp\u003e\n  Gdy wyjątek zostanie zgłoszony to następuje proces wyszukiwania \"odpowiedzialnego\" za jego obsłużenie. System\n  wykonawczy, przeszukuje uporządkowaną listę metod, które były wywoływane do momentu wystąpienia błędu. Listą\n  tą jest tzw. stos wywołań. Celem przeszukiwania jest znalezienie metody, która zawiera blok kodu obsługującego\n  zgłoszony wyjątek. Gdy zostanie znaleziony kod obsługi wyjątki (ang. \u003ci\u003eexception handler\u003c/i\u003e), którego typ pasuje\n  do obiektu wyjątku to system wykonawczy go\n  wykonuje, i zgodnie z tym kodem decyduje, czy program jest kontynuwany czy nie.\n\u003c/p\u003e\n\u003cp\u003e\n  Jeśli kod obługi nie zostanie znaleziony to system wykonawczy kończy działanie,\n  co jest równoznaczne z zakończeniem programu\n  wraz z wyświetleniem wszystkich informacji o wyjątku.\n\u003c/p\u003e\n\u003cp\u003e\n  Przedstawiony wyżej przykład ilustruje reakcję na brak obsługi wyjątku, dlatego nasz program zakończył działanie\n  wyświetlając informacje o błędzie.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 2",
              "stepic_id": 0,
              "task_files": {
                "src/FinallyDemo.java": {
                  "name": "src/FinallyDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.Scanner;\n\nclass FinallyDemo {\n  public static void main(String[] args) {\n    int[] array \u003d {1, 2, 3, 4, 5, 9, 8, 7};\n    int sum\u003d 0;\n    Scanner scan\u003d new Scanner(System.in);\n    System.out.println(\"Program obliczający sumę pierwszych n elementów tablicy\");\n    System.out.println(\"Wpisz indeks ostatniego sumowanego elementu:\");\n    int n \u003d scan.nextInt();\n    int element \u003d 0;\n    for (int i \u003d 0; i \u003c n; i++) {\n      try {\n        element \u003d array[i];\n      } catch (ArrayIndexOutOfBoundsException e) {\n        element \u003d 0;\n      }\n      finally {\n        sum +\u003d element;\n      }\n    }\n    System.out.println(\"Suma elementów: \"+sum);\n  }\n}"
                },
                "src/MultiCatchDemo.java": {
                  "name": "src/MultiCatchDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class MultiCatchDemo {\n  public static void main(String[] args) {\n    int[] array \u003d { 1, 2, 3, 4, 5};\n    Scanner scan \u003d new Scanner(System.in);\n    boolean isValid \u003d false;\n    int n \u003d 0;\n    int element \u003d 0;\n    System.out.println(\"Wpisz indeks od 0 do 4.\");\n    do {\n      try {\n        n \u003d scan.nextInt();\n        element \u003d array[n];\n        isValid \u003d true;\n      } catch (InputMismatchException e1) {\n        System.out.println(\"Wpisz indeks jako liczbę całkowitą!!! Spróbuj jeszcze raz.\");\n        String tmp \u003d scan.nextLine();\n      } catch (ArrayIndexOutOfBoundsException e2) {\n        System.out.println(\"Indeks musi być nieujemny i mniejszy od 5!!! Spróbuj jeszcze raz.\");\n      }\n    }while (!isValid);\n    System.out.println(\"Liczba w tablicy o indeksie \"+n+\" \u003d \"+element);\n  }\n}\n"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eObsługa wyjątku - konstrukcja try...catch\u003c/h1\u003e\n\u003cp\u003e\n  Mamy dwie możliwości reagowania na wyjątki:\n\u003c/p\u003e\n\u003cul\u003e\n    \u003cli\u003e\n        umieścić kod obsługi wyjątku ujmując fragment kodu, w którym może pojawić się wyjątek,\n        blokiem \u003csamp\u003etry ... catch ...\u003c/samp\u003e,\n    \u003c/li\u003e\n    \u003cli\u003e\n        przekazać zgłoszony wyjątek metodzie wywołującej poprzez dodanie klauzuli \u003csamp\u003ethrows\u003c/samp\u003e,\n        co powoduje, że przenosimy odpowiedzialność za obsługę wyjątku na zewnątrz.\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n    Dodajmy do przykładu blok try ... catch ..., tak aby wyświetlić komunikat, o nieprawidłowem indeksie.\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass TryCatchDemo {\n  public static void main(String[] args) {\n    int[] array \u003d {1, 2, 3, 4};\n    try {\n      System.out.println(array[4]);\n    } catch (ArrayIndexOutOfBoundsException e) {\n      System.out.println(\"Przekroczony zakres indeksu. Wyjątek \"+e);\n    }\n    System.out.println(\"KONIEC\");\n  }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Efektem wykonania programu:\n\u003c/p\u003e\n\u003cpre\u003e\n\u003csamp\u003e\nPrzekroczony zakres indeksu. Wyjątek java.lang.ArrayIndexOutOfBoundsException: 4\nKONIEC\n\u003c/samp\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Klauzula \u003csamp\u003etry\u003c/samp\u003e obejmuje kod, w którym może wystąpić błąd, argumentem \u003csamp\u003ecatch\u003c/samp\u003e jest\n    obiekt wyjątku, a w bloku poniżej \u003csamp\u003ecatch\u003c/samp\u003e znajduje się reakcja na błąd.\n    Dodanie obsługi wyjątku spowodowało, że program nie został zatrzymany. Po reakcji na wyjątek wykonana została\n    instrukcja za blokiem \u003csamp\u003etry ... catch\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n   Blok obsługi wyjątku może zawierać trzeci element - blok \u003csamp\u003efinally\u003c/samp\u003e, który wykonywany jest zawsze\n    bez względu na to czy błąd się pojawi, czy nie. Ilustracją będzie rozbudowa poprzedniego\n    przykładu, który będzie obliczał sumę pierwszych n-elementów tablicy. Zakładamy, że użytkownik\n    może podać niepoprawną wartość n. Jeśli indeks odczytywanego elementu jest niepoprawny, to przyjmujemy, że\n    elementu nie ma, więc jego wartość jest równa zero.\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nimport java.util.Scanner;\n\nclass TryCatchFinallyDemo {\n  public static void main(String[] args) {\n    int[] array \u003d {1, 2, 3, 4, 5, 9, 8, 7};\n    int sum\u003d 0;\n    Scanner scan\u003d new Scanner(System.in);\n    int n \u003d scan.nextInt();\n    int element \u003d 0;\n    for (int i \u003d 0; i \u003c n; i++) {\n      try {\n        element \u003d array[i];\n      } catch (ArrayIndexOutOfBoundsException e) {\n        element \u003d 0;\n      }\n      finally {\n        sum +\u003d element;\n      }\n    }\n    System.out.println(\"Suma elementów: \"+sum);\n  }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  W bloku \u003csamp\u003etry\u003c/samp\u003e  próbujemy odczytać element o indeksie \u003csamp\u003ei\u003c/samp\u003e. Jeśli przekroczymy zakres,\n    to zostanie wykonany blok \u003csamp\u003ecatch\u003c/samp\u003e, w którym nieistniejącej liczbie przypisujemy zero. Jeśli\n    indeks jest poprawny, to nie wystąpi błąd i zmienna \u003csamp\u003eelement\u003c/samp\u003e będzie liczbą z tablicy.\n    Blok \u003csamp\u003efinally\u003c/samp\u003e zawsze jest wykonywany, bez względu czy wystąpił błąd czy nie. W nim\n    dodajemy do zmiennej \u003csamp\u003esum\u003c/samp\u003e  wartość z \u003csamp\u003eelement\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n    W bloku \u003csamp\u003etry\u003c/samp\u003e, może wystapić więcej błędów, także różnych typów. W takiej sytuacji\n    można dodać kilka klauzul \u003csamp\u003ecatch(typ-wyjątku obiekt-wyjątku)\u003c/samp\u003e, aby każda obsługiwała\n    wyjątki danego typu:\n\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003e\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class MultiCatchDemo {\n  public static void main(String[] args) {\n    int[] array \u003d { 1, 2, 3, 4, 5};\n    Scanner scan \u003d new Scanner(System.in);\n    boolean isValid \u003d false;\n    int n \u003d 0;\n    int element \u003d 0;\n    System.out.println(\"Wpisz indeks od 0 do 4.\");\n    do {\n      try {\n        n \u003d scan.nextInt();\n        element \u003d array[n];\n        isValid \u003d true;\n      } catch (InputMismatchException e1) {\n        System.out.println(\"Wpisz indeks jako liczbę całkowitą!!! Spróbuj jeszcze raz.\");\n        String tmp \u003d scan.nextLine();\n      } catch (ArrayIndexOutOfBoundsException e2) {\n        System.out.println(\"Indeks musi być nieujemny i mniejszy od 5!!! Spróbuj jeszcze raz.\");\n      }\n    }while (!isValid);\n    System.out.println(\"Liczba w tablicy o indeksie \"+n+\" \u003d \"+element);\n  }\n}\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Blok \u003csamp\u003etry\u003c/samp\u003e zawiera trzy instrukcje, przy czym w dwu pierwszych mogą wystąpić dwa różne wyjątki:\n    nieprawidlowego typu danej wczytaje z klawiatury lub niepoprawnego indeksu. Każda z klauzul \u003csamp\u003ecatch\u003c/samp\u003e\n    odpowiada za jeden typ wyjątku. Przykład ilustruje też, że obsługa wyjątków zaburza normalny\n    przepływ wykonywanych instrukcji. Trzecia instrukcja \u003csamp\u003eisValid\u003dtrue;\u003c/samp\u003e zostanie wykonana, jeśli\n    w dwu poprzednich nie zostaie zgłoszony wyjątek. Gdy pojawia się wyjątek, wykonywany jest niejawny skok do\n    odppowiedniej klauzuli \u003csamp\u003ecatch\u003c/samp\u003e i wykonywany kod obsługi wyjątku. Po obsłużeniu wyjątku wykonywanym\n    jest pierwszy rozkaz za konstrukcją try ... catch ... Z tej przyczyny nasza pętla \u003csamp\u003edo ... while\u003c/samp\u003e jest\n    wykonywana tak długo, aż nie wystąpi wyjątek i zostanie zmiennej \u003csamp\u003eisValid\u003c/samp\u003e przypisana wartość\n    spełniająca zakończenie powtarzania iteracji.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 3",
              "stepic_id": 0,
              "task_files": {
                "src/SimpleThrowsDemo.java": {
                  "name": "src/SimpleThrowsDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.Scanner;\n\npublic class SimpleThrowsDemo {\n  static int getElement(int []arr, int i) throws ArrayIndexOutOfBoundsException{\n    return arr[i];\n  }\n\n  public static void main(String[] args) {\n    int[] array \u003d {1, 2, 3};\n    int sum\u003d 0;\n    for (int i \u003d 0; i \u003c 5; i++) {\n      try {\n        sum +\u003d getElement(array, i);\n      } catch (ArrayIndexOutOfBoundsException e) {\n      }\n    }\n    System.out.println(\"Suma elementów: \"+sum);\n  }\n}\n"
                },
                "src/ThrowsDemo.java": {
                  "name": "src/ThrowsDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.Scanner;\n\nclass ThrowsDemo {\n\n  static int getElement(int []arr, int i) throws ArrayIndexOutOfBoundsException{\n    return arr[i];\n  }\n\n  public static void main(String[] args) {\n    int[] array \u003d {1, 2, 3, 4, 5, 9, 8, 7};\n    int sum\u003d 0;\n    Scanner scan\u003d new Scanner(System.in);\n    System.out.println(\"Wpisz indeks elementu tablicy:\");\n    int n \u003d scan.nextInt();\n    int element \u003d 0;\n    for (int i \u003d 0; i \u003c n; i++) {\n      try {\n        element \u003d getElement(array, i);\n      } catch (ArrayIndexOutOfBoundsException e) {\n        element \u003d 0;\n      }\n      finally {\n        sum +\u003d element;\n      }\n    }\n    System.out.println(\"Suma elementów: \"+sum);\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eObsługa wyjątku - przekazywanie wyjątku przez throws\u003c/h1\u003e\n\u003cp\u003e\nDrugą metodą reakcji na błędy przy pomocy wyjątków, jest przekazanie wyjątku do funkcji wywołującej.\nZilustujemy tę możliwość, modyfikując poprzedni przykład. Tym razem odczyt z tablicy będzie realizowała metoda,\nktóra będzie przekazywać wyjątek.\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nimport java.util.Scanner;\n\nclass Task {\n\n  static int getElement(int []arr, int i) throws ArrayIndexOutOfBoundsException{\n    return arr[i];\n  }\n\n  public static void main(String[] args) {\n    int[] array \u003d {1, 2, 3, 4, 5, 9, 8, 7};\n    int sum\u003d 0;\n    Scanner scan\u003d new Scanner(System.in);\n    int n \u003d scan.nextInt();\n    int element \u003d 0;\n    for (int i \u003d 0; i \u003c n; i++) {\n      try {\n        element \u003d getElement(array, i);\n      } catch (ArrayIndexOutOfBoundsException e) {\n        element \u003d 0;\n      }\n      finally {\n        sum +\u003d element;\n      }\n    }\n    System.out.println(\"Suma elementów: \"+sum);\n  }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Metoda \u003csamp\u003egetElement()\u003c/samp\u003e nie obsługuje wyjątku. Dodanie klauzuli \u003csamp\u003ethrows\u003c/samp\u003e powoduje, że jeśli wystąpi wyjątek o wskazanym typie (w tym przypadku \u003csamp\u003eArrayIndexOutOfBoundsException\u003c/samp\u003e) to zostanie on przekazy metodzie, która wywołała \u003csamp\u003egetElement()\u003c/samp\u003e. Dlatego w metodzie \u003csamp\u003emain\u003c/samp\u003e musieliśmy dodać konstrukcję \u003csamp\u003etry .. catch ... finally\u003c/samp\u003e, aby obsłużyć przekazany wyjątek z metody.\n\u003c/p\u003e\n\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 4",
              "stepic_id": 0,
              "task_files": {
                "src/FinallyDemo.java": {
                  "name": "src/FinallyDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class FinallyDemo {\n\n  public static int getElement(int[] arr, int i){\n    int element \u003d 0;\n    try{\n      return arr[i];\n    } catch (ArrayIndexOutOfBoundsException e) {\n      return 0;\n    }\n    finally {\n      return -10;\n    }\n  }\n\n  public static void main(String[] args) {\n    int[] arr \u003d {1, 2, 3, 4};\n    System.out.println(getElement(arr, 3));\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eBlok finally\u003c/h1\u003e\n\u003cp\u003e\n    Blok \u003csamp\u003efinally\u003c/samp\u003e ma jeszcze jedną ciekawą właściwość. Blok ten jest zawsze wykonywany jako ostatni\n    w konstrukcji \u003csamp\u003etry ... catch ... finally\u003c/samp\u003e bez względu czy w dwu poprzednich blokach występują instrukcje\n    skoku w tym też \u003csamp\u003ereturn\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass FinallyDemo {\n\n  public static void main(String[] args) {\n    int[] arr \u003d {1, 2, 3, 4};\n    int el \u003d 0;\n    try{\n      el \u003d arr[3];\n      System.out.println(el);\n      return;\n    } catch (ArrayIndexOutOfBoundsException e){\n      System.out.println(\"Niepoprawny indeks\");\n    }\n    finally {\n      System.out.println(\"Koniec programu\");\n    }\n  }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Efektem wykonania programu będą dwa komunikaty:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003csamp\u003e\n4\nKoniec programu\n    \u003c/samp\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n   Jest to kolejny dowód na niezwykłość instrukcji \u003csamp\u003etry\u003c/samp\u003e i ilustruje jak zaburza ona\n    kolejności wykonywanych instrukcji. Teoretycznie powinien wyświetlić się tylko numer liczby z tablicy bo\n    za instrukcją \u003csamp\u003eSystem.out.println(el)\u003c/samp\u003e znajduje się \u003csamp\u003ereturn\u003c/samp\u003e, który powinien zakończyć\n    działanie programu. Blok \u003csamp\u003efinally\u003c/samp\u003e musi wykonać swój kod i dlatego został wyświetlony\n    drugi komunikat.\n\u003c/p\u003e\n\u003cp\u003eNależy też pamiętać, że jeśli w każdym bloku instrukcji \u003csamp\u003etry\u003c/samp\u003e znajdzie się \u003csamp\u003ereturn\u003c/samp\u003e,\nto metoda zwróci wartość instrukcji z bloku \u003csamp\u003efinally\u003c/samp\u003e:\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\npublic static int getElement(int[] arr, int i){\n    int element \u003d 0;\n    try{\n      return arr[i];\n    } catch (ArrayIndexOutOfBoundsException e) {\n      return 10;\n    }\n    finally {\n      return 0;\n    }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Bez względu na to, czy wystąpi wyjątek, czy nie , to funkcja zawsze będzie zwracać wartość 0,\n    bo \u003csamp\u003ereturn 0;\u003c/samp\u003e z bloku \u003csamp\u003efinally\u003c/samp\u003e zawsze będzie wykonana jako ostatnia,\n    i anuluje wartości zwracane z poprzednich bloków.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 5",
              "stepic_id": 0,
              "task_files": {
                "src/ThrowDemo.java": {
                  "name": "src/ThrowDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class ThrowDemo {\n\n  static double divide(int a, int b) throws ArithmeticException {\n    if (a \u003d\u003d 0 \u0026\u0026 b \u003d\u003d 0) {\n      throw new ArithmeticException(\"Dzielenie zara przez zero: a \u003d \" + a + \" b \u003d \" + b);\n    }\n    if (b \u003d\u003d 0) {\n      throw new ArithmeticException(\"Dzielenie przez zero: b \u003d \" + b);\n    }\n    return (double) a / b;\n  }\n\n  public static void main(String[] args) {\n    try {\n      System.out.println(divide(10, 0));\n    } catch (ArithmeticException e) {\n      System.out.println(e.getMessage());\n    }\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eZgłaszanie wyjątków przez throw\u003c/h1\u003e\n\u003cp\u003e\n  Tworzone własnoręcznie klasy też powinny zgłaszać wyjątki w sytuacjach wystąpienia błędu.\n  Możemy samodzielnie je tworzyć i przekazywać. Wyrzucanie wyjątku polega na utworzeniu obiektu wyjątku i przekazanie go instrukcją \u003csamp\u003etrow\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n  Na początek prosty przykład ilustrujący rzucanie wyjątku:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass ThrowDemo {\n\n  static double divide(int a, int b) throws ArithmeticException {\n    if (a \u003d\u003d 0 \u0026\u0026 b \u003d\u003d 0){\n      throw new ArithmeticException(\"Dzielenie zera przez zero: b\u003d\"+b);\n    }\n    if (b \u003d\u003d 0){\n      throw new ArithmeticException(\"Dzielenie przez zero: a\u003d\"+a+\" b\u003d\"\u003db);\n    }\n    return (double)a/b;\n  }\n\n  public static void main(String[] args) {\n    try {\n      System.out.println(divide(10,20));\n    } catch (ArithmeticException e){\n      System.out.println(e.getMessage());\n    }\n  }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Metoda \u003csamp\u003edivide()\u003c/samp\u003e testuje wartości obu argumentów i w zależności\n  od ich wartości rzuca dwa wyjątki tego samego typu. Rzucając samodzielnie\n  wyjątki klas bibliotecznych, mamy możliwość podania własnego komunikatu.\n  Korzystając z metody \u003csamp\u003egetMessage()\u003c/samp\u003e wyjątków możemy\n  wyświetlić nasz własny komunikat.\n\u003c/p\u003e\n\u003cp\u003e\n\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 6",
              "stepic_id": 0,
              "task_files": {
                "src/CustomExceptionDemo.java": {
                  "name": "src/CustomExceptionDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class InsufficientAmountException extends Exception {\n  long amount;\n  InsufficientAmountException(long amount, String message) {\n    super(message);\n    this.amount \u003d amount;\n  }\n}\n\nclass ExcessiveAmountException extends Exception {\n  long amount;\n  ExcessiveAmountException(long amount, String message) {\n    super(message);\n    this.amount \u003d amount;\n  }\n}\n\nclass Bank {\n  static long MaximumAmount \u003d 15000;\n  private long balance;\n\n  public Bank(long balance){\n    this.balance \u003d balance;\n  }\n\n  public void withdraw(long amount) throws InsufficientAmountException, ExcessiveAmountException {\n    long newBalance \u003d getBalance(amount);\n    if(newBalance \u003c 0)\n      throw new InsufficientAmountException(amount, \"Za mały stan konta na wypłatę\");\n    if(amount \u003e MaximumAmount)\n      throw new ExcessiveAmountException(amount, \"Zbyt duża kwota wypłaty\");\n    balance \u003d newBalance;\n  }\n\n  public long getBalance(){\n    return balance;\n  }\n\n  private long getBalance(long amount) {\n    return balance - amount;\n  }\n}\n\npublic class CustomExceptionDemo {\n  public static void main(String[] args) {\n    Bank myBank \u003d new Bank(2400);\n    try {\n      myBank.withdraw(300);\n    } catch (InsufficientAmountException e) {\n      System.out.println(e.getMessage() + \" \" + e.amount);\n    } catch (ExcessiveAmountException e) {\n      System.out.println(e.getMessage() + \" \" + e.amount);\n    }\n    System.out.println(myBank.getBalance());\n  }\n}\n"
                },
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eTworzenie własnych klas wyjątków\u003c/h1\u003e\n\u003cp\u003e\n  Gdy stworzymy klasę i nie znajdziemy gotowej klasy wyjątku, która pasowałaby do zgłaszanego\n  błędu, możemy samodzielnie stworzyć własną klasę wyjątku.\n\u003c/p\u003e\n\u003cp\u003e\n  Na rysunku poniżej znajduje się hierarchia klas, które służa do tworzenia wyjątków i błędów.\n\u003cimg src\u003d\"\\img\\throwable.png\"\u003e\n\u003c/p\u003e\n\u003cp\u003e\n  Z klasy \u003csamp\u003eThrowable\u003c/samp\u003e wyprowadzone sa dwie klasy. Klasa \u003csamp\u003eError\u003c/samp\u003e służy do zgłaszania poważnych błędów, których nie można\n  naprawić ani odpowiednio zareagować. Są to takie błedy jak brak pamięci (ang. \u003ci\u003eout of memory\u003c/i\u003e, przepełnienie stosu (ang\u003ci\u003estack overflow\u003c/i\u003e, błędna definicja klasy, brak\n  zdefiniowanej klasy itd.\n\u003c/p\u003e\n\u003cp\u003e\n  Klasa \u003csamp\u003eException\u003c/samp\u003e odpowiada za wszystkie pozostałe błędy, które można obsłużyć i ewentualnie naprawić. Wyjątki dzielą się na dwa rodzaje:\n  \u003csamp\u003echecked\u003c/samp\u003e, czyli takie które muszą być obsłużone lub przekazane do obsługi jawnie i \u003csamp\u003eunchecked\u003c/samp\u003e, które nie wymagają jawnej obsługi. Oba rodzaje są funkcjonalnie identyczne.\nPrzykładem wyjątku typu \u003csamp\u003eunchecked\u003c/samp\u003e jest \u003csamp\u003eArrayIndexOutOfBounds\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n  Własny wyjątek musi być klasą wyprowadzoną z klasy \u003csamp\u003eThrowable\u003c/samp\u003e lub jej potomnych, najczęściej z klasy \u003csamp\u003eException\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass InsufficientAmountException extends Exception {\n  long amount;\n  InsufficientAmountException(long amount) {\n    this.amount \u003d amount;\n  }\n}\n\nclass ExcessiveAmountException extends Exception {\n  long amount;\n  ExcessiveAmountException(long amount) {\n    this.amount \u003d amount;\n  }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nObie klasy można teraz wykorzystać do definicji klasy konta w banku.\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass Bank {\n  static long MaximumAmount \u003d 15000;\n  public void withdraw(long accNo, long amount)\n    throws InsufficientAmountException, ExcessiveAmountException {\n      long balance \u003d getBalance(accNo);\n      if(balance \u003c amount)\n        throw new InsufficientAmountException(amount);\n      if(amount \u003e MaximumAmount)\n        throw new ExcessiveAmountException(amount);\n      //else withdraw...\n  }\n  private long getBalance(long accNo) {\n    return 0;\n  }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {
                "img/throwable.png": {
                  "is_visible": true,
                  "text": "iVBORw0KGgoAAAANSUhEUgAAAtgAAAFRCAIAAADB5k3fAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAF4XSURBVHhe7b2PUxRXwvd7_5OmpmFKKQwgcvUSlVeLNZGrlOujrK4VII-RMalFcr3g5grmCbj3leFNmLwumGSSPJAy40Y0NeRJIOuYcnzCRAdLssIuXB0jiWDwEV5RYPkhMzb3dJ-enp7f3fyYH8z3U13UMN19pvv8_PQ5p7v_t3kAAAAAgCgBEQEAAABA1ICIAAAAACBqQEQAAAAAEDUgIgAAAACIGhARAAAAAEQNiAgAAAAAogZEBAAAAABRAyICAAAAgKgBEQEAAABA1ICIAAAAACBqQEQAAAAAEDUgIgAAAACIGhARAAAAAEQNiAgAAAAAogZEBAAAAABRAyICAAAAgKgBEQEAAABA1ICIAAAAACBqQEQAAAAAEDUgIgAAAACIGhARAAAAAEQNiAgAAAAAogZEBAAAAABRAyICAAAAgKgBEQEAAABA1ICIAAAAACBqQEQAAAAAEDUgIgCEh2WSsKhdxLgDAICQQEQACA-aVbUgxgAACoGIABAeNKtqQYwBABQCEQEgPGhW1YIYAwAoBCICQHjQrKoFMQYAUAhEBIDwoFlVC2IMAKAQiAgA4UGzqhbEGABAIRARAMKDZlUtiDEAgEIgIgCEJ3yz-tB8yO9BGp7loPmhs9uQIXwQd4gqoQ5msrthO8uUtT10il8sCHLW4icAAAgJRASA8IRvVid7LhgaDA3CUvNaLpGPTa_V0n8bGt5v7ZmEiAAAQCAgIgCER12zSntHfJp5iAgAAAQCIgJAeJZMRH77trHh8BYNP16jzX29qfMBbe2d3Q1ZzNaqj5rKc1NZJnt_c9-zedfknY73ywqy-MEdNiv_zSbLT5Pc_Dw3cKE4k80xdM-Sfwij1qrNLLNNbx8X_n0-bn17DbNdb38yT0Lo_7L2QK6WDyGJzSg8cbGPD4EgHsyJprpXc_mDSd1S-mfLwISw0kdEOOdD-2dVhcJhpOYeOHmx_ykNIzQQEQCAQiAiAIRnyUSEKMXuqo_bv7dbPq18OY3VHL4w-ExYSUREEIKDJ-oqdCcsv073fVKoSdK-XGls77xp-9pYsVPLbDzcendufsbRfIBlDrQ4ZvhgXT1NL7Isk7bP9JPgBxPdDTvZ1W9bx11zA62H16ZkF9W1XrnedeULfVEOy-SdsD7iNxMPhoR_rNlis7V_xB9M7knrCJEPLxHhxn6oz09j15boz39n77xYTwJZW35hYJr_qZBARAAACoGIABCeJROR5LIL9wWBmHeOtFesYnIqLY-ElbyIaIvODThpd8MjS0WObOP5-TmHqTiLXfcn24TrWU_TNiZLZx4km3IDpn28wSStqrCMkc1cfcbfpKwqax_hnnTVbWeTy9uG52gA3GBriSYpvcY2Rf6hB6MpabnD_0dWTne_n8ekFhj_MeclIrMDpoNapqDe_pgeFjd25cQ6Vghf-D84EBEAgEIgIgCEZ8lEpND0s7sJF-Qj85B5yP05dVfz7ed03axd_0KSttQ87GnvncPmI1o6BDNlq02jSuEas7y1Kq3CUL-bDtYIXpJZ0jrAcQ86yjbKf048AHpUfgczP3vTkMOyRa1DnExEnt9uKUhl85p6n0nbjXfVbWOT37KMucQvggARAQAoBCICQHiWTERkX_qJiPiZRwghq6GbTtOgyLYR5oX8xtjv4rVAW_rl7Stvr2FeNQ1M814ijdqIcM7Ruz_arR3n615J9hKRzDr7LN2EZ6jtYCabQX5SJiLj1urVSezuBku3xA1Lw36WKTT2hxmdgYgAABQCEQEgPDEmIrR35FXTvZ6WgvSXjH2uodZifpSn31azVRAUsrl8kqkwN-Wll_h5qTIR8Q4_kIjQEwmwbDd0T4r7BYFsJn4CAICQQEQACI-6ZnXxIhJgaGZuqFUn3R0jDMFsrv7ceESztdY2JkwNSd1Y_8H7v0nNqbPz8z6e3zX9Lp1dW2owX-lyjPLCIT8Av4OhQzPaP7SPyOeIjFkqk93TSlQCEQEAKAQiAkB4Ii0iASar9rcUprPJFR38jS10UmpqZka6VnOkbZh8Q2_iTWKJnVhH-Q18-1Rck92nd0hHRQ_GE75rwv5uHpO-33T3uVxEuPttumx2XY1VmhHCPbJW57EZlR1kbUggIgAAhUBEAAhPxEWEmwl0-67O1O8WE-GmGPIr4kAM7S8hbuGeRvrs78aCNHZt6fvfdHbf7Oxorn1lLctvwE9HdR8Mk6TNrzZd-cH2TeOR3FTtztPdE2RfmYgQfen5sFBDbznu7LZ_11pXks2k7dD_MObpqgmMuhgDACQwEBEAwqOuWV0CESH4PNCs_P322-LjyHjog8uS1lRZ6YPMXP3Gl4hYeEZzuJmBDn0RfZpZau6Bmpar19uOb2ZXH7c8dtGDyTz-ycXa_UL42XuqznY9pFNX5SJCkB9GknZTcU2L_aF4j3EoICIAAIVARAAID5pVtSDGAAAKgYgAEB40q2pBjAEAFAIRASA8aFbVghgDACgEIgJAeNCsqgUxBgBQCEQEgPCgWVULYgwAoBCICADhQbOqFsQYAEAhEBEAwoNmVS2IMQCAQiAiAIQHzapaEGMAAIVARAAIj5pmdbLPWLSm-Ny9OfdTv5yPesynK_duFp4tlsRmFJQbvuoZkV586_MAsaXA7-FpC0P2mLXpeybdmr2f9M2Ef5QZBSICAFAIRASA8ChuVrm5Oy37NLsM3fR5p_Pc5N9NZdu0_LNN3zI0n28zf95UuTeLf7b6KetwwCeZLgVLLyJERW4atmbta-6fE1aFBSICAFAIRASA8ChtVoW3xK3SSc9ZH-9p3Me_I6alV_Z09tlhS80WJsm9WZyIyPyzwdbD2rXHOoYVqQhEBACgEIgIAOFR1qxyc_0fF0jvvyX_D5sPJydpC1sc0jANRfAV7abqS7x8UBHZW_NRvS43lfwQq8nTNX4_LL3PxTnc1VK9J4N_ZZ12U3HtxT6Z0_AvgjGU5rlfKHPyYv9TfqWXiDhHOvU7NGx26dm-SeF9eCEC9Kxis3b_21-MlZmyN-BwI-3lyfQNveGBiAAAFAIRASA8yprV6X5joef9t_OuMctbq5i0faafvDXEByoiSWxGYfXHX9vsf23mX7SbWdI6wO_Fjdr1u7VMTnHdF1b7VbO-JJvZeLj1rtApwTkHzeVrWe3Lx5ot17ouNR5ay7K0x8IjIq7JvrM6ss3eD3uohYQKcMrRXMKv0l_svNn5TeORLRriN7JX8XG_dpRtYAuaHQpMBCICAFAIRASA8ChqVrmfTIVpbKHpZ9E7BC9htunt4nyRIFARyda13qNjM0LHQ9KqCsvY_PzzAdN-TUqe_voEDZN7ZK3OY5MrOkbItk-66siOhU09E8K6uWFzueg9bhEZHL50IjdFNh8lZIDj1urV0oARWfW_bLUveYnI_Iyj-QDL6C4MhR-dgYgAABQCEQEgPIqa1SlbbZrnvfxuw9hu6J4UvwgM3exV04D7PhpPfwZt-Hc39UghcLN2fSaTU2l5NO_qaXqRlfdPcEOtxUz27013XDSEl4oP5aexq4-2_SrdoRMiwP8SPmTpzIOiR81zU7aT6V4i8nzc-vaa8GrFAxEBACgEIgJAeBQ1qw_Nh5ikrIZu96RTVT0issmqHhEZtVZtZpn9BsuNbglLwx4m5SVjn2uk_YgmKb3GNiXuJoOGQO8WZvJOWB-53SJEgLcemMt8tEkwG7mIkIDl01dDAREBACgEIgJAeBYkIrT_IOAcEdeY_dyZc5d7-aeJhBCRobaDmW6f8Fr4X_H9ORk0hOSDxqut1etYduu7XRN02kqIAO1DfiIinBFEBACwvEBEAAiPomZ11q5_QT40I872CHbXjHuIJISIPLJU5LBpJ21TfiZDEKZ0ePWIcCO9l692OUadnhBmBlvLVjHphcbeGX6LEAFys92Gjd5DM8I3_kMzW2ttY-IXwYGIAAAUAhEBIDyKmlXulwtF6d43lYx3N-xi1T5HxKMRdP6pfGzFNWatWc9sLG9_wFGbWVdjFW_SoXcLszl19ilPCPPzc_0thelsss50b9o9oTVIgFN2_QZ2VenFQfHOYXrwchGZ_dn0qtd0luBARAAACoGIABAeZc2qMBVUvKVFhBv7oT4_TXjIh_Bk1dZmQ0W4J6vKNIKb_PHM3nTxzt6bduv5uuK1rDb_PTsvH9x0z5kCDZtdVNd65XrXlS_0RTns2vILA9PyEIhqTNjfzWPY7CPfEO8JGeDMoLkim8kurPncav--w1iZ73P7Lu1Q-Y2xXzSfUEBEAAAKgYgAEB6Fzapwc-yG8vZfPd0fvEzcu9pc88om4WFlZAn7rhkvjSC73-4wlO8Qnj_GanJfeeds10Np39mR7i9qD-TSB5ptKTV03Bnnf9o7hHlu2HJsqzRrNVSA3LjjK32xcKja3HLj-XcPyEWEHwxKV_iUdxKC-AkAAEICEQEgPEqbVd9HvK8khGEdPOIdALDUQEQACI_iZtX3pXcrB7z0DgCwPEBEAAiPmmZ1ss9YtKb43D2fO2Xim-l7Jt2avZ_0zSg9KYgIAEAhEBEAwoNmVS2IMQCAQiAiAIQHzapaEGMAAIVARAAID5pVtSDGAAAKgYgAEJ74bVanp6fFT5EFIgIAUAhEBIDwRLdZffz4cZvZfOvWLfJB_CokRD7Ixp-fPfvG669XHT8ufhtZICIAAIVARAAIT9Sb1cuXL5NjIMuW3FziFv5eIpcPuiVZ9hUWokcEABDjQEQACI_UtGNRvohxBwAAIYGIABAHOByOa9eu_ctvd_s09vV6_bTAB2c-8FlFlqrjx8kGbWYz2ZeEEK3eEQAACAFEBIBYhHjD5cuXiV7QoZZ9hYVEKf7vo0clydiSm3vr1i1xawGyCzEPaYP_909_ovpCRITsK62CnQAAYgqICADRh9gAcQJqDNQ8yF9iIcRF5K5AdITKBFkVTCCIXhBHoZv5T26lPxTQTshCvqS_qHBWLAAALB6ICABRgLT0t27dojZA9YJ4wOdnz1IPEDfyhnxPNiMbB9tAgtgGCZlsTP6KX4UkmJ3Qm25gJwCAZQUiAkAkkMyDNO20x4KaB2n-Hzx4IG4Ukg_OfEC2D9YR4g_5RbK9-M-CIPJBj5n8tHTYsBMAwNICEQFgWSB6QSSDqABptkn7Hey2W-XESJOvxE4UqhUAABAgIgAsDaQBJs0wbZ5J20ynl5K2ORG6DQLaCYkB8pmoGI0E2AkAICAQEQAWAp1XQZteaXqpZB7KB1BWMJKd0G4hOhUGdgIA8AEiAoAiJPOQppcS8yAWEmJ6KfCHmAeNRtgJAIACEQEgMI8XPb0UKCSgndBZNUT1yPckIWB7AKxUICIAiJDmUJpeSlpB2hDSVhDmEXl87ISOf8FOAFh5QERA4kKascuXL9N2ThogoC0c7kqNTUi60FQjyQQ7AWBlABEBCQRtw6TppcQ8ML10BRDWTq7hYfYAxDAQEbBiwfTSRCagnZCFfKb2CTsBIEaAiICVg3x6KTUP8oFOL4V5AAK1E5IfqJ6S7AE7ASDqQERAHPPgwQPJPKTppdQ8ML0UKIT2nMFOAIgWEBEQT8hvbCFNBTUP0lRgeilYWoLZyRt41Q4ASw1EBMQ0pK7H9FIQI_jbCVFh2AkAiwQiAmIIWtHTWp6aB_lLb3yAeYCYhWROOkRI8irsBAC1QERANKGTB6l5SNNLcWMLWAGEthOykA0wkwkAAkQERBRiHvLppdQ8ML0UJAgB7YQoOC0FsBOQmEBEwPKC6aUAhIbIB4EUClpMaNcg7AQkDhARsMSQSvOy93PT6fRSmAcAyiHmATsBCQJEJP4g9REWtYsYdwCExCfbYInYIiYASEggIvFHzBbamO3wQDUHFBKPWYX2ncR1dyNKaIIDEYk_UGjVghgDCkFWiQqI9gQHIhJ_oNCqBTEGFIKsEhUQ7QkORCT-QKFVC2IMKARZJSog2hMciEj8gUKrFsQYUAiySlRAtCc4EJH4A4VWLYgxoBBklaiAaE9wICLxR5wX2mdPn0xx4ucIgWoOKARZJSog2hMciEj8oabQDrUdzCTbB1oyD5mHxK0ixsy9S_qSLQ3dTv6fye6G7SxT1vZQ-G85IecrfgIgJMgqUQHRnuBAROIPNYWWisjWQzXvGhoavJfGCz1PxK0ixkPzISYpSxSRGUdr9aHS07Yxl7BuGUE1BxQSG1klxq4flh9yauInkJBAROIPNYWW1miR6HVQhJeIRA5Uc0AhsZFVYuz6YflBCU1wICLxxxKKCDd25cQ6ll1XY6XdEtzjLn0BqQGPtd_nd-DGHe0GXW4q-UVWk_tKzZf9k-7eC-dwV0v1ngyWrNJuKq692DdJ5304uw0ZSZnHP7lY92quhlzApW4p_bNlYIKsdHY3ZHku7MghPfEemnFN3ul4v6xA2IbNyn-zyfKTPMysUxetja9v4cPk157pfKDcZtTEGEhoYiOrxNj1w_KDEprgQETiDzWFNmyN5hyxVK9nUvL01yc418TN0wUadv2xSyO8AcwMmiuymbT8ik8t9muXGnXZDJt95Jthsoobtet3a5mc4rovrParZn1JNrPxcOvdOT48XhrIEWpfPtZsudZl-bTy5TRt_nv2MRc3OdRradjDJKVXmG503x11yueIcDN9nxRqyF6VxvbOm7avjRU7tb5hstlFp0yXOu1CmKzm8IXBZ_wZKADVHFBInIiIUHZeqDQ2H-XVPONgS89V4QLgTEvZNi0x9d819z_jhAuJ0-X5WeSkWCZrR1kTvSQIsHv_P4VgowZKaIIDEYk_1BRaBZdWzoG2ss2spqTl1nXj3nR2XbVlRNh4yq7fwLL5Z3pnhLqLu9-my2aZV00Ds88HTPs11F34NfPcI2t1Hptc0UF2pNJAQrszRddNd7-fx6TvN919Tv7zGpqRi8gjS0UOm1x24f4Mv4Yw5zAVZ7Hr_mSbeC6GmVzeNsxrCS9P7RWrmJxKyyPh3_CgmgMKiScRIXqhyTv0zsnKopOWYbt4AZD7Ws2pimJSiLnJPmORlr-Q-KjDZre1f8Tr-9ryCwPTAXanRT56oIQmOBCR-ENNoaU1Gl9D-S4Z0kwNbu7euZJk-v3WP1r4Lg-Cq6dxM5O6q_k2LxA8c0OtOjaj1OR44mg-wDK7m3omxTXz3Kxdn0nNgEpDoelnGgrB1dP0IssWtQ6Rb4KJCNn_hSRtqVn8bR7nsPmIltmmt4-LYdIQ6Dp-lEfFrD1yauInAEISG1lFoYhkFpsc4hbiBUCpacCt8mOWyuSkVaUXB5202NBizq6v6Zzw3z3aoIQmOBCR-ENNoaU1WqBZbx9Yh9yKMT8_1W_cT4LVFp0bEKst10j7US2ztdY2JvwrZ9RatZll9hssN7ol-DGXlJeMfS6hQvSejiocA_WeYCISaBKrxzZoJXvQ_FBcAxEBy0UsiYjsskFaxOsHWnYOtDjc2kHLSEGzQyzU9NogS2ce9Lg9N9hWmsW-oO-a9ds92pBTEz-BhAQiEn-oKbRhL60EnPculGbz1ZxncMT50FzGMtsN3VK3h0TQWpI3CYgIiGdiI6vQIhbi-kFWdii-ZSRg-ZX28pknHn1QQhMciEj8oabQKhGRueH2Y9lM1ivHj-7RuKejzj8ft769xrtHhBvt_c56wzF6n5_PkXbSFvD5qEKFqP1D-4j4vzg0I36jYmhGGAmSD81ARMDyE0siEqLYQkTAigIiEn8srYhwI5f-uI7V7jzTM_20p3Gf1j1NhBs2H05m11dfGRPlYG7YXL6K2a63jwgf8k5YH7m1wTVmrVnPbCxvf8DRCtEzsdQ1YX83j8ksaR3gNw4mIgEmq_a3FKZ7TYCFiIDlZ6WISMChmV8uFKXLhmYgIiBWgIjEH-pFJOCTkQwfWgefcyO22nyWyT9p4-_Y5ca-P5mbwuaeEp52Oi54Cb1H97r1fF3x2pRsXevAHMdN_nhmbzqbUVj98de2m3ZhFUvv0RUrRP5W27rWKz_Qufranae7J4QHkIxbq1cnafOrmlu_658cl9WGgW_f1Zn6eTGBiIBIsVJEJNBk1Tst-zRJq8raRziICIgtICLxh3oR8ZrJIS1ZDTfG-O4K6cEhBDpM47411_mo-9zJVzbRB5rl6Ro6HO4HmnGTtzsM5TuEB5rxzzp752zXw1l-Ba0Qf3uiSXygWfaeKvcqAve0r-WNbP7XdzX1PPKuDX0eaFb-fvtt-QPNICIgAsRGVgl3_aBEROYD3r5bZrozGcBjog1KaIIDEYk_YrrQBqgQow-qOaCQWBIR8YLBZxFGNpWICPF-nweane64My64PUQExBYQkfgjpgstRATEM8gqUQHRnuBAROIPiIhaUM0BhSCrRAVEe4IDEYk_UGjVghgDCkFWiQqI9gQHIhJ_oNCqBTEGFIKsEhUQ7QkORCT-QKFVC2IMKARZJSog2hMciEj8gUKrFsQYUAiySlRAtCc4EJH4A4VWLYgxoBBklaiAaE9wICLxh5pCyz_UaE3xuXtz4gPL5p2PesynK_du1tLHEmQUlBu-6hlxP3BsOR4wsET30cgeYjZ9z6Rbs_eTvhn3SYUD1RxQiPqsIjwUeLXOdG86-BNRwz4pNTxqH-KngCUq7J4Czs3dO1eyusjY5_-mzDCghCY4EJH4Q3GhpQ913mXoHhf_n_y7qWyblknNPfCWofl8m_nzpsq9WUySNv-UdZi6SFyICFGRm4atWfua--n7bMKCag4oRHVW4V-KlJXXcJNoSMKLCGG8u2GXtrDFIV35KAMlNMGBiMQfSgstd79Nl71KJ73Slr47ZqOupVd8dDrP7LClZguT5N4sTkRk_tlg62Ht2mMd4qv1woBqDihEZVYR3gTpecUjRGSeG2wt0Wx-s31IlYmghCY4EJH4Q1mh5eb6Py5gNldbR8X_-bfpJgW4WBF8Rbup-hJfH9G6aW_NR_W6XPcrZhq_Hxbfm0UqneGuluo9witmtJuKay_2yZyGf1mMoTRPGPRJzT1w8mL_U36lVz3lHOnU79Cw2aVn-_jX1nDOh_bPqgqF98vIdqF4fovN2v1vfzFWZsoqYm6kvTw5fb_p7nP6f0hQzQGFqMsqc_8w7kxdU2UVuxwViYhQxDJOmq-cEYtYRkF5k6yI8c9lN7hLX-4rNV_2Cy94EkQkbfc7f5aK2JbSM51iRyZh9qH9bPXubJ-9KPyboRoOb-Hf_SQvtl4iwo1c_VN-Grv2jc_6aBkMEaBsVUbhiXMfVr0gu9Lgfu0o26D9nWlAScl0Q4ISP4GEBCISfygrtNP9xkI2-S0L_x5dgmvM8tYqJm2f6SdPSx8AWjfx9Qv_Zl37X5v5t-C6X-LPjdr1u93v471q1pdkMxsPt94VLgY556C5fC2rfflYs-Va16XGQ2tZlvZYeETENdl3Vke22fthj1CpcWM_1PN1X4n-_Hf2zov1RTns2vILA0In9_yUo7mE_y39xc6bnd80HhGqUdkVoVDfsQXNDgX1Hao5oBBVWcXVb3yJyam0PBL_Vy4ipIiRbG_61reIzc8Mmiuy-TfVfWqxX7vUqMtm2Owj3wxzVERIEcjeU_Vxh81maT6Wr0nSFrcKr_l3jdnf4_1eeOV1p7leelE2H6RzoK1sM6vZWdn81y57R9PBjSxDeyw8IsJN9n5WupHVHDjT80TYJ0SAdMCXrKo3d9ptpGRSZ_J0eTpH2itWMQdaHPybsxWCEprgQETiD0WFlvvJVJjGFpp-FuoV0UuYbXq7--ItMLRuInXOPVqVCh0PSasqLGPz888HTPs17hfz8useWavz2OSKjhGy7ZOuOrJjYVPPhLBO6LKm3uMWkcHhSydyU2TzUWYHTAe1TEG9_bEY3tiVE-tY4TXl8_Pj1urV0oARWfe_bLUveYnI_Iyj-QDL6C4MhR-dQTUHFKImq8z-bHqVZV41DUjdEspFJPuw-b6YtWVFbH7Krt_AsvlneulEbKG3kv4EFRHPa_2piNMrjed3Tb9LZ7e-2zXhvuqw1qxnNpS3_8rNc1P2-hwmdUfj36gX0J5RoWZwi8jggKV6O6v57ckrD8TjDhXgqLVqM-sZjXKN2_57jpeIzD93NO9i0otbf6EnqASU0AQHIhJ_KCq0U7batCRZpzGtdLYbukNPaKebyepWT38Gbfh3N_VIIXCzdn0mvSJ09TS9yMr7J7ih1mIm-_emOy4awkvFh_LT2NVH2351h_z8dktBKpvX1PtMqq_Gu-q20bpVCDlLZxau93i4KdvJdC8ReT5ufXtNeLXiQTUHFKImq4zZarayq9-2jkudcspFRCbQsrFLV0_jZiZ1V_Ntd4hzQ606NqPU5JihQzOyHk23Rjx0Cg1_yrbGW8_EVcSR7PoXqNxM9TbuYuX9E9wvF4oys_Z_7nDREF567WC-lskpN_8iHXSoAIUP2lJp5plY1chFhF5FZNbZJUELC0poggMRiT8UFdqH5kPiG8MpqnpEZDWpp5YUroSY_QbLjW4JS8MeJuUlY59rpP2IJim9xjYl7iaDhsD3KpMl74T1kViDCbUVu7vBIoZFuGFp2M8yhcb-iYfmMh9tEszGa7Ke8ul7qOaAQtRkFUEvMjxlTI2IBCxipBgd1TJba21854gPfrldCueZYORpexq-FYsRz7eG3Wnsb4z9ruGOP2SzaSdtU5I4SNAQaMFk11dfGRM3oYofJMAHPhULNZt0LxGRqZVCUEITHIhI_KGo0PqKiFi5BJoj4hqznztz7nIv_zSRELUkrUwlpfAs_K_4_pwMGkLyQePV1up1rKe_V9jFJyhhIf7xxF9EhO0hImB5UZNV_EVEaPWDiYjmaMcIyfkhihgpRn7Z3k1wEZkR9vIpRMLCH5v_QUrQELKKjd-aq_JYzyApPQy_0MhCwhnyL-nCT0BEwCKAiMQfigqt0IMqG5oRh6KD3TXjHnMJUUs-slTkBLm0Ers3vHpEuJHey1e7HKNOTwgzg61lq5j0QmMv3008ZqlMDtKJMs_Ndhs2eg_NCN_IK2KqVoEvH31ANQcUoiarCCOJXkMzdBzEL08KhZF9sbGXN_AQRSxAluZGe7-z3nCM0jkiAUVkVpiHHqwgCB2ZXsXWOdpz1cqXTM-ROO9f1JHKQXxIIJ3YHiTA2ZuGHNZraEb4xks7_GuDcKCEJjgQkfhDUaGl_aVeN5Xwzxpi1T5HxFNL0vmnsrEVcQrbxvL2Bxy1mXU1VvEmHTonjs2ps0_JL4_4pz-ls8nCYyj9dhFnv2ZUdpBfF2bteabmiQcvr4j9pwoGBdUcUIiarCJM4PC6PeT5hO1P6xk2u8zszreE2eH24-RLvizw_4YoYmKpkY2S0EK3XW9_ElxEnH570XnfKVll3zzk_IotLXcb6rumJmRHQm9SyyoxOeYCHIY8QGFaenLZhfvi5Nfp7vfzGHcBF-AGTPvC36DnBUpoggMRiT-UFVphbql4S4uIeLus9GTV1mZDRbgnq8pryckfz-xNF-_svWm3nq8rXstq89-z8ybBTfecKdDQ-_2ud135Qi_diysXkXnXhP3dPPGORNdkz4eFGjZrd9XH7Z3d9u9a60qymbQd-h-E6o_ex5hdWPO51f59h7Ey3-f2XdpDw4-Ci_-HANUcUIiqrCJM6qT3krih98oybFb-G7XvNRgaTlUfzBeKmL5TLImhihgRbuGpg_QO-etCERPvmw0hIvPck56mA1rxzt4bYunT7K63j_IHNv1j007xJvkusZTRu-69joSbuF6_NUW85T5UgPRG_ZSsvbWmKz_Y2j-qfJlUKXIRoR0qhcZ-eh--IlBCExyISPyhsNAKd9t615K8TNy72lzzyibh1n9-0Dfcu2a8aknhyUiG8h3CA834xxy9c7brobTv7Ej3F7UHct1PWzJ03Bnnf9o7BHK1ZTm21T1rlX8G2vtlBcIDEvhHLdW02MkFHt2Qf7LTV_pi4VC1ueXG8-8ekFfEfPdvusKnvJMQxE8AhERdVhFucxVvOHfjW8R8i0mYIjbvfNR97qS4uyZP19Dh8DzQLIiIEPjHoJ0uz88SfpRcadR8Zh92_wDnHLn5l5riXPpAs9zDhvbb_g80I78wYqleL81aDRUgKbb_oS8SSrpm2xHjWcPv5ZNV-cEgtU95J78ifgIJCUQk_lBaaIU-WNkj3lcSQoczHvEOlhqVWUXIh56HagA6rINHvAN1QETiD8WF1veldysHvPQOLA-qs4rXS-8AXnoHFgJEJP5QU2gn-4xFa4rP3VNZL8Q20_dMujXiDH9FoJoDClGfVbiZvk8KVwvzrxMdbu7euZLVRca-ALcfhwYlNMGBiMQfKLRqQYwBhSCrRAVEe4IDEYk_UGjVghgDCkFWiQqI9gQHIhJ_oNCqBTEGFIKsEhUQ7QkORCT-QKFVC2IMKARZJSog2hMciEj8gUKrFsQYUAiySlRAtCc4EJH4A4VWLYgxoBBklaiAaE9wICLxBym0WNQuYtwBEBKfbIMlYouYACAhgYgAFTx-_PiN11_3qUHoUrBjx-YXN-pKS32-pwvZ68GDB2IoAIAF8fnZsz4lS1o-OPMBWXy-pMuW3FyUPhDLQESAavzrO-IZe__lX8gHq9Xqbyr1ev30NB73BMAScO3aNSIWPkWMFEm69vLlyz6ryLUBLATEOBARoI5bt24RsZDXdMQ8urq6pM_EOeQusi4zk1zGPX78WNwfALBQSOEiIlJSXCyVL7IQ-RBXC5AN5GvJQgos-RIXAyBmgYgARRCTID5BLsX2FRaSiq_1_Hlax1HzqDp-XKr1yOWX3EX-_dNPyeUa2ZFsQ2pDMTgAgBpIsZLKkdVqlYpbwDJFNpZ6Tf7e-3dSYGl5JCGQCwlxIwBiBogICAOp6UjdR-o1Uos5HA76JTUP8g1xDuIotMqjC_mSbCC5CNEX-i8Jh0gMWdrMZnSQAKAEUnCIRpBSQwqg1LNIiiEtayHMXnIRqb-E7EuNhJZlGAmIHSAiIDBSFwipuUh9RypEcYUAqRmpcBDIZrRapAvZhW5MXYQoC92MQupQsiPZrF6vl7QGAOADEQWppPhIAymP5PsQFkKhBZBeCcihRVuSG8wgAVEHIgJ8IRWc1AUSrJKSLIRAtqT-Qf7SRboII1UhqUbpZzmkKmwzm2kHCdnYx3IASFjkRSNY3yEpMmEthEJKFglE_McPUrqpkZAFRgKiCEQEiITuAgkGvTgjO5LtyQeHw0HrNXF1OMilXljpASARIEWJTgMnZSHCnYW0n5KWfWI5Ae0HgOUDIpLoEIFQ0gUSDHm1RepQ-kHtLBAfBxK_BSABkGf-qPcO0vEgGAmIMBCRxIU4h1TpKO8CCYEkIguGHAY5GHJIpGpGJQhWMPQCgOb2BVwALCv02Gj3DPm7JJUDACGAiCQc8hqQtPdLWAMuXkQo1JBoJYi5_WCFIV0AVMX8De0wEhAZICIJxHLXgEslIhRS5V0WblwkS5vZjBoQxDXy_Bx3HX7kaMnBS_03uDwASwtEZOVDL2siMOSxtCIi4XA46DUZqQFxxy-IO0izLXUqxHsTTo2EuBQ1EpRHsCRARFYyEe4EXiYRoZAasM1sJudCjApdxCD2oTmWdoGsvImfpG4hVzVSBw_5V1wBgHogIisQqRN4ubtAfFhWEZEgFiLd47PCKnewMqBZNEH68KiRkPJIjQRFEiwAiMiKgj4PgHYCR6ALxIfIiAiF1HeR7OwBICxSk5yYnXa49RcsGIjISkA-D07tMzyWkEiKCEU-_SWKJw4SGXkmJC0xBimokZDaAKOoQCEQkfhG3gUS9XlwkRcRCXk8YAIdiAw016FbLiDUz6RZujASEAKISFxCinQsdIH4EEURoZBokU8PRMUHlgN56cOsiLCQ6KI9RjFyvQRiEIhInEGKsXSREWtFOuoiIiHFErrKwRISy6Uv9iHGRgROGsNCBAIJiEh8QMqwdK0fs5MhYkdEKCSW5JMHxW8BUIm89JGmNDZLXxwhxSdm1QAKRCTWkV_cx_jsh1gTEQnaM0xqPXSkA1WQnJM4N-JGHnqfETU88gFGkrBARGIUn4uwuJjuELMiQiHVHGlO6NRCdAuDENAGUupLw2Sj5Uaa9kurO1wtJBoQkZgjjrpAfIhxEaHIZxrG7CAXiArStEoMGUQLUvtRIyGpACNJHCAisUI8doH4EBciIkEkL06FDyw50hU5bsSNEUgq0OJJUwSdUisbiEj0IcVsZYxDx5eIUOT-h_ou0ZB3j2H-UAxC-6iokZC_KKErFYhI1CC1njQOHaddID7Eo4hIUB1En3yCIA2Akr-YMBT7UGWURs2QZCsMiEgUWKltXlyLCEWyQ3TRr0h8BkDRBRJ3kCSDkaw8ICKRQ94FsiL7GFeAiFBohzCt7DChdWVA7Z9k0XgfAAUUemeTNKyGXsy4BiISCVZqF4gPK0ZEJOgcRnTgxy-0uVrB9g9gJCuAmBMRUuljif1FTC1vgn0fEHloWJZ1EWM8NvA5thW2iCcZbXyOCkuiLWI-iB9iUUTETyBWCZZGqtIOCR0ZYi2eV3C6x86poXAlMvGY-hARoJpgaaQq7ZDQkSHW4nkFp3vsnBoKVyITj6kPEQGqCZZGqtIOCR0ZYi2eV3C6x86poXAlMvGY-hARoJpgaaQq7ZDQkSHW4nkFp3vsnBoKVyITj6kPEQGqCZZGqtIOCR0ZYi2eV3C6x86poXAlMvGY-hCR-OXZ0ydTnPg5ogRLI1Vpl5AJHYUki7V4XsHpHjuntuxH4px4-k-X-BnEGPFYxFaEiHATA5eNx3Znk32FJXtPpfHywIR3je-aHLja8k5xroZuk5p7oKbl6r1Jz0bOh-Yylsk8ZB4Sv_BiqO1gpjt8nyXYLsvJzL1L-pItDd1O_p_J7obtLFPW9lD4b_khZy1-8ibY9wFRsbGz25CRxGaIZ0vhJu9dba55ZVMqTQXtpuKa5qs_T8oqx4fmQ17JJF8iF1ceopRk5HzFT7FBqONZWELHTNkkvyh-ijbBj8Q50l6xiknd1Xz7ufiNBPesp2kbk7Kt8dYzmhAHzQ_FVXK4mYG_1hftN3RPil8sEHkRoHUvSa_tevsTcb3EuLV69WKT0tndkBUshFAnq5wYaiDIj4qf4ocVICIzg-aKbL6GKqqqe8_Q8D9qj-7jbWNt-YUB6eFFs8NXTu0gX2YUHKn9wGT-0vRR7aFcUrWl7aj9bthJZUSJiGw9VPOuoaHBe2m80ONXeJYboZXNEmvsGUdr9aHS07axCF2jBEsjVWmnYmPf9olzDn93Mj-NZbJ2_OGk0fSl2fRB7cE8LckD-aesw7N0I1FENr1W65teDQbDl72TfvXwchOlJIu1WinU8SwsoWOmbMZOVIc4Em6kvTw5iS1odviWgPHuhl0ss9_YPzXvclz4v0p1DbYxcZUcWk9uXx4RYXPq7FPiBpTn49a31yy6OQ8lIqFOVjkx1EDEWpFXQvyLyJRdv4HV7v2wx3OR5Jrs-bBQk7SmyjrO_8vN3TtXkpyk3f1e50Op8iJ584G19rdaJqvE5JgT_lcgItG4kg6IV6sWaYKlkaq0U7GxT_s0199SmM5q9tV3_io7fdE1VxWfuzcnmCUVkcVe6CwdUUqyWKuVQh3PwhI6Zspm7ER1yCMZtVZtZpkDLY4Z8QuKUJEGEhQfllVEktgN9V1eo5f0aJdTRJaGGGogYicfKif-RUSo3zPr7DLFIO4xcKE4k_2NsZ_ICffIWp0nmr4P0zcNW1PYdTVW_sJ0USLCjV05sY51B0X-f9ylLyCCfKz9Pr8DN-5oN-j4PpgkVpP7Ss2X_ZI2OYe7Wqr3ZLBklXZTce3FPnG0SKiUM49_crHuVWE4KXVL6Z8twniTUKiEQssv5JCeePfzuybvdLxfViBsw2blv9lk-YmGKez4Up3566ZS_rKSv9As-7DTc2WplGBpFOz7gKjY2Kt9cj22HF_DpO5o_Jt3PUqgl3R5J6yP-NMNJyILTTLO-dD-WVWhEL2puQdOXux_KlacC04y_rdOl-dnCWtJojTRvYQgF5tkKuI5IoQ6noUldPg2QGjzXqg0Nh_dwneLHmzpuSqk1JmWsm1aUkZ-19z_jOMmb3cYyncIJZHNKChvvDwgprjf7v3_FL73JXaiOuSRPJ-w_Wm97-gMN2Wvz2EyS1oH-CilCSGUHSEHbq36qKmclgX5wm8g9wkB2b4EbrLvYo00IJ69p_qiuxz5i0jeW1WH1zA7Dd0TwgYC_LjMBt0fSjJlNXPwMGlRClBshbNI2_3Onw1iOSJl84xYjuQHLHzOOnXR2vg6n9ZC_Xmm84H73IKX_SXKhMGrAqWZkED2FT_FD_EvIs9uNeWlsGt1TVb5hA8ZdIgxsOnPOJoPsMzmauuouzAsuEfEOWKpXs-k5OmvT3CuiZunCzTs-mOXRvhDooNHafkVn1rs1y416rIZNvvIN8NkFTdq1-_WMjnFdV9Y7VfN-pJsZuPh1rt8Dw0tHsROXj7WbLnWZfm08uU0bf579jEXNznUa2nYwySlV5hudN8ddcqLNDfT90mhhuxVaWzvvGn72lixU-sO090ckp_7_JLNZmk-lk-2LG4dDBhvwQmWRqrSTsXGNCrE9inI9ZzAc0fzLsbdExa-R2QhScaN_VCfn8auLdGf_87eebG-KMczCLjAJJvsMxZp-d_6qMNmt7V_RPaSwlx8kqlKlAgQ6ngWltAK2wASjZq8Q--crCw6aRm2iymV-1rNqYriasvIdK9xbzqr2Vlp_Np2s7PDWJmvYbN1rQN8p4vf7iOBfyh2ojrMkQTo_Hhsq9nGJpe3DdPeYSEhPCJC4ip1y8ETdRWv6hq_sTTsJ3Vmpcn2o2PU6eUTArJ95-fuXtBtpIWly_5dax2p39j11VfG-Nwr39Hdy_KduXq1MElFCEkcl0muaPu6ztOfESrMoMXWfRbZe6o-7vApR_IDFoswm110ynSp0y4UYVZz-MIgf0Shyv6SZEJiWEGrAqWZkBA7-VA5K2COiGvM_h4__4NPpM2FR_XN5v_sH_VcMrr6jS_5d5mIcLN2fSaT8pKxz7VYESGZeKCtbDOrKWm5dZ2v1NaRnCVsTIt9_pneGaH14O636bJZ5lXTwOzzAdN-DW0I-TVi501yRQfZkRYJEtod2pHDTXe_n8ek7zfd5WsPr35-eZF-ZKnIYZPLLtx3V99zDlNxFrvuT7aJ57Q0rtKZeQcicL92lG1gk9-yqJypECyNVKWdio1pVND26fntloJUNu2kLeDdJ1O22rQksScsvIgsIMnGB0wHtUxBvf2xGIVCt8qqsnZeXxaWZGOWyuSkVaUXB8W5SnQkkV1f00kuDBefZOoL1PIS6ngWltBK24DMYpND3EJMqVLTAC0mrjHLW6sYIh733EFM3zPpVjHbam2PA-wehNiJ6nBHQruUZJInXK2J2ZhA40cmItqicwNec-mkoRl55SPg2Zf2smQfNt8Xk5B2VItpKt_RHebN23z2zmvqfUb34GWU6MLATXIMtGYOGWbwmlYsR1Ipk5cj2cmKnyUhE-f25lRaHs3Pz4Yq-0uQCedDVgVKMyEh1oq8ElaAiBBckwP_aaorE7tV-cXTX0ezYLCxedlaJSJCA_dexAs4gjgZRfh-6x8tYtvh6mnc7NUROjfUqmMzSk2OJ0J_zO6mHmm0lYqRkO9pNi00_UxDIbh6ml5k2aLWIfJNsFaN7P9CkrbU3W7xOIfNR7TMNr19XDjZ9OLWX9wr_SoRZZATFD95E-z7gKjYmEYFjWf5Z3_ka6mIBFpkmUFlkt3-G986eipKwnhXHbmUlNVoKpNMSPEsnVnWx8ENtpVmsS_ou2a5xScZOTXxU2wQ6ngWltDhyyaNNFm7S3f3dAkIiag50jbs-TFu2KzT0AsYv92DQH5R_BRtwh0JvUFGyuF0QujGY5b_ErMZjR-PiMjLgnIRcT5sr8wSPEBc5bWx_LMU5hOh4S809gvdDLwe8aNFc_wx0Jo5VJjBa9oZ4SzS9pl-ClCOZCcrfqYFVkDYUfhpasbByv4SZEJa-QerCvx2Dw75UfFT_LAyRETCNTn0N2vrn4VbecVOOdqLG6xHZMp2Ml3Mu0pEJNCk6A-sQ-6MT67U-o37ySnILiBcI-1HtczW2gCTsmnn836D5Ua3BN-BL_TQCNnU25-EY6DZOpiIeH0vIpUlT6ESke2ohmBppCrtVGxMSyw9cVef8TcptJEW18oRPMyrRyTAXTOGD62DnhRTlWR0mG93g0VMLcINoadaqDoXkmQz3tU6xZMui08yVYkSAUIdz8ISOnzZ9Is0-kO07eGRJZOEZxulcR47UR3-SOb-YdyZKraC3H9ZKjfSTlNxrSx-_HKgchGR4Rx1dNut7Sb9gSz3xvIdPWEKN_XQClnQI2FYxO8YBHzDnA1e0_qfhezX5Qfsd_CeHUOX_SXIhD4RS5H28pkIGIpYK_JKiHcRcU06vv_qqx9-pn1xEnSMg_pjhOaICDjvXSglDpQkGxwJmL0oNEw_g6bNlZBNVbZqCSAiSzlHREBVktEwAyzCxgtJMoiIjIUldPiy6Rdpvm2ALJkkPNsojfPYiWoFR0KrPj56hbbf-75ZWfz45UCf0hEybmUz8fklIy-ffx4M3Vi-oyxM2gfAV9djtpqtdBqH1zEEDTNgURIJVY68DtgnY8h2DF32lyATBqx2pL0gIpFFZSTS4iQf3aDIE1WYh8UUNvW4J2OPXTPqP786MMGJd83QSwG6izyzygmbzwhzw-3HspmsV44f3aNxT0cVuz29PJ0b7f3OesMxep-fzxFsFFzIpto_tI-I_xPp4vv5xW8Ct2oBh2aE_knP0EyQ0qiGYGmkKu1UbExLrNhOuMasNfwM04abdJKYDHV3zQioTLI7_1GZnJReY_O7_0pgQUkWqD_2lwtF6bKhmUUlWazVSqGOZ2EJvQRtQKChmaHWYrEnVWmcx05UKzkSbrC1RJO6q_kf_8WPhuwydAtSR5HFj18ODCcidPoOvy-dVLHxUMNFa5djlO9ulG8s_ywP89lg62EtMaS_XdFvyKJ38ciOIUSYz4LXtHSOSJByJM8MvhlD9tPCBI6gZX8JMmHAoRmpKvDbPTixVuSVEO8iws3dadmnSVpV9OHNEc_YCzfZ83GROEOT32ag9fBa1v0QJG62x_hbItSa7a_96_YlfI4IN3Lpj-tY7c4zPdNPexr3ad1zDrhh8-FkaV43YW7YXL6Kf4bgiPBBqk8JtPLdWN7-gDRBfDb1TJtyTdjfzZPurwsmIgEmqwoPYxAmwC6-VaMESyNVaadiYxoV0gUrnX6r-e3JK9JtdYSFPEdEdZJdv8VPf5Pu-CXQvreMyg4ShwtLMv8ZajRLC5PgFp9ksVYrhTqehSX0ErQB_pNVpxzNJVpmQ3n7r5ziOI-dqFZ0JHSaZ0Gt4Y-bvac-eMWPXw70EZHpfmOh7FKQTtCm-wrpIutn4iZvvJ8frkeEbMYbUub-gwdy3LeryI4hVJjBa9onocqRPDP4ZgzZT9Opr8HK_hJkwkCTVT1VgdJMSIi1Iq-E-J8jwj3paTrA3xquyX3l-ClDQ0NDzZuFfGed-z5Yntlh67uFvHzkHaoRnqzK3_QldKwlH_7szriQ7LQwpOQe_DevET7xuXg0nwV8cJ4w54AbsdXms0z-SRs_h5ob-_5kbgqbe0p4dOa40MjRe3SvW8_XFa9NoXcGcpM_ntmbzmYUVn_8te2mXVhFhIm_4VPMpvyNZHWtV36gt3Jpd57unhCKgTDepM2vam79rn-SXCBKeTTw7bs6Uz8Rk1ClUQ3B0khV2qnYmEaFp_YJ8MDNk3_gn5ui9MmqDf9uHZolGqI-yeiz8tis3VUft3d2i3cPpu3Q_8DXfQtMsoD37JWZ7vCV8uKTTBbPrjHbad3BIwab1GUzYms44vWA1zGbofS1RT9lMhSh0n1hCR22bCppA2YC3b5bes7Bj_kqjXNV-X9ZUXYk9JYQkmNTC4z_cFeVArL48cuBtL8wbUfVxxcs_ZPibSwkz9ebO3-wnn9XfIYHv-8_-4y_53svDF_Zbt6wtTfXHsjhVzG6C0Pk1-Sx6i031JDIlu5537JjCB1m0Jo2VDmSZwa_jCHbMWTZX5JMGKoqUJoJCd6pH7aM-1cLUWBFTFYVHgJTuXez8KQavlzlHqj5zC7rZuXxf9dMVVPzn_mU1uQd_vwf02JhoGvlC82FNJ_5rBKXrIYbY_y1r_QUCgLt83ffmut81H3upPi-DE2erqHD4X4Cj9djlIhLvXO2iz7-lWbT355oEp-Olb2nyr2KwD3ta3lDcKldTT2PvPOozwPNyt9vvy17oFmQ0qgGcqjiJ2-CfR8QFRvTqJBdBhEW964ZUuWNC90VC0gyefQKv9tiJxdj_JoFJ5nvU4xOd4hyvARJRsIUP4k5XB6a32Wcgm6kRSI7Hj8WltBhyiYJTEkb4F0SMwrKDVKKK41zsqP4KdooPBLxce-ag7KbUARk8eOXA0lE9X5WupGPpRcbe0kMcU_7L4olRbvpVf1X3zb_a6YYtzM_dYhlgSbclVvm4-7bc-Sx6i0i4oC75_4Xr2MIFSbZNHCxDVWO5JnBL2N47xi87C9RJgxeFSjNhASyr_iJJ2wZ968WosCKEJFFIFRz-nrLA5qbYoiA2TQ2CJZGqtIuwgkdCWIyyWItnldguruJnVNbwZEMwhKPqZ_oIhK7QETiDoiIAlZwAY-dU1vBkQzCEo-pDxGJVSAicQdERAEruIDHzqmt4EgGYYnH1IeIANUESyNVaYeEjgyxFs8rON1j59RQuBKZeEx9iAhQTbA0UpV2SOjIEGvxvILTPXZODYUrkYnH1IeIANUESyNVaYeEjgyxFs8rON1j59RQuBKZeEz9WBQRLLG_iKnlTbDvAyIPDcuyLmKMxwY-x7bCFvEko43PUWFJtEXMB_FDzIkIiF_isQAAAACILhARsGRARAAAAKgFIgKWDIgIAAAAtUBEwJIBEQEAAKAWiAhYMiAiAAAA1AIRAUsGRAQAAIBaICJgyYCIAAAAUAtEBCwZEBEAAABqgYiAJQMiAgAAQC0QEbBkQEQAAACoBSIClgyICAAAALVARBYLaX2xYPFZxMwBAAAgHBCRxYJWB_iALAEAAMqBiCwWtDrAB2QJAABQDkRksaDVAT4gSwAAgHIgIosFrQ7wAVkCAACUAxFZLGh1gA_IEgAAoByIyGJBqwN8QJYAAADlQEQWS2y3Os-ePpnixM-JAOd8-vSf0T5hiAgAACgHIrJYFtHqOB-ay8jufktqbpH-qzvji21PZ-5d0pdsaeh28v9MdjdsZ5mytofCf0tDsOMXloPmh-JmEeOfA5feLc410BN2djdkMZmHzEPCqohCTl_8BAAAIBwQkcWyiFaHNuSp-VWftpnN7uV886nSLZokdl2NdcwlbrgwHpoPMUlZoojMOFqrD5Weti0yTC_o8afkHvw3Q0ODz_J-a8-kuFnEGGo7mMlmiCfscrQePXjEYBsRVkUUiAgAACgHIrJYFi0i_lftE72NhSyTpTMPLqpTxEtEloNgxx8tvEQkikBEAABAORCRxbIMIkKHFUSH8BtikA2yOLsNGUlZpy5aG1_nO1EYNiv_zTOdD9x7SQMlZOMnsqEZIYQX3jK1_1mXm8pvkFF44mLP8L3LjaV5Wn777EL9lWGn24Kcw10t1XsyWLKldlNx7cW-SXFNOBHhHlmr81gm74T1kbCHa8L-bh7Drq9sFwJ3Td7pMIi_mJp74OTF_qfugIP9Ij3yY80X9cWb-CPX5r7eaPmJXytEhXCyZOEPySfeuMnbHYbyHUKYbEZBeePlgUmhcyh4HC4Y8hPiJwAAAOGAiCyWRbQ6wRpy50h7xSomdVfz7ed8QxlGREjbmV10ynSp0275tPLlNFZz-MLgM25yqNfSsIdJSq8w3ei-O-qUzxGhn5PYtSX689_Zbeb6A1msJj3rhY3FdV9Y7d9_rS9axWSWtA7wrT83atfv1jI5wqqrZn1JNrPxcOvdOf5IwveIcCOX_riOZbe-2zXh4iZuvL8zjV1XbRkhx8A5B83la1nty8eaLde6LjUeWsuya491DM-F_EX3kWt2Vjb_tcv-1-aKnVrN7nr7KMef8LeG3WlsGjnhW47RWa94m-k17k3n9zJ-bbvZ2WGszNew2brWgTkuRBzyOy4IiAgAACgHIrJYllhEuMlBW3P5phRWU9JyZ4p8EV5EksvbSPvNQw0mp9LyiP_Pa2jGX0SyD5vvCx0N3JTtZDqTtKbS8ph2PIxbq1cnaf_QPjI__3zAtF-Tkqe_PkFX0U6O5IoOXibCiwhRgEFzRTaTvq_ZfstYpGW2_tEyLIT0pKuOHENhU8-EsNncsLl8FZO2z_STK9Qv0iMnofXTE56fvmnYmqL9nWmAKJv30Iws3lxjlrdWMUQ87glrCNP3TLpVzLZa2-MwcbggICIAAKAciMhiWbSI0NEE7yXj9_VWcXQgvIgUtQ7RNttn4zAi8qppYJZfI-6VXtz6ixgMDZa_7WXG0XyAZXY3eSaecrN2fabYTgc_fma7odu9y5zDVJwlfMmuP3ZphP6Gq6fpRZYtaHbwAsHDDbUWM9m_N936_0L9ou-Rz89P9TbuYhndhSGiEcFEZLyrbhurOdI27PYQEuiwWadJyqyzz4aOwwVBTlb8BAAAIBwQkcWyiFaHNuTSXSenqg7kahk2q_Dj3ml3qxigXfQTEdmNsmpEhH7m8f0JT7Cj1qrNLLPfYLnRLcGP-KS8ZOxz-R6_fPl365DkCtxc_8cFREQ0paaBGfG7kfYjmqT0Ghvf5-NF6F8UjtxrOio9Buo9wUQk0CRW6RxDx-GCgIgAAIByICKLZdEiImvzuCc9TQe0TNqOk1fFnoMA7WIkRURowj39HJ5FCNbv-AMzM9hatorfSzY4EvSOntC_CBEBAICVBkRksSyi1QnUkIsDGZvLzQO03fRrF8dsNVsjJSKPLBU5bNpJW-CnsyoSEW74mzfXsqsOVP4_u9PF6agEYRqKV48IN9J7-WqX4-_toX5ROHLN0Y4R6WkowtCM-E0wEQk0NMOPBMmGZiAiAAAQJSAii2WJRWSem7t3riQ5yX13ybyr3_gSk7Kt8ZZ4F4cwPTNSIkLnkEr33xJcY9aa9czG8vYHnBIR4YYtx7aymn1NPU-ne84UaNzTRLj7bbps-UPbuGHz4WQ2p-77u6F-kR65NM12npu4Xr81RVvcKjxxJZiI-E9WnXI0l2iZDeXtv3IQEQAAiCoQkcWy1CJCmOzjbzBh11dfGSPt65Rdv4Fl15bUm6_ar5xvEB-8oUBE6M0v-VXNrd_1T44vSETmuckfz-xNZzMKqz_-2nbTbj1fV7yW1ea_Z-cFgh5_4CerGj6wDj13jdlObWFSttR-z58IN2KrzWeZ_JM2oiIc9ZLsorrWK9e7rnyhL8ph15ZfGJgO-Yv0yKUbj7828rfvFr5_kw9enF-i2VXdfNHS_9TrpALevlt6zjHjvn0XIgIAAFECIrJYlkFE5uenf2zamcYyBfX2x9y8a7L_y1p-HmsSq8ktrvvS2qxTJCLc076WN7J5a9nV1PNoYSJC8HoUmCb3lXfOdj2kE1Hp8XumcXgtGQ3dY3x3hdS1Q-CEYRr6WJH5-dmR7i_E82JSt5QaOtyv1wn-i_TI99Y0nhQeaMZm7a7-zC6NuLgm-87qSPgMu7mxZ9b7pHwfaGbocMgeaAYRAQCAaAERWSxodSKIr0LFJsgSAACgHIjIYkGrE0EgIgAAsNKAiCwWtDoRBCICAAArDYjIYkGrA3xAlgAAAOVARBYLWh3gA7IEAAAoByKyWNDqAB-QJQAAQDkQkcWCVgf4gCwBAADKgYgsFrQ6wAdkCQAAUA5EZLFEu9XhZvo-KVytM92bdr8xzv-mkmDfK2c5bldZojA9TyQTno6_usjYNymuihIQEQAAUA5EZLFEudWZ628pzMpruEk0JOFFhDDe3bBLW9jimKPPaI0OEBEAAFAORGSxRLXVEV5Kl1zeRl9pCxGZn-cGW0s0m99sH4qiiUBEAABAORCRxRLNVmfuH8adqWuqrOPi_0pERGj-M06ar5zR5aaSg-dfvNL0_bDT3XBz4452g7hKk_tKzZf9_DtZqDTsrfmo3r0qT9co22t-9qH9bPXubO-9RPj3vDQc3qLh30Gj3VRce7Fvkt_PS0S4kat_yk9j177xWd9TfqVzuKuleo_wahjZLhTZb2UUnjj3YdULspfFcL92lG3Q_s408Jz-HwXIgYmfAAAAhAMislii2Oq4-o0vMTmVlkfi_8pFhDTha0v0pm9t9r82V-zUMpklrQNCQz8zaK7IZtLyKz612K9datRlM2z2kW-GOfde9KW4vnu5xuzv7dDQV-n-0GmuL16bkq1rHaDjI86BtrLN_Jtvm__aZe9oOriRZWiPhUdEuMnez0o3spoDZ3qe8Ptwo3b9bi2TU1z3hdV-1awvyWY2Hm69K3T7cHN3Wvbxv1Vv7rTbvmk8QsXI89Y650h7xSrmQItjRvwi4kBEAABAORCRxRK9Vmf2Z9OrLPOqaYC-mZagXESyD5vv0y4GbqS9PDlpVYVljPwzZddvYNn8M70zwkrufpsuW_iJx3QvXes9GrTXXs_vmn6X7n6nLsE1Zq1Zz2wob_-Vm-em7PU5TOqOxr9RL-CGzYeTk9hC08-i3JS1DQ5Yqrezmt-evPKABv58wLRfk5Knvz4hHuIja3Uem1zRwb_FV3jXv2c0yjVu--85XiIy_9zRvItJL279he4deSAiAACgHIjIYoleqzNmq9nKrn7bOi4NQigXEd2FIdqQe82xcPU0bmZSdzXfdoc4N9SqYzNKTY5RYS-Z9Mj2Ehr-lG2Nt56J64gj2fUvUE2Z6m3cxcr7J7hfLhRlZu3_3OGiR_LSawfztUxOufkX90HPOJoPsMzuph7p5heOhJdJ-36EkLWl5mHJMqZstWleIjI_bq1enZRZZ5cELcJARAAAQDkQkcUSvVZH0IuMhm6PdSgXEdk2HqVwjbQf1TJba218N4c3IfZ6Pm59ew2Ttqfh224P3xp2p7G_Mfa7hjv-kM2mnbRN-XdP0DD5iSMsw66vvjImbiL0eTD7DZYbYmAES8MeJuUlY5_rofkQk5QlP2nebNK9RMR7-mrkgYgAAIByICKLJZZERGj1g4mI5mjHiDTtNKBSOB-ay1hmu6Hb_zkcYfeiPuG98Mfmf5ASNMysYuO35qo8limotz8WVIRqk19o1D_8RYRuDxEBAID4BCKyWKLX6ox31W3zHpqh4yB-XRrCcAb7YmMvP4UjbN-G1-7caO931huOUTpHJOBerjHLW6sC96MQhO4Nrx4R52jPVWuXY9TpORLn_Yu65CTt3k_6-LkpjywVOUE6Uci53DTksF5DM8I3XtohDM2k19imxP8jDUQEAACUAxFZLNFrdYQJHF63hzyfsP1pPcNml5kHZTfWDrcfJ1_m1NmFhjmEiNCZpPJREuE5Jcx2vX1IzV7z3NiVE-tSssq-ecjREPJOWB-JK-kE2A31XVMTsjCnHM0lWiarxOSYE39Utos4-3VjefsDbv5JV912Nrnswn1x8ut09_t5jFf_Bzdg2sek7TP9JEVBhIGIAACAciAiiyWKrY4wS5TenOKG3ivLsFn5b9S-12BoOFV9MD-LSdLm6zv5W04IoURkfn68p3Gf-77Z69bzde4bcUPuxT3paTqgZbL3VH3cYbvRdeULfVEOq9ldbx_lD2z6x6adafzdwue_67J_11on3YvrFSY3cb1-awq79ljH8Bw3-eOZvenircI37cJhsNr89-xjLrKhc9BcvjYla2-t6coPtvaPKl9OI0kgExHaQ1No7BceNhsNICIAAKAciMhiiWarI9w3u6qsfUR27c9N3rvaXPPKJuHpGmTR5L7yztmuh9IdJKFFhPz7qPvcSXF3TZ6uocPheaBZ8L34x6CdLs_PEn40NfdAzWf2YfemnHPk5l9qinPpA81yDxvab_s_0IyEOGKpXu-etco_A81QvkN4oJnfKbgm7_yHvihXy6_adsR41vB7-WRVfjAouk95J8csfgIAABAOiMhiiWqr4_OId0DHifCIdwAAiBsgIoslyq2O10vvAF56BwAAcQZEZLFEu9XhZvo-KVytM92DinBz986VrC4y9vnffhxRICIAAKAciMhiQasDfECWAAAA5UBEFgtaHeADsgQAACgHIrJY0OoAH5AlAABAORCRxYJWB_iALAEAAMqBiCwWtDrAB2QJAABQDkRksaDVAT4gSwAAgHIgIouFtDpYsPgsYuYAAAAQDogIUMH09PQbr7_u0-jS5YMzHzx48GBLbq7P92QhX966dUsMAgAAAJABEQGqOf0__6eParSZzXQVcREfU_k__vf15Eu6FgAAAPABIgKUMj09fe3atXq9nujFf9vs6fkgX4pbCPj0mhT8nzu25ObS_hJxCwAAAMANRASE59atW8QkiE8Qw7h8-TJRDSoZ5BsfC6GQDaivkKXNbCYK8vnZs_sKC8lCPsBIAAAASEBEQFDkAkF84vHjx9L31EJCKwVxF7IZMRLx__l5h8MhFxopQAAAAAkLRAT4QvyAWAJxhWBDKrdu3QprIRTiMSQc8R8ZJATaZVJ1_Pi1a9emp_HGPgAASFAgIkCETgEhZkC7MULc50JWKe_MCDh2Q6G_SI2E_A2xJQAAgJUKRASIU0Ci2D_h0wcTwoEAAACsMCAiiQudAkLa_n2FhTEyY4McA6a1AgBAQgERSThIY99mNpOWnihIzDb2ckmSz5MFAACwwoCIJAp0QkbcDX_QYSNyzLjRBgAAViQQkZUPacvlE0Lj9BYVn2mtcXoWAAAAfICIrFhW5EM7pH4dYiSY1goAACsAiMhKI0Hme5LTlN9oQ6xLXAEAACCugIisEKanpxOzYabTWle8eAEAwEoFIhLf0KEK-eQJcUXiQRQE01oBACDugIjEKz63k2DypgSNGWJmJGYwrRUAAGIciEicIR-JwAM2QuDfVwQjAQCAGAQiEh_4zM3ETAjlEP-QRx1utAEAgJgCIhLT0Mt6JS-iA2EhMhf7j5QFAIBEAyISo0gTHfCi_CVHPrxFPmB4CwAAoghEJLagbSS5ZCdtJG79WG58JvwitgEAIPJARGICjBpEF2IkdFor-p8AACDCQESiCZ0CgnmUMQJm5AAAQORZYhEhNTiWlbSI6bpE-ASOBUuwRcwxAIAEYOlFRPwEwvHgwYMYn5Sw5KkZd9mDJFCMp9GKBNUIAAkFRAQEBSICogLyCQAJBUQEBAUiAqIC8gkACQVEBAQFIgKiAvIJAAlFwouIc-LpP13i53ji2dMnU5z4ebmAiICogHwCQEIRWRHhJgYuG4_tziabCUv2nkrj5YGJ5W5Q5Ti7G7KYzEPmIXI0MwN_rS_ab-ieFNcFZajtYKb7mH0WGlRkmbl3SV-ypaHbyf8z2d2wnWXK2h4K_y0p5ATFT0vEkgcYw0TCFCNFpM8lkfIJACCiIjIzaK7IZpK0m4qq6t4zNPyP2qP7cjVJ7NryCwORe36Uy9F69OARg22EOMlDcxnLbFcsIlsP1bxraGjwXhov9DwRt4oYD82HmKQsUURmHK3Vh0pP28aWvl8naiIinCC7rsbqc1LObkNGEnvQ_FD8Pygy3ZR_pinuo5IkQxbXXuybDN_SKnY-L1NUCT33wMuy6GYYImW9csjJip8AAAlABEVkyq7fwGr3ftgzKbUursmeDws1SWuqrOPiN5FErYhEoxkIiJeILCNL3h4oDVBsjFO21H4_JveDpRGRlNyD_-ZRybo_vrIplWU2Hm69O0d3Dopi51tMAtFz3_RarXSE0mL4snfyubhZxPA6l2W0XjkQEQASigiKiFCjZdbZZ8X_BbiBC8WZ7G-M_WLNxjkf2j-rKszi26HU3AMnL_Y_lVoibvJ2R8PhLRr-6lB2Fet3lSZvroTPmcfPtJRt0zJs1u-ae6-9JzRL_cJe9EKT3_iXnqZtTMq2xlvPaCAEwZxWlbWPcGFEhBu7cmId67mC5x536QtYZuux9vv8Dty4o92gyyWtXRKryX2l5st-ScWcw10t1XsyWO8zkg77k4t1r_KdRkzqltI_W4QxLKFZdR82f0hPvE_fNXmn4_2yAmEbNiv_zSbLTzRMYceX6sxfN5Xmafm1WTvKPuwc9koNH8hPiJ-WCKUBiiJCloJ6-2MpA3ilbEhCioj4vRvOef-iLjlJlgkXzeJFRME5RojFnMtCWfKMBwCIZSIoIs9uNeWlsGt1TdZ7wbrBubEf6vPT2LUl-vPf2Tsv1hfleAZunANtZZtZzc7K5r922TuaDm5kmc1vtg9xCkSEHJU297WaUxXF1Zbhm7RZ-mVyqMfSsJ8EUmmy_egYddLDy2vqfUYPjpuy1-cwG8rbf-XC94g4RyzV65mUPP31Cc41cfN0gYZdf-zSCB8SHZBKy6_41GK_dqlRl82w2Ue-GSaruFG7freWySmu-8Jqv2rWl2RL1-XSYb98rNlyrcvyaeXLadr89-xjLm5yqNfSsIdJSq8w3ei-O-qUnz430_dJoYbsVWls77xp-9pYsVPrDtNtMOTnPr9ks1maj-WTLYtbB4OkBWHJ2wOlAQqNX_rrR99cx2p3numZdh-if8rKGuwg8iH_HFBESLT9cqEoXUpf3ncN5TsEO2QzCsobLw-I4iiPauFzxknzlTOiYpItm74fdnLueKaLO8-EMU6PKPf_EkZEFmq9wRVfPAb11sv_1uny_CxhLfHaJrqXECTZUZ31yiEBip8AAAlAJOeIuMbs7-0Q-jNYzebCo_pm83_2j8rrptkB00Gt7CKY1rlCnwTVgtQdjX-boauGzYfJVWyh6WdOgYhoSk0DdD9aRcqbJWloZsbRfIBldjf10H9HrVWb2dVvW8efKxqaET2ppOXWdePedHZdtWVE2FjoVmHzz_TOCOfE3W_TZbPMq6aB2ecDpv0a6i78mnnukbU6j02u6CA7iodd0nJniq6b7n4_j0nfb7rLd817XaTKT_-RpSKHTS67cF882fk5h6k4i133J9vEc9qorNKZeQcicL92lG1gk9-yBO9mX_L2QGmA4gleH2w_ls2kFxp7pcTzTdklFBEaFTO9fPIR3zV-bbvZ2WGszNew2brWgTkSa34iQnIykWbTtzb7X5t558ssaR147muKnCLjdIvyyHAYESH7LMB6Qyq--xjUWe9kn7FIy__WRx02u639I7KXFCbNbKqsV86SZzwAQCwTSREhuCYH_tNUVyZebvJL9p7qi-JF2_PbLQWpsj4JwnhX3TahhZjobdzFMgdaHO4mlm88MrP2f-5wKRCRgmaHe2zdr1nyzBERzaDhJl-VjlurV0uTV6iI0AP2XjKkPmtu7t65EuJG_Pdb_2gRm3tXT-NmJnVX8233788NterYjFKT44m39xC4Wbs-k8mptDwSD5vXLHEdCajpRZYtah0i3wQTEbL_C0naUrdq8DiHzUe0zDa9fVw48fTi1l_cK_3izQ9yLuKnJUJpgNIJSnpHhcw_ZZdARMSJStrfmQaeu8Ysb61iiHjcc0fK9D2TbhWzrdb2OJCIZB8236fxyY20lycnraqwjJF_vBLIna9CGadHlOm-IUWEnIda6x0Prvh8BAnHoNJ6xyyV5HxLLw4S0-Kh-Z9dX9M5Ica5OuuVs-QZDwAQy0RYRCRck0N_s7b-WbiV1z1UIbT97O4GS7fEDWH0pNDYf7fjD9ls2klbgLsI_RpUpc2Vr4iIE1Y21HdNucatb69htuvt9I4YKiKB7pr5wDrkVgzSDvQbydEmaYvODYi1s2uk_aiW2Vpr45snb4QeF2a_wXJDPFcCf_WZ8pKxzyUcttSSCQjHQL0nWNvg3f5RpPOVt80CfvHmR_RFxK13q4rP3ZvjFKdssM80xeWTVd_THy8SxiO2v219yFHx1RxpG_bECTds1mno3CZ5jNHPugtD7hmu8uPxSgifnjaCn3HKRJnuSyLKf5GlrErrvf234IrvEo9BpfUKp5ClM8v6OLjBttIs9gV91ywdn1JnvXLIeYmfAAAJQMRExDXp-P6rr374mV6rSdCrQ9rVEbQKJq7Q72mGffGr45Q2V34iMj83bC5fxfvHbX6MgzcSerQKhmYIznsXSoVHpHgGR_x_QiJoLwtf6QuHLWt4CIkpIoQpR3OJltlcbh6g0bJoEfGJ8NTcA9Uf2x4IvyWLZAnPD8ljLGSu8zr-8MYpPwuxFAS4a8bwoXXQI72qrDeU4k_TI1eZ2WYCZWxPnCwgs8kh5yV-AgAkABETEf_rQoqsqRY6e9NrbLSD2BuhNvfqEXGO9ly1djm8x60Fpmy1aUqaqwCWIHSwsxv_ePzN1e4xGh4lIjI3zE9oyHrl-NE9Gncfz_xzoWfFq23gRnu_s95wjN7nXSdwH4942No_tI-I_4sXqeI3gduGgEMzwjWxZ2hGXduw5O2B0gC9TpDkHWHextpjHYPXPakZKmWDfaYpLo8EH5ZDRGjm8bEffuE38DsLUUTk3wRElfXSMAMswsbCMXhimwciAgCIHBETEW7uTss-TdKqog9vjngmqHKTPR8XibMpxSFt-WOsaH9JRmXHw2mhryLvhPWR2MjSjflOC3JpWChTHDrC7a7KQzVXgSpu7r8slRuFOlruTOFFhBu59EfxFo-nPY37yIUp7TAXJtWy66uvuJ-HIXW6jPie0bxrzFqzntlY3v6Ao4edXN42THv-XRP2d_OEuZD8xoHbBvKf_2TV_pbCdDodYQFtw5K3B0oD9DpBAjfdc4afknnk6BtBFZObsp1Md5_gQkUk0NDMUGuxeNu5PMb8Yk9-PF7HLyRKSOOU509RGuTfBECl9d75j-CKLx6DWusNNDQjzPn1DM2oy2xyICIAJBQRnCPCPelpOsDfy6fJfeX4KUNDQ0PNm4Vez5Ki0wbZrN1VH7d3dtu_a60ryWbSduh_4Fvx6R-bdorT_rvEVXRHekMNm11Ub-78wXr-XfHexcDNlbxZohV32o6qjy9Y-t3SQb9MYnd-3M_fKEGhIhLwyapChzk3YqvNZ5n8kzZ-8h839v3J3BQ295Tw3KdxwUvoHRPXrefritem0LswuMkfz5AL_YzC6o-_tt20C6tYereCeNj8SdW1XvmB3pKg3Xm6e0JQNKGnXZtf1dz6Xf_kuKyKD3z7rs7UT8QknkWEnBm9SVW4jqep6eoz_kZ-uzWJh12SZCxURPwnq9KBIXoX98JEhKpnSOOUa4cCEVFtvddvBVd894RZtdbrP1mVXmkIE2CXVERcY7bTOvFpyJQRW8MRr-eqjdkMpa_pGgJMxQIAxD6RnawqPHigcu9m4dECZEnNPVDzmV12-UlcxPM8Lv6JCzUt9ofums45cvMvNcXC1MIkbe5hQ_tt8WEM3NP-iyeF52OSXV7Vf_Vt879milV5KBGZ5yZ7PysV-j9ebOyVqugB0z6vGX-EoL3rZMlquDHGV9zSLZQEesHqvlHC-aj7nHh4rCZP19DhcD_QzOuRFcTP3jnb9VDoLqKH_dsTTeKjHbL3VLlXEbinfS1vZPO_vqup55F3Fe_zQLPy992xFN8iQk6a6h05LzE1n3TVkePPKdZf7CRi-h590p14ggsVEfcwkM_tu6XnHPzcJsUi4mWKz8Mbp1w7qIgEfLJqw79bh2aJhqi33pCKT49BtfUGvH23zHSHV_olFRH_VPProVRgbwCAmCWyIhIHCFfAmoOmAaUPX1oW_NunaBBTIuLuSPBECzfZd1EU09TcIv1XVz55LYB8yD8rEBEfO8woKDdI4qhYRLxMkR8PCWOc_iISeNlu6B4XuisWYL3BFZ8ewwKs1_eBZqc77ozTg1pSEQEArHAgIhKjXc0NhrqjezJSZJ3bUSLBRQREktjIbHKQTwBIKCAiEvQ2Sza76LTyZ1EvFxAREDEgIgCAqAIRAUGBiCQEEBEAQFSBiICgQERAVEA-ASChgIiAoEBEQFRAPgEgoYCIgKBAREBUQD4BIKGAiICgQERAVEA-ASChWHoRwbKSFjFdlwifwLFgCbaIOQYAkAAssYgAAAAAACgHIgIAAACAqAERAQAAAEDUgIgAAAAAIGpARAAAAAAQNSAiAAAAAIgaEBEAAAAARA2ICAAAAACiBkQEAAAAAFEDIgIAAACAKDE___8DtSdAwK0jfd0AAAAASUVORK5CYII"
                }
              },
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Typy generyczne",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/GenericDemo.java": {
                  "name": "src/GenericDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import jdk.nashorn.internal.runtime.regexp.joni.ast.StringNode;\n\nimport java.time.LocalDate;\n\nclass Node\u003cT\u003e {\n  T data;\n  Node next;\n\n  @Override\n  public String toString(){\n    return data.toString();\n  }\n}\n\n\nclass GenericDemo {\n\n  public static void main(String[] args) {\n    Node\u003cString\u003e stringNode \u003d new Node\u003c\u003e();\n    Node\u003cLocalDate\u003e dateNode \u003d new Node\u003c\u003e();\n\n    stringNode.data \u003d \"Obiekt typu generycznego\";\n    dateNode.data \u003d LocalDate.now();\n\n    stringNode.next \u003d dateNode;\n    while(stringNode !\u003d null){\n      System.out.println(stringNode);\n      stringNode \u003d stringNode.next;\n    }\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003ePodstawy typów generycznych\u003c/h1\u003e\n\u003cp\u003e\n  Dotąd tworzyliśmy zmienne, które umożliwiały przechowywanie wartości\n  zgodne ze swoim typem. Typ generyczny, to rodzaj zmiennej, a dokładniej parametru, która nie przechowuje wartości ale typ.\n\u003c/p\u003e\n\u003cp\u003e\n    W celu łatwiejszego zrozumienia typów generycznych przypomnijmy klasę węzła do\n    przetwarzania list jednokierunkowej. Węzeł przechowujący łańcuchy to klasa o poniższej definicji:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass Node{\n  String data;\n  Node next;\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Jeśli potrzebujemy węzła przechowującego daty, to musimy zdefiniować taką klasę:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass Node{\n  LoaclDate data;\n  Node next;\n}\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Obie klasy różnią się typem pola \u003csamp\u003edata\u003c/samp\u003e i widać, że tworzenie kolejnych\n    węzłów do przechowywania innych klas to zmiana typu tego pola.\n\u003c/p\u003e\n\u003cp\u003e\n    Można ułatwić sobie pracę, definiując klasę parametryczną, poprzez dodanie za nazwą klasy\n    listy parametrów, w których miejscu pojawią się konkretne typy:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass Node \u0026lt;T\u0026gt;{\n    T data;\n    Node next;\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Zdefiniona klasa daje możliwość teraz tworzenia węzłów z dowolnym typem pola \u003csamp\u003edata\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nNode \u0026lt;String\u0026gt; stringNode \u003d new Node\u003c\u003e();\nNode \u0026lt;LocalDate\u0026gt; dateNode \u003d new Node\u003c\u003e();\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    W miejscu typu generycznego mogą wystąpić wyłącznie typy złożone, klasy lub interfejsy.\n    Można też spotkać się z podawaniem typu generycznego na wiasach \u003c\u003e po nazwie klasy:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nNode \u0026lt;String\u0026gt; stringNode \u003d new Node\u0026lt;String\u0026gt;();\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Ten sposób jest poprawny, ale podanie drugi raz konkretnego typu jest zbędnę i nic\n    nie wnosi, dlatego rzadko jest stosowany.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 2",
              "stepic_id": 0,
              "task_files": {
                "src/GenericsMethodDemo.java": {
                  "name": "src/GenericsMethodDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.EmptyStackException;\n\nclass GStack\u003cT\u003e {\n  private class Node\u003cT\u003e {\n    T data;\n    Node next;\n\n    Node(T element){\n      this.data \u003d element;\n      this.next \u003d null;\n    }\n\n    @Override\n    public String toString(){\n      return data.toString();\n    }\n  }\n\n  private Node\u003cT\u003e stack;\n\n  public GStack(){\n    stack \u003d null;\n  }\n\n  public void push(T element){\n    Node\u003cT\u003e node \u003d new Node\u003c\u003e(element);\n    node.next \u003d stack;\n    stack \u003d node;\n  }\n\n  public T pop(){\n    if (stack \u003d\u003d null){\n      throw new EmptyStackException();\n    }\n    T element \u003d stack.data;\n    stack \u003d stack.next;\n    return element;\n  }\n\n  public boolean isEmpty(){\n    return stack \u003d\u003d null;\n  }\n}\nclass GenericsMethodDemo {\n  public static void main(String[] args) {\n    GStack\u003cString\u003e stack \u003d new GStack\u003c\u003e();\n    stack.push(\"ALA\");\n    stack.push(\"OLA\");\n    stack.push(\"ELA\");\n    while(!stack.isEmpty()){\n      System.out.println(stack.pop());\n    }\n\n    GStack\u003cInteger\u003e istack \u003d new GStack\u003c\u003e();\n    istack.push(10);\n    istack.push(12);\n    istack.push(14);\n    while(!istack.isEmpty()){\n      System.out.println(istack.pop());\n    }\n  }\n\n\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eMetody generyczne\u003c/h1\u003e\n\u003cp\u003e\nKolejną możliwością jest definiowanie metod generycznych, kóre mogą przyjmować parametry jaki i zwracać wartości typu\ngenerycznego. Tę możliwość wykorzystamy do stworzenia stosu generycznego, w którym umieścimy zdefiniowaną wcześniej\nklasę Node.\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass NodeStack \u0026lt;T\u0026gt; {\n  private class Node\u0026lt;T\u0026gt; {\n    T data;\n    Node next;\n\n    Node(T element){\n      this.data \u003d element;\n      this.next \u003d null;\n    }\n\n    @Override\n    public String toString(){\n      return data.toString();\n    }\n  }\n\n  private Node\u0026lt;T\u0026gt; stack;\n\n  public NodeStack(){\n    stack \u003d null;\n  }\n\n  public void push(T element){\n    Node\u0026lt;T\u0026gt; node \u003d new Node\u003c\u003e(element);\n    node.next \u003d stack;\n    stack \u003d node;\n  }\n\n  public T pop(){\n    if (stack \u003d\u003d null){\n      throw new EmptyStackException();\n    }\n    T element \u003d stack.data;\n    stack \u003d stack.next;\n    return element;\n  }\n\n  public boolean isEmpty(){\n    return stack \u003d\u003d null;\n  }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Wewnątrz sparametryzowanej klasy \u003csamp\u003eNodeStack\u003c/samp\u003e, możemy korzystać z typu generycznego\n  w każdej metodzie tej klasy. Metoda \u003csamp\u003epush(T element)\u003c/samp\u003e przyjmuje argument typu parametrycznego, a \u003csamp\u003eT pop()\u003c/samp\u003e zwraca wartość typu generycznego. Zrozumienie co zonac\n\u003c/p\u003e\n\u003cp\u003e\n  W chwili gdy utworzymy obiekt klasy generycznej, i w miejscu parametry T pojawi się konretny typ, zostanie on ustalony także dla parametrów i wartości zwracanej metod\n  generycznych. Na przykład dla węzła z typem \u003csamp\u003eString\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cprev\u003e\n  \u003ccode\u003e\n  NodeStack\u0026lt;String\u0026gt stringStack \u003d new NodeStack\u003c\u003e();\n  \u003c/code\u003e\n\u003c/prev\u003e\n\u003cp\u003e\n  pod typ generyczny \u003csamp\u003eT\u003c/samp\u003e zostanie podstawiony konkretny typ \u003csamp\u003eString\u003c/samp\u003e\n  a wtedy metoda \u003csamp\u003epush\u003c/samp\u003e będzie miała konkretną definicję:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n public void push(String element){\n    Node\u0026lt;String\u0026gt; node \u003d new Node\u003c\u003e(element);\n    node.next \u003d stack;\n    stack \u003d node;\n  }\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  W ciele metody mamy także tworzenie obiektu klasy generycznej więc, tam także\n  pojawi się konretny typ i zostanie utworzony obiekt klasy \u003csamp\u003eNode\u003c/samp\u003e dla typu \u003csamp\u003eString\u003c/samp\u003e.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 3",
              "stepic_id": 0,
              "task_files": {
                "src/GenericsInterfaceDemo.java": {
                  "name": "src/GenericsInterfaceDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "interface Comparable\u003cT\u003e{\n  int compareTo(T o);\n}\n\nclass Theme implements Comparable\u003cTheme\u003e{\n  String data;\n  public Theme(String data){\n    this.data \u003d data;\n  }\n\n  @Override\n  public int compareTo(Theme o) {\n    return data.length() \u003e o.data.length() ? 1 : data.length() \u003c o.data.length() ? -1 : 0;\n  }\n}\n\nclass Number implements Comparable\u003cNumber\u003e {\n  Integer data;\n\n  public Number(Integer data) {\n    this.data \u003d data;\n  }\n\n  @Override\n  public int compareTo(Number o) {\n    return data.intValue() \u003e o.data.intValue() ? 1 : data.intValue() \u003c o.data.intValue() ? -1 : 0;\n  }\n}\n\nclass GenericsInterfaceDemo{\n  public static void main(String[] args) {\n    Comparable str1 \u003d new Theme(\"ALA\");\n    Comparable str2 \u003d new Theme(\"ELA\");\n    Comparable n1 \u003d new Number(12);\n    Comparable n2 \u003d new Number(34);\n    System.out.println(str1.compareTo(str2));\n    System.out.println(n1.compareTo(n2));\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eInterfejsy generyczne\u003c/h1\u003e\n\u003cp\u003e\n    Duże możliwości oferują interfejsy generyczne. Typowym przykładem takiego interfejsu jest klasa porównująca.\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\ninterface Comparable\u0026lt;T\u0026gt;{\n    int compareTo(T o);\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Klasa może implementoować taki interfejs:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass Number implements Comparable\u0026lt;Number\u0026gt; {\n    private Integer data;\n\n    public Number(Integer data) {\n        this.data \u003d data;\n    }\n\n    @Override\n    public int compareTo(Number o) {\n        return data.intValue() \u003e o.data.intValue() ? 1 : data.intValue() \u003c o.data.intValue() ? -1 : 0;\n    }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Typowym protokołem porównania dwóch obiektów, jest zwracania wartości 1, jeśli obiekt wywołujący compareTo\n    jest większa od obiektu, który jest argumentem, wartości -1 jeśli jest mniejszy, a 0 gdy są oba równe.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 4",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Person {\n  String firstName;\n  String lastName;\n  public Person(String fName, String lName){\n    firstName \u003d fName;\n    lastName \u003d lName;\n  }\n\n  @Override\n  public String toString(){\n    return firstName+\" \"+lastName;\n  }\n}\n\nclass Team\u003cT extends Person\u003e{\n  Person[] staff;\n  int count \u003d 0;\n\n  public Team(int size){\n    staff \u003d new Person[size];\n  }\n\n  public void add(T member){\n    if (count \u003c staff.length) {\n      staff[count++] \u003d member;\n    }\n  }\n\n  @Override\n  public String toString(){\n    String result \u003d \"\";\n    for(Person m: staff){\n      result +\u003d m !\u003d null?m+\" \":\"\";\n    }\n    return result;\n  }\n\n  public T getMember(int i){\n    if (i \u003c staff.length)\n      return (T) staff[i];\n    else\n      return null;\n  }\n}\n\nclass Worker extends Person{\n  String rank;\n  double salary;\n\n  public Worker(String fName, String lName, String rank, double salary){\n    super(fName,lName);\n    this.rank \u003d rank;\n    this.salary \u003d salary;\n  }\n\n  @Override\n  public String toString(){\n    return super.toString()+\" \"+rank+\" \"+salary;\n  }\n}\n\nclass Task {\n  public static void main(String[] args) {\n    Team\u003cWorker\u003e smurfs \u003d new Team\u003c\u003e(4);\n    smurfs.add(new Worker(\"Ważniak\", \"Smurf\", \"mądrala\", 10.0));\n    smurfs.add(new Worker(\"Osiłek\", \"Smurf\", \"siłacz\", 100.0));\n    smurfs.add(new Worker(\"Papa\", \"Smurf\", \"szef\", 1000.0));\n    System.out.println(smurfs);\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eOgraniczenia typów\u003c/h1\u003e\n\u003cp\u003e\n  Klasy generyczne moga posiadać wiele parametrów, a parametry mogą mieć różne znaczenie. Aby łatwo je identyfikować\n  przyjęto konwencję ich oznaczania:\n  \u003cul\u003e\n  \u003cli\u003e\n    E – Element: element kolekcji (szeroko wykorzystywany w kolekcjach Javy, jak np. ArrayLis, Set)\n  \u003c/li\u003e\n  \u003cli\u003e\n    K – Key: klucz, wartość służaca do szybkiej identyfikacji wartości\n  \u003c/li\u003e\n  \u003cli\u003e\n    N – Number: liczba, czyli dowolny typ wartości numerycznej\n  \u003c/li\u003e\n  \u003cli\u003e\n    T – Type: typ parametryczny, gdy parametr klasy nie ma jakiegość szczególnego znaczenia\n  \u003c/li\u003e\n  \u003cli\u003e\n    V – Value: wartość, którą kojarzymy z kluczem\n  \u003c/li\u003e\n  \u003cli\u003e\n    S,U,V etc. – drugi, trzeci, czwarty typ parametryczny, wykorzystywane, gdy klasa ma więcej niż jeden parametr\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n  Przedstawiona konwencja służy do rozpoznawania znaczenia danego parametry generycznego, ale można także\n  wprowadzać ograniczenia. Ograniczenia mogą dotyczyć superklasy lub implementacji interfejsu typu generycznego:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass Team\u0026lt;T extends Person\u0026gt;{\n  Person[] staff;\n  int count \u003d 0;\n\n  public Team(int size){\n    staff \u003d new Person[size];\n  }\n\n  public void add(T member){\n    if (count \u003c staff.length) {\n      staff[count++] \u003d member;\n    }\n  }\n\n  @Override\n  public String toString(){\n    String result \u003d \"\";\n    for(Person m: staff){\n      result +\u003d m !\u003d null ? m + \" \" : \"\";\n    }\n    return result;\n  }\n\n  public T getMember(int i){\n    if (i \u003c staff.length)\n      return (T) staff[i];\n    else\n      return null;\n  }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Tylko klasa \u003csamp\u003ePerson\u003c/samp\u003e lub wyprowadzona z niej może zostać parametrem klasy \u003csamp\u003eTeam\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass Worker extends Person{\n  String rank;\n  double salary;\n\n  public Worker(String fName, String lName, String rank, double salary){\n    super(fName,lName);\n    this.rank \u003d rank;\n    this.salary \u003d salary;\n  }\n\n  @Override\n  public String toString(){\n    return super.toString()+\" \"+rank+\" \"+salary;\n  }\n}\n\n...\n\npublic static void main(String[] args) {\n    Team\u0026lt;Worker\u0026gt; smurfs \u003d new Team\u003c\u003e(4);\n    smurfs.add(new Worker(\"Ważniak\", \"Smurf\", \"mądrala\", 10.0));\n    smurfs.add(new Worker(\"Osiłek\", \"Smurf\", \"siłacz\", 100.0));\n    smurfs.add(new Worker(\"Papa\", \"Smurf\", \"szef\", 1000.0));\n    System.out.println(smurfs);\n  }\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Ograniczenie z jednej strony blokuje możliwość tworzenia klas \u003csamp\u003eTeam\u003c/samp\u003e dla dowolnego typu parametrycznego, z drugiej\n  daje pewność, że parametr klasy będzie zaopatrzony w odpowiednie metody i pola klasy ograniczającej. W naszym przykładzie wiemy, że każdy członek\n  klasy \u003csamp\u003eTeam\u003c/samp\u003e ma pola \u003csamp\u003efirstName\u003c/samp\u003e i \u003csamp\u003elastName\u003c/samp\u003e, bo takie pola ma klasa ograniczająca \u003csamp\u003ePerson\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n  Ograniczenia mogą dotyczyć także implementacji interfejsów. Ponieważ typ\n  parametryczny może jednocześnie dziedziczyć po jednej klasie i jednocześnie\n  impementować wiele interfejsów, ograniczenia należy łączyć operatorem \u003csamp\u003e\u0026\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass Team\u0026lt;T\u0026gt; extends Person \u0026 Comparable\u003e{\n\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 5",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\nimport java.time.Period;\n\nclass Person {\n  String name;\n  LocalDate birth;\n  public Person(String Name, LocalDate birth){\n    this.name \u003d name;\n    this.birth \u003d birth;\n  }\n\n  public int getAge(){\n    return (Period.between(LocalDate.now(), birth)).getYears();\n  }\n}\n\nclass Worker extends Person{\n  double salary;\n  public Worker(String name, LocalDate date, double salary){\n    super(name, date);\n    this.salary \u003d salary;\n  }\n}\n\nclass Duet\u003cT extends Person\u003e{\n  Person[] team \u003d new Person[2];\n  public Duet(T p1, T p2){\n    team[0] \u003d p1;\n    team[1] \u003d p2;\n  }\n\n  public boolean isOlder(Duet\u003c?\u003e t){\n    return team[0].getAge()+team[1].getAge() \u003e t.team[0].getAge()+t.team[1].getAge();\n  }\n}\n\nclass Task {\n  public static void main(String[] args) {\n    Duet\u003cPerson\u003e smurf \u003d new Duet\u003c\u003e(new Person(\"Ważniak\", LocalDate.of(2000,10,11)),\n                        new Person(\"Osiłek\", LocalDate.of(2001, 4, 23)));\n    Duet\u003cWorker\u003e muchomorki \u003d new Duet\u003c\u003e(new Worker(\"Turkuć\", LocalDate.of(2000,10,11), 11),\n          new Worker(\"Podjadek\", LocalDate.of(2002, 4, 23),234));\n  System.out.println(smurf.isOlder(muchomorki));\n  }\n\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eArgument wieloznaczny\u003c/h1\u003e\n\u003cp\u003e\nArgumentem metody może też być klasa generyczna. Jeśli rolą takiego argumentu jest tylko udostępnienie metody tej klasy, wtedy podanie konkretnego typu\n stanowi ograniczenie funkcjonalności.\n\u003c/p\u003e\n\u003cp\u003e\n    Problem zilustrujemy przykładem. Klasa generyczna \u003csamp\u003eDuet\u003c/samp\u003e posiada metodę testującą, czy suma wieku obu członków\n    jest większa od takiej samej sumy innego duetu.\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass Duet\u0026lt;T extends Person\u0026gt;{\n    Person[] team \u003d new Person[2];\n    public Duet(T p1, T p2){\n        team[0] \u003d p1;\n        team[1] \u003d p2;\n    }\n\n    public boolean isOlder(Duet\u0026lt;T\u0026gt; t){\n        return team[0].getAge()+team[1].getAge() \u003e t.team[0].getAge()+t.team[1].getAge();\n    }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Gdy utworzymy dwa duety na podstawie dwu różnych klas, to podczas wywoływania metody \u003csamp\u003eisOlder()\u003c/samp\u003e pojawi się problem:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nDuet\u0026lt;Person\u0026gt; smurfs \u003d   new Duet\u003c\u003e(new Person(\"Ważniak\", LocalDate.of(2000,10,11)),\n                        new Person(\"Osiłek\", LocalDate.of(2001, 4, 23)));\nDuet\u0026lt;Worker\u0026gt; muchomorki \u003d new Duet\u003c\u003e(new Worker(\"Turkuć\", LocalDate.of(2000,10,11), 11),\n                          new Worker(\"Podjadek\", LocalDate.of(2002, 4, 23),234));\nSystem.out.println(smurfs.isOlder(muchomorki));\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003csamp\u003e\n    Error:(43, 36) java: incompatible types: Duet\u0026lt;Worker\u0026gt; cannot be converted to Duet\u0026lt;Person\u0026gt\n\u003c/samp\u003e\n\u003cp\u003e\n  Komunikat wskazuje, że nie można skonwertować argumentu \u003csamp\u003emuchomorki\u003c/samp\u003e typu \u003csamp\u003eDuet\u0026lt;Worker\u0026gt;\u003c/samp\u003e do typu \u003csamp\u003eDuet\u0026lt;Person\u0026gt;\u003c/samp\u003e. Skąd ten komunikat?\n\u003c/p\u003e\n\u003cp\u003e\n    Przed kompilacją w obiekcie \u003csamp\u003esmurfs\u003c/samp\u003e, parametr \u003csamp\u003eT\u003c/samp\u003e klasy generycznej \u003csamp\u003eDuet\u003c/samp\u003e stała się konkretnym typem \u003csamp\u003ePerson\u003c/samp\u003e.\n    Metoda \u003csamp\u003eisOlder()\u003c/samp\u003e została skonkretyzowana do metody\n    o sygnaturze:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\npublic boolean isOlder(Duet\u0026lt;Person\u0026gt; t);\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    a my w kodzie w miejscu parametru \u003csamp\u003et\u003c/samp\u003e podaliśmy obiekt \u003csamp\u003emuchomorki\u003c/samp\u003e klasy\n    \u003csamp\u003eTeam\u0026lt;Worker\u0026gt;\u003c/samp\u003e?!! Stąd komunikat, że typ argumentu wywołania nie pasuje do\n    typu w sygnaturze metody.\n\u003c/p\u003e\n\u003cp\u003eW kodzie kłopotliwej metody korzystamy tylko z metod dostępnych w klasie bazowej parametru generycznego, czyli klasy \u003csamp\u003ePerson\u003c/samp\u003e, Dla działania metody nie jest istotne czy argumentem jest duet obiektów\n    typu \u003csamp\u003ePerson\u003c/samp\u003e lub \u003csamp\u003eWorker\u003c/samp\u003e. Żeby wskazać, że typ argumentu może być dowolny skorzystamy z argumentu wieloznacznego \u003csamp\u003e?\u003c/samp\u003e:\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass Duet\u0026lt;T extends Person\u0026gt;{\n    Person[] team \u003d new Person[2];\n    public Duet(T p1, T p2){\n        team[0] \u003d p1;\n        team[1] \u003d p2;\n    }\n\n    public boolean isOlder(Duet\u0026lt;?\u0026gt; t){\n        return team[0].getAge()+team[1].getAge() \u003e t.team[0].getAge()+t.team[1].getAge();\n    }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Ta zmiana powoduje, że przedstawiony przykład już działa poprawnie, a argumentem metody\n    może być dowolny obiekt klasy \u003csamp\u003eDuet\u003c/samp\u003e.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Podsumowanie",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "\nimport java.time.LocalDate;\nimport java.util.*;\n\nabstract class AbstractField\u003cT\u003e{\n  private String name;\n  private T type;\n  private boolean canRead;\n  private boolean canWrite;\n  private boolean visible;\n\n  public AbstractField(String name, T type){\n    this.type \u003d type;\n    this.name \u003d name;\n  }\n\n  public String getName(){\n    return name;\n  }\n\n  public T getType(){\n    return type;\n  }\n}\n\ninterface Enumerable{\n  Map\u003cString, AbstractField\u003e values();\n\n  default void addValue(AbstractField o){\n    values().put(o.getName(), o);\n  }\n\n  default AbstractField ofValue(String name){\n    if (values().containsKey(name)){\n      return values().get(name);\n    }\n    return null;\n  }\n\n  default void print(){\n    for(AbstractField f: values().values()){\n      System.out.println(f.getName() +\" \"+ f.getType());\n    }\n  }\n}\nclass CountryFields\u003cT\u003e extends AbstractField\u003cT\u003e implements  Enumerable{\n  static final CountryFields\u003cInteger\u003e ID \u003d new CountryFields\u003c\u003e(\"ID\", 0);\n  static final CountryFields\u003cString\u003e NAME \u003d new CountryFields\u003c\u003e(\"NAME\", \"\");\n  static final CountryFields\u003cEntity\u003e CAPITAL \u003d new CountryFields\u003cEntity\u003e(\"CAPITAL\", new Entity\u003cCityFields\u003e());\n\n  public CountryFields(String name, T type) {\n    super(name, type);\n    addValue(this);\n  }\n\n  @Override\n  public Map\u003cString, AbstractField\u003e values() {\n    return null;\n  }\n}\n\nclass CityFields\u003cT\u003e extends AbstractField\u003cT\u003e implements Enumerable{\n\n  static final CityFields\u003cInteger\u003e GEO_NAME_ID\u003d new CityFields(\"GEO_NAME_ID\",1);\n  static final CityFields\u003cString\u003e  NAME \u003d new CityFields(\"NAME\", \"none\");\n  static final CityFields\u003cString\u003e  ASCII_NAME \u003d new CityFields(\"ASCII_NAME\",\"none\");\n  static final CityFields\u003cString\u003e  ALTERNATIVE_NAME \u003d new CityFields(\"ALTERNATIVE_NAME\",\"none\");\n\n  static Map\u003cString, AbstractField\u003e values;\n\n  private CityFields(String name, T defaultValue){\n    super(name, defaultValue);\n    addValue(this);\n  }\n\n  public Map\u003cString, AbstractField\u003e values(){\n    if (values \u003d\u003d null){\n      values \u003d new HashMap\u003c\u003e();\n    }\n    return values;\n  }\n\n  static void printFields(){\n    for(AbstractField f: values.values()){\n      CityFields cf \u003d (CityFields) f;\n      System.out.println(cf.getName());\n    }\n  }\n\n  static public CityFields valueOf(String name){\n    return (CityFields) values.get(name);\n  }\n}\n\nclass Value\u003cT extends AbstractField, V\u003e {\n  private V value;\n  private T column;\n\n  public Value(V value, T field) throws Exception {\n    if (value \u003d\u003d null || isType(value, field) ) {\n      this.value \u003d value;\n      this.column \u003d field;\n    } else{\n      throw new Exception(\"Invalid type value\");\n    }\n  }\n\n  public V getValue(){\n    return value;\n  }\n\n  private boolean isType(V value, T field) throws Exception {\n    if (value \u003d\u003d null) {\n      throw new Exception(\"Value cannot be null\");\n    }\n    return field.getType().getClass().isInstance(value);\n  }\n\n  public T getField() {\n    return column;\n  }\n}\n\nclass Entity\u003cT extends AbstractField \u0026 Enumerable\u003e {\n  private Map\u003cString, Value\u003e values;\n  public Entity(){\n    values \u003d new HashMap\u003c\u003e();\n  }\n\n  public void setValue(Value\u003cT, ?\u003e value){\n    if (value !\u003d null)\n      values.put(value.getField().getName(), value);\n  }\n\n  public Object getValue(T field){\n    if (values.containsKey(field.getName()))\n      return values.get(field.getName()).getValue();\n    return null;\n  }\n\n  public void printValues(){\n    for (Value v: values.values()){\n      System.out.println(v.getValue());\n    }\n  }\n  @Override\n  public String toString(){\n    StringBuilder b \u003d new StringBuilder();\n    for (Value v: values.values()){\n      System.out.println(v.getValue());\n      b.append(v.getField().getName() + \": \" + v.getValue() +\", \");\n    }\n    return b.append(\"\\b\\b\").toString();\n  }\n\n  public String toStringValues(){\n    StringBuilder b \u003d new StringBuilder();\n    for (Value v: values.values()){\n      b.append(v.getField().getName()+\"\\t\");\n    }\n    return b.append(\"\\b\\b\").toString();\n  }\n}\n\n\nclass City{\n  int geoNameId;\n  String name;\n  String asciiName;\n  String alternateNames;\n  double latitutude;\n  double longitude;\n  String featureClass;\n  String featureCode;\n  String countryCode;\n  String cc2;\n  String admin1Code;\n  String admin2Code;\n  String admin3Code;\n  String admin4Code;\n  long population;\n  int elevation;\n  int dem;\n  String timeZone;\n  LocalDate modificationDate;\n\n  public City(String row){\n    String[] fields \u003d row.split(\"\\t\");\n  }\n}\n\npublic class Task {\n  public static void main(String[] args) throws Exception {\n    CityFields.printFields();\n    System.out.println(CityFields.valueOf(\"NAME\"));\n    Entity\u003cCityFields\u003e city \u003d new Entity\u003c\u003e();\n    city.setValue(new Value\u003cCityFields, String\u003e(\"WARSAW\", CityFields.NAME));\n    city.setValue(new Value\u003cCityFields, Integer\u003e(1, CityFields.GEO_NAME_ID));\n    System.out.println(city);\n    Entity\u003cCountryFields\u003e poland \u003d new Entity\u003c\u003e();\n    poland.setValue(new Value\u003c\u003e(\"POLAND\", CountryFields.NAME));\n    poland.setValue(new Value\u003c\u003e(1,CountryFields.ID));\n    //poland.setValue(new Value\u003cCountryFields, Entity\u003e(city, CountryFields.CAPITAL));\n    System.out.println(poland);\n\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003ePodsumowanie\u003c/h1\u003e\n\u003cul\u003e\n  \u003cli\u003e\n    Termin \"typy generyczne\" odnosi się do specjalnych klas, które służa do wygenerowania\n    konretnych klas.\n  \u003c/li\u003e\n  \u003cli\u003e\n    Typy generyczne to klasy lub interfejsy, które posiadają parametry.\n  \u003c/li\u003e\n  \u003cli\u003e\n    Parametry typów generycznych są typami złożonymi, czyli innymi klasami lub interfejsami.\n  \u003c/li\u003e\n  \u003cli\u003e\n    Parametry generyków podawane są w nawiasach \u003c\u003e np. \u003ccode\u003eclass Team\u0026lt;T\u0026gt;{}\u003c/code\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n   Typ generyczny jest tylko szablonem do tworzenia klas lub interfejsów. W chwili deklaracji obiektu typu generycznego np. \u003ccode\u003eTeam\u0026lt;Person\u0026gt; smurfs \u003d new Team\u003c\u003e();\u003c/code\u003e następuje podstawienie w miejscu  parametru T konkretnego typu i wygenerowanie właściwej klasy.\n  \u003c/li\u003e\n  \u003cli\u003e\n    Typy generyczne mogą posiadać metody z parametrami generycznymi jak i mogą zwracać typ\n    generyczny.\n  \u003c/li\u003e\n  \u003cli\u003e\n    Parametry typów generycznych mogą posiadać ograniczenia dotyczące klasy bazowej i/lub implementowanego interfejsu np.: \u003ccode\u003eclass Team\u0026lt;T extends Person \u0026 Comparable\u0026gt;{}\u003c/code\u003e oznacza, że w miejscu parametru \u003csamp\u003eT\u003c/samp\u003e można podać klasę wyprowadzoną z \u003csamp\u003ePerson\u003c/samp\u003e i implementującą interfejs \u003csamp\u003eComparable\u003c/samp\u003e.\n  \u003c/li\u003e\n  \u003cli\u003e\n    Argument wieloznaczny ? służy, do sygnalizowania, że argumentem być obiekt klasy generycznej, której parametr jest dowolnego typu np. w metodzie \u003ccode\u003eboolean isOlder(Team\u0026lt;?\u0026gt; team);\u003c/code\u003e argumentem  może być każdy obiekt typy generycznego \u003csamp\u003eTeam\u003c/samp\u003e, którego parametrem może być dowolna klasa.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Kolekcje",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/ListDemo.java": {
                  "name": "src/ListDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.ArrayList;\nimport java.util.Collection;\n\nclass ListDemo{\n  public static void main(String[] args) {\n    //Tworzymy kolekcję elementów typu String na podstawie klasy ArrayList\n    Collection\u003cString\u003e membersA \u003d new ArrayList\u003cString\u003e();\n    //dodajemy elementy do kolekcji\n    membersA.add(\"ELA\");\n    membersA.add(\"ALA\");\n    membersA.add(\"OLA\");\n    //rozmiar kolekcji\n    System.out.println(membersA.size());\n    //usuwamy wszystkie elementy z kolekcji\n    membersA.clear();\n    //rozmiar kolekcji\n    System.out.println(membersA.size());\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eWstęp\u003c/h1\u003e\n\u003cp\u003e\n    Przedstawione w bloku \"Java. Programowanie podstawowe\" przykłady struktur danych, były\n    bardzo prymitywne i mało elastyczne. W praktyce programiści wykorzystują gotowe implementacje\n    najbardziej znanych i popularnych struktur danych. Zgromadzone są one w bibliotece powszechnie nazywanej kolekcjami (ang. Collections). Na kolekcje składa się kilka interfejsów, które\n    stanowią poniższą hierarchię:\n\u003c/p\u003e\n\u003cimg src\u003d\"images\\collections.png\"\u003e\n\u003cp\u003e\n W tej części będziemy omawiać kolekcje typu:\n\u003c/p\u003e\n\u003cul\u003e\n    \u003cli\u003e\n        List - listy, które są sekwencyjną elementów, z których każdy ma swój numer - indeks,\n    \u003c/li\u003e\n    \u003cli\u003e\n        Set - zbiory, które zawierają elementy niepowtarzalne, a ich kolejność nie ma znaczenia.\n    \u003c/li\u003e\n    \u003cli\u003e\n        Map - mapy, które gromadzą elementy identyfikowane przez klucz\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n    Biblioteki posiadają także niezbędne metody do manipulowania strukturami, aby\n    w łatwiejszy sposób przetwarzać dane.\n\u003c/p\u003e\n\u003cp\u003e\n  Podstawą funkcjonowania wszystkich kolekcji (oprócz Map) jest wspólny interfejs generyczny Collections\u0026lt;E\u0026gt;, który posiada m.in. poniższe metody:\n\u003c/p\u003e\n\u003ctable border\u003d\"\" bgcolor\u003d\"#123456\" cellpadding\u003d\"4\" align\u003d\"center\"\u003e\n    \u003ctr\u003e\n        \u003ctd width\u003d\"40%\"\u003e\n            \u003ccode\u003eboolean add(E e)\u003c/code\u003e\n        \u003c/td\u003e\n        \u003ctd\u003e\n            Dodaje element typu E do kolekcji i zwraca true jeśli nastapiła zmiana kolekcji\n        \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n        \u003ctd\u003e\n            \u003ccode\u003eboolean addAll(Collection\u003c? extends E\u003e c)\u003c/code\u003e\n        \u003c/td\u003e\n        \u003ctd\u003e\n            Dodaje do kolekcji wszystkie elementy z innej kolekcji i zwraca true, jeśli\n            nastąpiła zmiana zawartości kolekcji\n        \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n        \u003ctd\u003e\n            \u003ccode\u003eboolean remove(Object o)\u003c/code\u003e\n        \u003c/td\u003e\n        \u003ctd\u003e\n            Usuwa element z kolekcji\n        \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n        \u003ctd\u003e\n            \u003ccode\u003eboolean removeAll(Collection\u003c?\u003e c)\u003c/code\u003e\n        \u003c/td\u003e\n        \u003ctd\u003e\n            Usuwa z kolekcji wszystkie elementy zawarte w kolekcji \u003csamp\u003ec\u003c/samp\u003e.\n        \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n        \u003ctd\u003e\n            \u003ccode\u003eboolean retainAll(Collection\u003c?\u003e c)\u003c/code\u003e\n        \u003c/td\u003e\n        \u003ctd\u003e\n            Usuwa z kolekcji wsystkie elemementy, które nie są zawarte w kolekcji \u003csamp\u003ec\u003c/samp\u003e\n        \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n        \u003ctd\u003e\n            \u003ccode\u003eboolean removeIf(Predicate\u003c? super E\u003e filter)\u003c/code\u003e\n        \u003c/td\u003e\n        \u003ctd\u003e\n            Usuwa elementy spełniające warunki zawarte w \u003csamp\u003efiler\u003c/samp\u003e\n        \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n        \u003ctd\u003e\n            \u003ccode\u003evoid clear()\u003c/code\u003e\n        \u003c/td\u003e\n        \u003ctd\u003e\n            Usuwa wszystkie elemnety kolekcji\n        \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n        \u003ctd\u003e\n            \u003ccode\u003eint size()\u003c/code\u003e\n        \u003c/td\u003e\n        \u003ctd\u003e\n            Zwraca liczbę elementów w kolekcji\n        \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n        \u003ctd\u003e\n            \u003ccode\u003eboolean isEmpty()()\u003c/code\u003e\n        \u003c/td\u003e\n        \u003ctd\u003e\n            Zwraca \u003csamp\u003etrue\u003c/samp\u003e jeśli kolekcja jesy pusta\n        \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n        \u003ctd\u003e\n            \u003ccode\u003eboolean contains(Object o)\u003c/code\u003e\n        \u003c/td\u003e\n        \u003ctd\u003e\n            Zwraca \u003csamp\u003etrue\u003c/samp\u003e jeśli w kolekcji znajduje się element \u003csamp\u003eo\u003c/samp\u003e\n        \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n        \u003ctd\u003e\n            \u003ccode\u003eboolean containsAll(Collection\u003c?\u003e c)\u003c/code\u003e\n        \u003c/td\u003e\n        \u003ctd\u003e\n            Zwraca \u003csamp\u003etrue\u003c/samp\u003e jeśli w kolekcji znajdują się elementy\n            zkolekcji \u003csamp\u003ec\u003c/samp\u003e\n        \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n        \u003ctd\u003e\n            \u003ccode\u003eIterator\u003cE\u003e iterator()\u003c/code\u003e\n        \u003c/td\u003e\n        \u003ctd\u003e\n            Zwraca obiekt iteratora.\n        \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n        \u003ctd\u003e\n            \u003ccode\u003eObject[] toArray()\u003c/code\u003e\n        \u003c/td\u003e\n        \u003ctd\u003e\n            Zwraca tablicę zawierająca wszystkie elementy kolekcji\n        \u003c/td\u003e\n    \u003c/tr\u003e\n\u003c/table\u003e\n\u003cp\u003e\n    Kolejne interfejsy jak List, Set lub Queue wzbogacają listę metod, które\n    zapewniają funkcjonowanie konkretnych struktur. Jednak korzystając tylko\n    z metod tego podstawowego interfejsu możemy już tworzyć proste strktury jak\n    odpowiednik tablicy jednowymiarowej. Aby to zrobić musimy sięgnąć do klas kolekcji, które\n    implementują strukturę kolekcji. Dzięki znajomości tylko metod interfejsu możemy\n    w jednolity sposób odwoływać się do różnych implementacji kolekcji.\n\u003c/p\u003e\n\u003cp\u003e\n    Podstawowe dwie klasy kolekcji do tworzenia list są \u003csamp\u003eArrayList i \u003csamp\u003eLinkedList\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\npublic static void main(String[] args) {\n    //Tworzymy kolekcję elementów typu String na podstawie klasy ArrayList\n    Collection\u0026lt;String\u0026gt; membersA \u003d new ArrayList\u0026lt;String\u0026gt;();\n    //dodajemy elementy do kolekcji\n    membersA.add(\"ELA\");\n    membersA.add(\"ALA\");\n    membersA.add(\"OLA\");\n    //rozmiar kolekcji\n    System.out.println(membersA.size());\n    //usuwamy wszystkie elementy z kolekcji\n    membersA.clear();\n    //rozmiar kolekcji\n    System.out.println(membersA.size());\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Program w przykładzie będzie działać tak samo gdy zmienimy rodzaj implementacji kolekcji na \u003csamp\u003eLinkedList\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nCollection\u0026lt;String\u0026gt; membersA \u003d new LinkedList\u0026lt;String\u0026gt;();\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {
                "images/collections.png": {
                  "is_visible": true,
                  "text": "iVBORw0KGgoAAAANSUhEUgAAA8wAAAJgCAIAAADQ430YAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAP-lSURBVHhe7J13nFVFtv1FUFQkSc4gMGQEQZI-chBBjJhQgREBBxHUUZKAStIBZAAByUlkAAUkDHGUGQREJAw5Ss6IYnbm_d78vn1Xu995t2nsbvrafem9_jifOnUq7Kpae9eqc2_fvuo_8eDnn3_-97___a9__eu7777j9o033hgyZMgoR1Thz3_-84ABA8aOHTthwoRx48ZNnjyZpfzv__5vra8SXFloEo7Lwd_-9rc__elPEydOZLbHjBkzfvx495dUi2HDhuEOLBYOgmu89dZbrBc5gwcPZilxDa0pie-__15pxyVw_vx5JdasWcP0jh49mollPjXbjmjBiBEjWLupU6eylNr3HZcJ7a3_8z__o1vATtG1a9dXXnmlW7duL730UseOHXv16vXiiy927979j45Uieeff_6FF1549tlne_fu_cwzz7z--ut_-MMf2Br-3__7fyxocHFRU2jm2JtfcHGRHawGjhw5UqxYsSZNmtRxRBWaN29-xx13kKhXr17FihVr16597tw5rakUNoAoLrIvH3369ClVqlTDhg1r1qxZuXJlJrxx48ZaBUdqg5yifv36tWrVIqzhF__1X_-VJ0-e1q1bK27KI_SWIbS8jl8HsaV9-_YlS5ZkSm-__XYcQbPtiBa0aNGievXq7Brffvtt7KI6Lg9xRfbKlStz5cr1-9__HqHG9f7772_Tpg2R5_HHH3_SkSqBwmaxWrZs2apVq0cffZTrzTffvHfv3p9--on9gj1CuwYgYWlDvG-yIccPP_zwzTffkOZaoUKFDz74QE04ogVaSkhw4cKFkSNHPvjgg6SR1_ZICLt1JAGvvPIKCoN5Jv3zzz__-OOP3333XWgRHKkO7Hn6JMdeWn___fdTp05FZ2hT5BHQo7A3Do64sGn84x__yG5kEi12uh1RArzgzTffREbobIkvENDI12o6kgDFk-Acrlixgjhz7NgxIgwqjRlWGUe04OOPPy5evPjRo0dDThMupeLuF_GKbEHRE5FdoECBjz76SJmO6IIWcfTo0fg2jg0Jwj4EJyeMK47Eol27dvfcc48OpaY5HKkW0tBGexKDBw9u0KCB8oPbnr_MTjiefPJJJBqzBzhnxuY6ogcDBgxo2LChNgidRZXvSBoUSYLb6_LlywsXLhz8No7KOFItCGXBz3Y2b96cP3_-w4cPkw57F3NRHXVxkY2PBRvlvFWwYMGlS5fG3juiCj_88APX8ePH165dGxKA06dP65HBuOJIAoiSf_jDH5566qnY-5DL-ZRGBWyZRowYcdddd-Ea586dO3v2rDLBReOmIwzaY55--ukOHTro1vkfdWDV-vXrV79-_fPnzxPTtHE4LgdxRfayZcuQaEgsTu_K_-abb0j4eSY1Q8dOlgyn2LJlS5EiRf75z3-eOXPm2LFjKnCJ5fuVN9mAIxftlipVatWqVVDBEUVg4aCFzktvv_126dKlP_nkkyVLluzbt0-bop2h_TB9OWCSX3755Xbt2pHGG20yY5fBkcpgC4QX_PTTT4qPOEjdunXXr1-Pj2zfvt01YhLw7LPPdunSJfbG-R9tYMkGDx5cs2bNdevW_eMf_0BMKNORZCjUKJgQbQD7b9myZYk5cedWBRypDSyWPqMWkE8lS5ZcuHDh2rVr__73v3_99demsi6Ki4tsqkELq4ZWu_nmm_3rItELlMSoUaNuu-22NWvWEEA3bdoELci3j3R160gacMK-ffu2b9-etG9L0QJbKSUQ2VWrVv3b3_62bNmyzz__HJfRU8evgs2CAMI-9Mwzz3Tu3NnPJ1EK9ARe0Lhx482bN7Pdb9iwgRx__3I5CIps4gxAZN96663acBVkKKPXYaQdqRkS3Bs3bixUqNCsWbOWL1_-17_-Vfpbr7oviku9yT579iyNkjh37lzevHmR7dw6ogj2xS_ceNy4cbfffju0-Mc__sFSSl4bM9zDLwfEUET2Y489xjzrtShBk8zYZXCkMmjV7CUCK8V6DRw4EJHNKfSTTz7ZunWr9j82RS2o41dBSHn22WfR2efPn2eS8QXNtiNaAOeHDh36X__1X59--inqYd26dbFL60gq4opsJrZo0aL6mS_0mQo4UjO0RniHEhw-0cPvv_8-OmrVqlWhIrFLTIG4b2fiFdmwITYVerH9u9_97m9_-1vsfXJAEoQEoTloFv0GBR-3sj6lgJFmqsFu2Zs1UanfVd55553bbrvt448__vvf_070lMEaSHCtHUnDH__4x9___veaybiESRaYXxCaI9F-YhG0IUghndzk1PZRSaqCWY4XKM31z3_-M6dQohwO8vnnn5OpQbl3_CpsPv8QgtJBeiQXaNOaTYWHH6MKtslONgjlRAv-9Kc_IbLxAo6an332GTnO_-SCAjgiGzVFYBRDPMhEBVggW6N__vOfN99881_-8pePPvroH__4h-3LKmDFDCkmsuMiGDTp3eJUKoHOKEyoZua7774jbRZ---23qVNPGFxkRxQRFdlyDa7BA2cK7t8EhNhUCMHBMgNffvkldkpkpyoXNphVLrKTBTafkRPZRNdggGXhFMFSG-ShjF3WskcEfTb1w0V25OAiO3rBAtkaRZPIxriwL7Loj8Ygn_gnBH_sJkUQNMYgkR13QlMtXGRHFJF-k41rnDt3Ti2nHv3KVkFwwBc4AISJHjJTLa9s6hRtlOMiO8mw-YyQyD5z5kxs6j__uXDhAtRKncoVJ7XfpTHa2B4cFXCRHTm4yI5esEC2RtEhsrUfoxX0No6-4kYiKEgxENfo3wy_uk9Q4KuvvtJwUjlcZEcUkRbZcR0kZTdvxojzYkPYSO2WXSTV-oUZiYVKc3WRnWTYfEZIZAssVspyPoGAMJw52d2ikTkusiMHsddFdjSCBbI1ig6RHaZCvvvuO_2Fpl4PKxPQrz4oTynIKoGg-e2338ps0rY9k9AtbhMqmErhIjuiiKjIhmBKQMiTJ0-qF8tMEWCJ-abssbFDLa6hJzEI-7QqNcBWx7yYq4vsJMPmM3IiG7Yb386FoHSqgoZsf6gDUvPnOReFi-zIwUV29IIFsjWKmq-LSOQB9uO4Zhl4lLzBOgkIM8BuCfTmJ8GzQeqEi-yIIqIiO-4CXeJXOX8bmMS3EzIIk904Reqklq2Oi-xkgc1nhER2dP35INulDpnMQDJOwm8DF9mRg4vs6AULZGsUNSKbTRqSscnRuHLQrKa82bntBVjwrdhvDLrGJCFmjkMg0_5jomxDW6T-bcBFdkQRUZEttQrHzp8_r5wLFy4okVKwAYpI4OzZs_ZhjuxkHnDk5J2KZEHQeKW5ushOMmw-IySyAVyC_8D4ljrB6decVLtvKjc4DC6yIwcX2dELFsjWKPreZEtMw7nRo0eXLVt24sSJUq62Pcc1-jeDTR-z-dBDD2XNmvXaa6_Nnz9_27Zt9bc4KfuRfaLgIjui-A3eZM-bN69GjRpdu3ZNDZ-Va4A4iIi0devW9u3b58qVK3v27NmyZatXr97-_ftDBWMPoqkKtjoYrzRXF9lJhs1n5ES2fXQzY8YM2PXyyy-nQl5t2bKFrYENAi-4-uqrH3jggSNHjsQ-ixK4yI4cXGRHL1ggW6NUJ7K1B5sd9sfXkqc_hF4Af_XVV0jtLl26EJgGDhyoKnorRsWff_45-G5AhqkMMDu_-eYbBWLaVF2VsehM3WBc5paSyoHuJpephTF6lU4m7R86dChnzpxFihQZP3480zpnzpzBgwdbeQ1NmptaXIMmYTzQLVapsKAWuMpOapHAEvpVMRlsVeK-vLSWEwIX2RFFEkS2CkMAMUFVtOh4REyJX14JC9OmTUufPn39-vVj70NQAclupcUiErBRXegcC3hEzpdffkmaXsgX_4NQ11CLRvQ9EJWxT5x4pGbt6fHjx6tWrZoxY0b8AnmKm4waNero0aPiGJABFNMtkKcANRX8-Qgg_8XvuFKAOVGgMGvFfF1VWAUAncrlrYu4sNWxueLqIjvJsPlMoMjWI1bTgpugBbUzpG6BLQEVhwwZkjdv3mbNmikH5lgxUVSNq2UoqluuyhEVlTaGqAXcUFwCqiXY55bg1KlTXFVRNOMqnpNZvHhxtolhw4atXLlyypQp_fr1s90HMApZaN7NDJjxasQYro4E1eKRrLI9FGg45OtRcD6T9mGXi-zIQauTNJEtelhhhXqjq6AYiPtARXoB3AY3F6Wtr-DLGhVQs-KkGrewr1uKGWMBrmGjMC-AqEpb16oirnLl6dixYzknv_rqq2PGjCFTtFfvqmVD062ZSkfkBN1Kzoin27jwLzVo3iQjBfUSBH3J4EuAxq391CiytfYk1KY21OACCxz60a_bt28PzgjjD94CFox21JQe0T76Y_369aQ1-1pUBSOVYYPHANWljEwiHYxEZCo_CGrNnj37qquuYutVjoIdXDEehIGntBxsSiW1kDJDaZWxRSIRDKAqQ13riK4po1FYTlybLwoX2RFFYkU2JRU-BHjIslpOWHUIwNPDhw8TNzds2EAOJVlBGlGP4OTJk1wlfCkszliInDBhAs6ltEB19UJheYGqqEFrNkhICiiiWfAinNEIPouDoH7Ixy9oUE-FoAyiWdFVARdwa_ynKdHSEAyIakQVT5w4wVUGY5JqMXa5_69OvhWwSeDqIjvJsPlMoMgOrrgSQJRWWrsD3KCAkY1bVn_37t1Lly6VFwBVgfxivqlqYDux0W_evHnz589XGpgZQEqaHGARNbg7cGhUfrCWgS4Q1tdffz3nzNis__zn2LFjsakQgn6hpszjOPfaUx5ZHAgOB5g6BxovhcVhZol2VJjNLhhbEgUX2ZGDmEMMT4LIhiEihiIwUHWLtxDAHsGTa6-9lphs0ZuNQIShjFinW9KiCupLrhSU73pEXYvD5NAdA6G6ccwsUQvyOzFcgRpQRuVxkxtDaNy48R133FGiRInRo0erDLapllyeXqwLbBDVSYvqyg9TzLRgXq8EbqtbgDtr-2AIGogsB_RlFS8KerROU5fItimQHTYqHdNNZ1sYtTEHx8-8sOSaHcBcMx08xUJVhH_Zs2e_9957SZNJ3VDBGFBMdBFszfQyT6BlEc5CmFrQunIdMWJEhgwZDhw4QFolgY1ICw9YYLWgHs0MCgSDo9JYgvFWF1hAV0WrojMJbVqDDIqKdmszc2m4yI4oEiWyYZGiCSAMBWkA5O1qAZ5YU1ACGtC4gimJoAgQrCm5BoAeWFWxYsXChQsbZ8R_bm3p6UgyHQQjjsZy6NAhrkZdrtYR6mThwoUE9BkzZlinlKFxrA1qdAPF1K9UCE0F6S3IGHlZMJIydSopAywom7_Is5SODzalNKI0VxfZSYbNZwJFtigkML2AhTaP0O6gRdRaiwaAklprEjBBkTa4O8JGChMzrYoSlOdarly5kiVLkqCi6gZfGIPgrWS3KgryOyra0ERyWIQNy5YtwwumT59OvtioIVCARoAsMdlhULPAZgAgelRdV9uwKGOMVY4sDBsIM2wzkCi4yI4ctCJJE9nBXR7m2-orH77JUwiVsBG21K9fv2HDhmwQMJPyipaHDx_mqroWb7FEVAeQTd4k0pKgbuhJjBxSwrqmU20upMVSEGSdGoGZlBS3eVq5cuWrr75aDsJTiKoGw06kBp6qsGDOwgZhm4viCTbYoGw-laARDSRsd-CpZgZYyxcFJdUUSKXfyWbwmggSZhMrROaECRPQx-3bt3_ooYeefPJJvaJgIjT4vXv3ErXXrl27adOmDh065MyZs1OnTtu3bw81EHNMeeWVV4gLnNvKli1LU_369RszZsy8efPUizodPnz4fffdV6xYMbpgKyWHSdcjrs8888x7773Hmr388stFixYtX7589-7dxQl0w4ABAzhvZc6cuUePHrRPDKUL-4f19IXldH3LLbc0atRo5syZZJoGAoTUyZMnM8BKlSoVKlQIHfb---_zVGxgkqdMmYI_FC9evG3btosWLZK3AFt7jiIUM2Zbgl40hATCRXZEkSiRHZxwW2jto4px9lVOmDB79my40SaEVq1aoWhFMB5xpa_mzZvDMchAsQoVKtStW3fNmjUYQAE8F-8YP348-VmyZBk0aBA0GDJkyMiRI6lrmzqswPXKlClTo0aNt956S8YTInXA69Kly9ChQ0nA_MaNG8Pkli1bcgtXITMu8NJLLyEvMI_G8RcOpeaAKI_nnnuuSggNGjQYOHAg-UHfBO---27Tpk1xvWrVqj3wwAOUCSoGnOLhhx8uVaoU0fnNN98kR7OHZ2EhCcxQU2wwFkm5BiVLGGx1mHylubrITjJsPhMoskUAgSUIzrD2ctvweKTCMOrxxx8njD_99NOtW7dmb2Ot5SwqTGyfOnXqwYMHu3XrBtOaNGmyYsUKHqn6G2-88fbbb-fJkwcikZ44cSK8BTwSKAaZn3_-eY6jMJymcB-1D50w48UXX-zatSvWwnDITLEHH3xQPohL4lnt2rW78cYb8YJx48ZRhu7Yg0Ntx_xJDy1XDYHNgqeQk7pMkb5DRe-Ux3NhIHsB9o8dO5Z8iRie0kKzZs1uvfVWHk2bNi3U6n92797N1fyIBk2LyzWSABfZkYOomDSRDSAzAdlWlrindFigE2mB9LdRQqAja4GAyfahtIFQnzt3bnSXigUNs4pQztJKyG1lifoFQS_misSnIs51zz33kBPs2tLaDWkzbgxn9tQgjm-DUqY8VDm0QHW1I6uk0fVCysy28lb40qC8VUl1IpuxyQhWFAfGMqWRC1wZIeGJoNmxY8fq1auzVasAvWtCly9fTiYRiviFSK1duza35cqVo03w6aefEpXuvvtuMm-44QYkAoNnMybOUlctIBF4Ss6oUaMQ0MhxKQatK6vF0_vvvx-VTPxFphA977rrLh6BkiVL0j75lCldujQJjCRSExB5yjZPjxhP1EMZEBzTp0-PJmDJRZFdu3YhgKiLhkB5UAtFjj3qGi6iHnhKDjNDAE2XLh3xOqbj__xn9erVPXv2VBpxg9wnwbQYIXBRZuASO1kYXGRHFIkS2SwcV_iv8haM5syZwwaspenbty_7HAEFT4YnbOHoYNgCGVRYjRw6dAj1jPIgMubPn5_jHAwvUKDAgQMHeEpQrlmzJnGNiniQZHSJEiUeffRRWhYPORnyFAXDWRR-5suX77HHHmPDxgxZgqRAGbC7FylSBD6js7Nnz84Acd4-ffrgDuhjWsAAHJNieBCtURFgNjnIDg7Dd955J8WCn6ezHzzyyCPXX389AgIBzSO8CWekXx7RBZlUoVM0BxGDNCcEKtI17vPEE08gqrglSmC8dhfpbNtpLgpbHTpSmquL7CTD5jOBItvA_IvGAoQkcqJCXn31VW7ZO5555hm2NNKcxCA5dILh0EAx3EAohvxwiQ0ic-bM9erVowy0l4TFR-AkNMYFiLHsAgRbHMG-2A3ee--9bNmy1a9fn1AMCamOA5IvGQ3YVjgENmzYkPY5Vao18s-dOwcz2SlwK2rlzZv3jjvu4Clc6tWrl94RkqbMa6-9RuMcBihGNDavZ3tFduAF6p1tgt2QYjySyMAvqALbeYR34OBsiOTDTPYv5kQCAi-jgOQ7t2Z5ooABLrIjBFE9ySJbUEwG4oa9zSXUs-IbNmwg8m_cuBHmi_yKhJCNLiiMZOIWvYsSgPMw5-TJkypJAYoR0iHb1q1bcUaAkebIYhS-hkpBkMgxsUchl-qwXQdLKE37lEFpiJwCM0DjLVq0IC2NpD-8kS7HEgIvHGZL0ieZOBc2kKBlmUHvnLdnz54NPxX8DZiB2QitxYsXHzlyxPhPwnQ_hnEL1LugLi4NRgeUTl0i2wgBevToQaRj0pm4Jk2aEFCYFCYOExkzBZi4rFmzLl26VJFXHII0rMp11103depUbk-dOkUkzZEjh_12ASWPHj1KDspAOWgXrkwcq7tjxw6qmy4BiGkAmSjAGOk6Y8aM11xzDSpcPRLgCFsktMwsT-_evWkE7tpS2RddsEfGMxB4QFMvvPACt5r3l19-mRx7_UanNliAs9HssGHDdIvXcYpAyiuNPyCP0CXcIrgJwVOmTAkVjIHRgtbU16_CRXZEkYQ_fGSVKS8v4JbYwf7N6kCz5557jt36iy--IF8HcUBMyZAhQ__-_UnbDg3gBkR69tlnYT5gL-ewRwzSU1Vn4yQuyDwIQ9ck4AAxDt_hmIqPk4MlOhYaw2kQhU0XiBt92oidNKUgBUtp7cMPP2Tj10c0yompGZoH64grNl999dVIENLqjiiPgyDLgoEYaELwOI3LFDNBgxwb-3333Yea4ZaSKB4JLxlmk3ZR2OpgmNJcXWQnGTafiRLZTCzhK1iMCDxq1KjixYtzakI-dujQgfXdtWsX-cYBlgYWvf7666T1iQct6F0JLEX-kgMD8UdyiLH0AiWkRVDJBH8SQcCfvXv30ib-y62WG6bBKLyDutop8AI8pVGjRgrg7EfFihVTs4AyeAH7F8JCI4JauLYCNU4UKhUD0mxnHJhJ6yniWDy31rDfnIgtjLCAXjcnYhQFCxaUskFMPPDAA5x7yWev5Bg8aNAg8jFYA0ksXGRHDlrTpIlsC8iKnDSFBNILXRGYBBsERAJQlytcjakQchB1jaKA_-jCwoULqyQJa7Bu3bpE4yxZsuBHSJFMmTIR1bNnz64PTACKiIMu-RRjC6B6ly5dyFfIxYzu3bvjAqtWreIcC2kpgCVIUlwGEcWjfPny0TjN4ko5c-a86aabcHZ9XspegA-SD7c57lIXxRjT6y84duwY8ZmtjTbhOQU41m7bto1HGIA7dO3atUyZMvoJuFy5ck2cOJFH2kMRPJptNhqdKAQ5IMBC-XV8iHGnX9Yo1b3JBgyMjR_RoD-9qlOnDlJSgxcULzCa6MNWrVth_fr1WkuFGMAhnhydojQvhGBydPQHNnGAuMkjIpHt4oQkll_slJaFVQ0bNhTVBAoHGyHu0AhUYE6sHUswxaR5yoiwX5-kAxYeGgHSGC8iCtxi86OPPgpfbR4Ydb169SAZbJBXcOhkj1GDKGwE1gcffKAhm4sG7bw0XGRHFIkV2UG-AfZsIguRiFClF1ccHeGADn4sN8objUu-RLYIDIgycIb4qB4pNn36dIrJ17BEIaBkyZIVKlRAepphGADl0AQUXrJkCTmi6MiRIzlzrly5kk5FErw1d-7cOnPqeyz0Yv4IdFzkqls6Vb8ynh6VANhQrlw5Espp1qwZrN68eTNpilGLhAxGVI0YMYJwaWGHp0grOtq5cyfDx-koA6VR7dizbNkyIjjHWkpyyzXocWGwSWAUSnN1kZ1k2HwmSmSz0FpxpVHMc-fOLVCggN5K4FDwEImpArTGQkAblgZWUEbrSz4VSUMMzorkQGx4PmvWLHJYTUiumElJGod-0EZrqo2G6_Dhwyk8e_ZsbkW_fv36wcwVK1aQ1q6MB0EwntIXrkGO7T7yBVyYRhYsWED6omOnPMyEujRVq1Yt1aIpiRupKAwzRS4av_DCC2wiW7dupU3lcAJHZ-A1mj3Mq1Spkl7HoFTYg_RSiUjCNbFwkR05iFpJENmSoUBhk3YQlEhMuQBBtVOnTtCGNvEFElwJ2nCMp9BMxaiLyEaGsdH07dt3-_btrVu3huTSstCPmI_kwIkoAIWWLl0K_xctWsRThf2xY8ciXocMGUKb9HXPPfdAeLQ-PJRhMJMGK1aseO-99-KneCIFUKKMbt--fTQ-fvz4G264AcLT1_z582mcuE1FXBJpTuBlaLRMg6hYhBmPoDEThXlsFuSwKejTIXwcgWuK-ZVXXqHrt956izStSY7b8aBp06aPPPKIPJf8d999V76PQ2nm6feiPmugmEqC1CiyJ0yYwMyyh2ENS8g6SSIjcBm2UY1iHGXmzZsnTlCY-eV0Tkhl4ydCMa08GjBgACunyaUus8Yj2ocxJBRZaE3NsgFTOE-ePJzYEApESUAOsy9aQF9CWMeOHU21UFexjKZIc2Xn1itGMq0YoAskDiOicaIexzJa7tWrF5bTAqPjFoms4QiHQn9AprROkzVq1OBK2GVaSNAOHqL4S0m9I0S90eBLL73EMMnhkW1OwWW6NFxkRxSJEtlMvuZf0ZNAAznbtm1LumfPntCArdqWWJSjPHGKR_Bf-QLFyGzTpo2V55gKXadNmyYRAHhEeCUoKw0_7YhIdKY6Mr1o0aLEXxJwjBycUQVAqVKlpIzxNeUItINLwkx9pwsnJYd8ugAqQ3Ds1q1bkSJFrr_-eqIbsomTpA4YlCFfVmm6GKNVBHgWcZNwhlPccsst1KWX7NmzE9pUngFyRsWja9euzS17AAVQCXoU00Q8sNWhR6W5ushOMmw-Ey6yWWixRYAnqEZ4-_TTT3OLhmAp2eONKqFSMTvRpk2beGRfF1Ej-BF1CeMQUvnITYpBFQu_BHxYVL58edJsw1xZfVVn74CcuEDWrFnLlClDyGW_ozrElvalPOG6SpUqNih5pdpRI4hsKEp8hjBWTMM8ceIEWrls2bLwWW_pYBpPecT-Qo-QnFttSZaQuzVp0oTy7A6UwV8IFLgD7TAP9K6OoGuhQoX07Rcdmzk2kE4CXGRHDuJJ0t5kA7gkedO_f39osH79emJv9erV69evD5PDgnPx4sXjfmhz3333wQ0Ok3SHy1ALxj7xxBN6Khtee-01yiDB6Y4C5MgF6BqF07Bhw5iioVcYiB9Kvvrqq1RkaFxffPFFcrp3724O27t3bzNMmRRA7yqtCQmOXQPk-uyzz1LSDpxIcG6JLdJmqiiQPnjwIJsXOwu3agH5jkfbdwvxVjaa9u3bc8v-SFMcwkkzCq1CsMGLAiPNzlQnslknrNFbOm6feuopAgT8YHgKiNrvSc-dO5fBawcF2ib1dRH2P_sojUXlsM7JXreAugTHBx54wIKUQNdoC6qvXr2aIxSTi4JHa3KEUohkjIh14pe-QqqALtjEsaj6YuiuXbvEOesF0ZMxY8bGjRuzPezduxdxzNBgmJYZEvOUEKnCgpEPIFzomtAM6TlaLVy4kIVnruC0OgLaKvTjaI899hjlUcnkixmJgovsiCKxb7IVudh9ubJHsrJEQNKcxVlxmGCxCUcQM48dO8ajQYMGkWPtQ_5MmTLdc889uqXZDz74IF26dJMnT8YYORcJ_UUBbcpCGlS06tChAydb2oR4kG3JkiVz5syBk_Z1N8aCCACkbXRcVV0JSIXE0deZvvnlI3KAC3B6pC6uR48AEd-gQQO5NldkDVA6VCMG9KIW6tati9zBNaAuOxOJSZMmESXMNmLIli1b0By4Bk7Xr18_pDzeFGztorDZwwuU5uoi22DzY2O3iKTgBkQArZSVT7jIDoJeCMiHDh1COuhbf3379oXqixcvVrA1SoCdO3fyaPDgwZBZNvAUnpPJxqxOISG7LDkrV64MVYoBj_CCqlWrkhZDCPIaFyIbJ-L4CsdmzpwJx8aNG4cfsTtQQGUQuJUrVyZhkG1mGAdjGsGJ1Dj5KnD48OGCBQsyNIZDj6dPn86ZMyfHQgpoetlb8YuYJkJQg8yzjgePPvooA8EerMLFEPF0MX36dLm2bOM0kidPHtQSDfbp04dtCGN-VTdcFC6yIwetSNJEtt68wgp0FOc9wjs0a9WqFVoI4WGbhU59UIgu9CbbAjXlGzVqhBgVr8DJkyepzrZlHCYh19Ora2DV2RrQM82bNx82bNioUaPYp1555RVktzS67NcbIr0_xlTGa6GYTrlle8IR7r__fnJEXUH2s5fRC4107tyZEym7mH0VG_mOaDZ3NjUooOgo3KJFC4I_mwUcxjb2BWpZL4g0VCg6G8MowFhQg3oEbJjxgQHaGqXGN9lg4sSJrO6IESNIt23blpjChDLvtEyO1pinrNDSpUttyZlfXB0RwObKSCAQYev1118niCBwNS-sIk0RttAoMeEw9DJMj0g888wzzOaaNWtC7cWANk0lA0qyMRPISMfM4i9_e4ttlMQ8GoRVGEaPWm9yZDb0ol8ikebqiy--gAeMDnu4BSgnVIKGQxkqKh9QhlMBFNcfqGFS3GXWqUPvbLp165YlSxZ9fAnkorTMtPwqPwQX2RFFYkU2vA1OOyuLUxBf2Dv1hQ0dRFkm1pe4QIPbt2-HYDylfbGUgz5PiSZt2rThVnGNvRyq6IduBDqqU6eOhHKQLbQ_evRoOKavrwG5BvlAOaB8-fLFihUjQeNmswaoGMqOTiNs_KEnsY_w1jFjxmCbvkZCRWymHUhok9OyZUu8T4qWp2pNB2Cgwy1ah3TQZwGzxK6Dx1WoUIGQTePTpk0L2gD0qeJFYQYwvUpzdZFtCFtlg20nLIelgRVLoMjmEV0EJ5YGWXdiafbs2ZGJ5OBQkIeoKz6w4gpZHKtY6OCfz5IPXcns0qULLUuOIEbJWbZsGTlwXvyBfuhsEpBN51uhV69eRHJ9XcRkgeI2kC8UL168Zs2aJHA6Wa4ZUJpe2HTpkasq6krXCHfy9eGt8gn79jeXNIKoZZtA1vBIxlv7VGc-2QEhpMzAx7kyZJu9bdu2cQBgNyE9fvx49ln9Mskl-H8JuMiOHESYJIhssVdXyKAfZtC3CtnWLVZbbCf26usi8MT4DBo0aJA_f34jNpJXXwHAEvxLAh31LFmCRJGWpX0eoRzojnBdqVKlGjVq4Au33nprgQIFkLN0obHgs5ShLsPRAK0vErRDgyhdyS2BllWGbatKlSqYhz3scfqE374ZgpBD9e3duxc3URyQVWphwoQJGIZ8p3qJEiWwsFSpUux39nmXfi1bL9pXr16NC-utEy2j5TRFmt74wIhsjVKdyGYG9c6fPYyBceag5U6dOuljO2AkmDVrFqvLUUYLpitjYPqYdNIqidxkpvRVZpUBRYsWhVI63AuyX8xo2rQpQzAKBqMPM8vi2RepgQQNE0cLEIWc_v3704i-OSpomeE6-fpzXYKj9Aps4JYW6I6KWbNmRXtxSxVW1JjBtOhzveeeew6zjYubNm1SghgHS2iBPWbq1KnsAXbwwjYZJsiYX4WL7IgiUSJbTBZdYY7ObKtWrWKDnDNnDjksFie04Mc1YO3atRCmX79-apwrHUFgMglM5Kh3bfb2O18Ayun7c3QkKqpHgNSgo5IlS-qwd_LkSdlGMVMhuCrBVGlzIkBJFdYHcIgJhRsjpL7q-vbbb8vglStXZs6cmehMMRFepj788MOyh7GoLrcUOHTokGK6vg6OIyjoywa6RmHrZ9Q4fuTLl09RQqCFS7Ba9gC6U5qri2yDhSMQHL5t5xZpCUQKmLpNoMimfThgky_QEc0STtkstZRvvPEGaYVrUQuwR8IZCXFAIzxCLpCpr5rI4EmTJpGjmEl36qh-_focZfUhEhUhEo8IyyQ4vpYtW1Z_T3_mzBnxR04hsMVoz6IiIKGOaIFbXEyfOuILeqQQzd6HbCUf76AYrs3GDFcRKJjNfFJSXx9nk5IUkC_Aag352LFjeA2WB39IGJvVPj6CHNGrQXjLsUQKW7tMEuAiO3LQgiZBZOspTGO59cUJghU5jzzyCLIyuE1QUtGSkE54VCaQ59atW5eISoLeY2L3zz_TFJLXnIsu8F8y7W8hgLi0dOlSFDnqi7QZL9COSNu5c2fq2lsSg8UNgAGPPfYYHelWp0qqFC5cuHr16iI5_tgu9IOY6hq264WL_fYa5cV_QT-QpZ8kEhSggrOqV5Z4B5a3atUqS5YsGzZssIHHtTkMNGWtpS6RrRkUiFyEvBUrVijWMCNMtPZL-iITeYHeZS5UXmBpCX_B9xY9e_ak2K5du2LvQ9y98847M2XKVK9ePdQGWodjva1ir169aAH5wrJBIA5zlStXZoL0SoDJpSKiX7cGGz6GcVajDNEfroguXCEWYQjxgYwmYhYpUoQQzFHs2muvpcdToT97p0yLFi1Y2kKFCj3__PMcpIhfderU0a80AP0RJwvG9oANqHZCOcc1ekficA6DXhTjcElfqoI9gARcYeBc4y7qReEiO6JIlMgW7Y1yiEuFDE5T9lIZMa2_GeeRyIzIRhB3795dhRVH0J1QDv6woOp0-vTpGTNm1Hf3AY2TP2LECLZ2wm6HDh1wBGB79uTJk4k42bJlwzUGDBjAgbNgwYL69QbaxPeRnriMdWqeBb3lDhwXqa6vgdoMUB6XKVGiBKEZL8AFMB4PzZ49O9ZySBYDOWRiPz1yDOjYsSM2sD1YOzCf8tdccw07Qd--fR9__HEiL7PEI8aFtbIK77AvoeLRalnXi8JWxyaNq4tsgy0xsCmyhIFb5Vh-SGMn6OsizCq9xJ1bVOnmzZv1JwEsLsuq_4pgq8mOAJEQ2dCPW5wIJqCG4XD79u2VSc6oUaNuuukm9CtdYIk6Yh8hkhcvXvypp5565pln2rRpQyiWnQRbgjlUhIG4GBRFvrAZ0RRP4TkKgPBO-0Dzo4oEYWzDo5cvXw5R9QfHQMwEmzZtoim0BRyuWLEixteqVQsa0wXnB4UCbQSIafavrl27NmrUCONVnQnhyMHTnDlzwn9qsdlxHiCe85Rd9eWXX5aRuCH7GiMNbruJhYvsyEFqLGlfF0EJqAxk00sNfawNhyHD7t27xUkJD650AU9gl7ghcJAjIItygNMmbNQLGkBJgic-Qqa-mCEOS-mSLlOmTKlSpeRigqVxQ5pF1GHYkSNH2DWw01wA0DigGAWeffZZcjDYdkAECYSXgtfJFiGOj3Ds1Da3fv169pEmTZooDmjfYUIkkPAjmsVrxHxNLL1jnsozP8QH9Tto0CD6YjM1cawu7PaioC_NP0h1b7IZdnBVNK0yi_HrkaZm27ZtyFP7g1DNDkGwR48eGzduJK25YwtkmlTFzuu0Q0B88MEHkddc9TNGzLKYt2fPnhdeeIF8QAizP-qCFpQZMmQI6l9LonygigBTIVz__v3VI_kYZtxFRkAsFm_27NnkHDx4sG3btqgBhqkJZPkXLFiAkrj__vuhyMCBAzmJkq_qgBDMttS8eXMUNjsHfSGvNVIbHd3ZQuoRwGBLJwQusiOKxH5dxBZXIGqwX8be_BIraU3-L7YQAeEPjh1T4pdM-kKO69fZRZL9-_f37t1bX6rDDHhCgut7770HCTnEE5c578F2IpQaOXnyJC6DzMV9KICDwHZawwCaHT9-_JgxYzQiuwadhRMv1YMf9VARkCAT_3riiSc4POzbtw8zUNLMld58yMvwCM6xRFWkP3EWYRTTRMh3MA-RgeK_77778BEK6EWdgBk6KmiMehuhsAuCFoZBowB4gY3IRbbBoh-wKRI_WRHtcAaYbPOZcJEtUIbptZIkREgSKAD5iAoAWcW--8Ybb7C3kcYS8klgJF6wcOFChTWwdetWOEnk11OKaR05fCKvISSKHDGtsYg_REUkJvzETTp16kTA1KscTMKSSZMmkUM7opnArdFMfmdvf-hUBtMvNiOF7777bqQ_p2Ja4BYz8G6bTLQFOx0kf-SRR2gHL6AF2YwLwGqe4gWYh_Pa-xegIQcX5RLM_1W4yI4cFJ-TILKJxlplMQqFwC6gvy4gkEJmRAitwRO6EJmLFClCNAs2DitatGiRPn160vCZkrSJNtUf3FNdrjd__nwyIeGOHTvoCOpSGPAI9mbMmLF06dJLliyBrngoOewOah8G6vvc9vmPLEG9YLbGDjjH6s_0NaLjx49TjLpURAfTO4cH_dUj2LJli3hOI7gPOfgm8RlT16xZM23aNESjeseXM2TIUL9-_cWLF-NfOD5nzpkzZ6o6pwv9ESQKDbG-evVq0oAhaCcyuR8f6EUdgdQlsiURmE3GoDk12G-vaCXiIq6tAvlacoNuWadDoR82BzDGZg0BITZbR7KKAspn89AjckRibm3iBC1VmEk2KEtItYcexkRG6fIgKKBFDcZBkTsIfW4oaKJQXTKJYWJ20DzZ_KtwkR1RJEpk21PKw0ZYoVsRRgxhxXka5h2iLlBHase2W6BlVY6emjHiiZzFmGkhLO7GbKwGNi7dgjDDbI9XSZ4qQUeymbpWBkgci8bWC2ZYxFAOrhGkunmKCmgs2MmMhTmsvhIQH2z-aUdpri6yDVpoTbLNFVvLlClT2NtEHibc2GhlEiuyAX3RUZBg4qTWOkhLFlqJMO4JQe0rGN-sIjbLeK60bBaqXzgjM7BHYxcoKSODBBYob8TDKrVjoLxGYbylKdu8KKxzC8XUnQaLVda77TtMtfpSUzZRMhho-IxLk0MjF52lX4WL7MhBVEnam2yBCCkSkkAkiMzQAMIooorV0EO_6ogIIdNoyREuf_78SguZM2d-_PHH1bu2IQj25JNPFihQIFOmTFK6SFURkpaHDRtWsmTJG0O_w33TTTflzJnzlVdeiWkoRGOOjqhP1IVyxGdd1cWRI0eKFi369NNPy3I1q345VXJsoNk8efI8-OCDO3fu1H8n5EStMrTTs2dP_SZb9uzZuZYrVw65z1O1xjG7VOj_BgKkfL58-diUycdsNlOZYZB36KovpF0a2K8hgFT3JtviBYsXtuQkmDvdclXIpi-rgvWaBdbPAiWTRWHM46kNj4Q1qzAUtJ-nWsjgy0LrxUAv1p3lKEFh0mYbCT3CKnWkAjFFf_EloNYAxYJrbEPmqphLI5ocW2-6oIraDNZV2gZLsUvrCYOL7IgisW-yAcHRmMCyghhC__KLBxCDBFAZCCw60QWskLOosEiiYoQbMkmYASQUhSlGXRJkxrT7C_-VpjqOoy7oGl6RMPdUGhrzSGPUlfJYIo9TjxigW8F6kVUUtq96q0elacdKyiOM1TwyzwJqR-LD3BAoofygAReFTQ6dKs3VRbZBQw6bxqVLl7J11a5du1mzZi-88AKRRLNtcwgSKLK1iAJ9cWtTrVpq2aCnZIqfAPLAEwrzCFqK2-TTFGUgoW4Bj-QsIlhwUHgcdWlEm7RAgSBpaY2r0UzmWeNBWGYYYwG19u3bp3Rw7AAb5GsGHIRMEmpE7gDkiTIAZ8Rmmw0laFlleMSQwzpKIFxkRw5akSSLbFtuIIbYEqspC87k25lT5AfQSfSwR0gOUV3qyBK0Q5mtW7ei4_VnMHpEYfVLJtxAB1uUNvuDL09xWMrzCHtwK_FZOgeE7RSUIQdfoCO1hhZCsJEGVhLb0LgHDhygNRXDhTUzPKK7_SHQtQrIYMpwlZvbBqSEtWyTcFGErIgdY6oT2awra2NxhOURIZSjNLARymLytSQCxlhJM0z8sBgkSEZba5pcgBliGGCuKaCONNGkaZ-Wbb7CYGEXmGHKZBXNBhumcmiNNilvVYKLrfhOQhSRAWrTBgvkEkYFkcbGYgP8VbjIjigSJbJFAABDLC2oIvnijAgZbM2W3jipHBFDIB1krEBTyoRv2ClGWUeCNU6P6porrVFFt8IlCKMuKIALiNgGbjUQhWZRV2bLBkySVdoYzK3MwmCD9o0a3ZJQ45rPoLVxYfOJtUpzdZFtCM6kQM6sWbOqVKmyYMGCSZMmNW7cuHz58pUrV-7cufOKFStsPhMosmk5uEDmL5pq_eUWgAAqFtz_xJC4nBeMwKoY5LbRyRJq1khFYTgpcmKPTBIVlbZb-rUcAcvJDBJVjoAZGpR60ZVMEuSbk1I3PoOVbztLcCpoRE_NGBI0q9swCxMIF9mRgxYraX_4aOtu7NVaK8HVuGQF8AX1CKQijEVWmAJyGeyxioLx2bpWR1Sx6oIKkK-zMVYZjdW43cphqW5tkgNMeVNSjXONS2A7e_OU7uRNQPOgweLCwekS9EjFglAL5KvAJUAZq54yIpvCzA5Xi3EKhQKZzBdXm-vkQliDWsKkQZYHVxEorXHFnbvogovsiCIJb7ITCztQWeMiPJ0GHSESXScWxB0mgWvQJYOBD_oFbWZoine_GuySBTZFmKE0V0Q2DoJr4CAE0E8__XTTpk07d-5EcG9JY9iwYcOePXu4MnZmYOPGjcSNGTNmlC5dmkVU6Ni8efP48eNbtWqVP3_-ihUrdujQYebMmQ899FDr1q0hZLKvoxFJCYVrdhktH90hf7UHxRRyJBUusiMHOcXlfF3EkVJggWyNUkZk040YA3Ukr0lwMDKdGoRphcuH2ifsBq2NO8iEQLFbL2_CtDtDc5HtuDQiKrLtoA_MpXE0umMdoas0B-A27NV4CkIcw0jsD1qoydFVwyFTBVQl0rDVCRqDyG7UqNHSpUtfe-21atWqVa5cuVixYsWLF0dEkkhTKFWqFLq5aAgI6woVKpCTIUOG3LlzB2MFQX758uXdu3cvU6ZMtmzZatasWaVKFW55ZG8rkgv20bYQH08wL-yFnCNRcJEdObjIjl6wQLZGKfZ1EYlU-rNXDgAaAbbPYEyEXrGpy4ZoChDu9IvsSFpwZ4DBV-9KB8VKzAQHvrISjXCRHVFEVGRfYoFMvIKg66UI8D48MfgtQK7m-8wJUsneZ-spXhacq9-GitYjtinNFZFdtmzZFStWrFy5ct68ebt37z5w4MCRI0f27NnDNU3h0KFDR48e3RvCvn37Tp48SeacOXOYH-aKIP_hhx927NixTp065cuX50Dy1ltv6VehunXrph_BTd5oqQZJ0DUaGhbZ90oBtAfJ2F1ahovsyMFFdvSCBbI1SjGRbXsn1CEIolPpmzQJaVZgsTIZQS_wNSjiw95DJxzBRkDQVAbCrSE2N6rgIjuiiPTXRfT5j1aNNHJWXRjb6TTFRXaYAXJ87MRIWYv9Quh5DCjz29PPVgdLlOaKyK5RowbCghi6ZcsWFQCKY2kNsYP_hWCE9w8--KBkyZJo69KlS5crV65t27YTJ07URCn4M1HPPvus_hsXsLPW5cN2ELqA50oDbmNTIUi4BI13JBYusiMH0dVFdjSCBbI1SjGRHYx38W32lAnur8kLAjF2xh1hQiC6yzaMxwEI5VxDD2NBGRonPxjlowgusiOKSIts-4sr3QLrIuhTZIbx9rdE2DfBcEkLC9JJOhvEx7dgDIkoglOnNFeJbLxj9erVa9asSfETSyqB5oeJWr58ee7cuZ988smRI0cePnyYRUR_B5eSGevWrVuHDh1goMniZIFsCIu93_7y6yKEfRVIQeZfMXCRHTkovrnIjkawQLZGKSOyLaTqB1_sOxv2epvdl0aUTkaooy-__NKiMNckhNrgN0O0uUouMH20GZwKhfXYm6iCi-yI4jf4w0cgJ5K7wXP7wUfrLqhCUgTILxP9WKWzATmyOUyFB39Sk8JJ_gwqsbDpChPZNWvWlHfYP9ZhQcNsTiNgQhQJLTgcOXIEvtlsQD-LtOd_-ZuB9u3bt2rVSunk_W40K6XuIEnYipw7d06LqO0mxV0gquEiO3JwkR29YIFsjVJGZFNA5RUHMWLnzp0nTpwgGhJ_g_IaYpnyThagj6tWrdqkSZOE_KL4pcEQbGP4_PPPjx07hjIgpl8ZUdtFdkQRUZEND1kvWybIiWehUHfv3g0_Yf6OHTskZ83hUwRQ6_bbbx85ciR-JCUke-T1GPzggw_my5cvffr0mTNnzpo1q_4zMBAbUXW_ja_Z6sQV2ctCIHTKJAGr0hQ06ktwCdaxoFbSQnqvXr2eDv2H_-T9HMCWCdhJbMuWLfv27Tt-_DhegM4mXJOTvJtLGoSL7MjBRXb0ggWyNUqxr4sYCK9stPq_O0KVKlUWL16sp2EvIS4TivIMGJ2tdDAcJwraUzVqVEuZMmWwHK2AvklZ4ZJccJEdUUT6TTZtSkDg4SjUa6-9Vs5FWtcJEyaoZApi69atGNOjRw_SmgGuQfeZNWsWwnrJkiWdOnVKly7dqFGj7PUk12QXZ_HBVsfCBVdEdp06dVatWrV69epNmzapANOud_BpCoqlthYQT8ukq3K4Mmn2oSUgs0uXLu3atSOdvOsoe5RQmjiWIUMGyHbDDTdwvfrqq7kWKlRo5syZKulIGlxkRw4usqMXLJCtUYqJbPSoOmPfKlq06C233LJ3797PP_988uTJOXLkQLNyq5ICDDOeWewGEn_2_Y2gKOeR_f8hQHfqMX_-_I0aNTKDtXGqZeI-QdkaCXYk0AL7AWXY5tU1WLhwISEb9O7dWzk8lQ5Qj9YOCeUY7Lsr2mZoWWW4amfSG0f7V0kg-BdCak0lNQnkABnJLbsaCTNVViUELrIjit_m6yIwGW6cOnXq2LFjCFYoOmTIkAMHDmzcuBEHpF-oIp4gGd98803VAspUIiiA7KMbYG4i4vFIPFR5Kwlz0J20Y7RhsOLhmjVrMmXK1LdvX9JhFMUwrtbFokWLMH7GjBlqXFebNFmrisF0csE6wkiluTJj_s9okgabzwT-M5rLBFyCgRDy8OHDU6ZMgUgjRow4c-YMt4RfMU2r1r1793HjxpGgsCgkGiv8iqIiGGn9eyOL7XRBFbUGjKhWnpLKBPIUwFM1u379emLCoUOHuFWn9uUo9tPgFxTVL1BFPdJVNuuYF9wKIwcX2ZGDuBRdIhuboSXc279_f6tWrQYNGkSmiArYYh566CECppxC7kAVbm1EStjPAakkiCt79MgKpCowChtRyojsYDAChQsXRmTbZL300kvEwbVr1wajkhhmollfKVEVE6AWbnhqr0zsxRLLphhUtWrVQoUKkbC1pyNq8VQNYpsFMkU6Uwwy29rEKuref__9BJoCBQqgSpUv88x4gOXGEmrRNTNmYVTNkqN8ZQK1oBxMUgIGY6dMojwgcT7w08IKr3bLuOwfZ4IEBl8X2RHFb_Amm6tWjTRgF0yfPn2_fv2MvQZ6v_XWW_FZ-Zf4SYJaMgwKnT59WmzkCudJAApwZRTGbUoCavFIXmBsgeTU1a3Yu2PHDun-0POYTDUI1K9xdcGCBZScPn261IkM40preK4VCwZi9Z4skDGAaVGaq4vsJMPm87cR2fAETkJ7eAuRrr_--mnTptGd0VgRlQJFixYtX768LIE_QU8RtTisctWbi1B2DOHVjkV7bpXWJiJXohhXXACIrjSuDQvA6lGjRuXNm5czgHKM0mqc7khALRMf5kphoClaDloeUbjIjhygCtcoEtlBq-bMmZMhQ4Zs2bJ98cUXykF233TTTVdffbW9zWFQptPgLeOlBY1aEPkFHtn_YAcqTMLOq6kK2CbzQEp-XQRxrCmuUKFClSpVSGi-3njjjYwZM86dO1fbJPGic-fOhL8cOXJcd911ZcqUYXsjH1CeWFO2bNnRo0evWbPmzjvvZCcuXrz4vHnzYKRFvQ8__LBWrVq0UKlSpd69exMU0PTkHz16lOC1e_fuJ554okSJEtSlcbZ8xVMWGCX0yCOP0Brhj8YRAX369Lnmmmu4qgxdIJRvvPHGcePGdejQgWI7d-5UPhBFli9fft999yHrkTiZMmWqV6-evgwjnzlw4ACjw2Z9momd-vRcIEBjT9asWXmEhQMGDNDfDNG4ClCYsUBcJqdkyZJYq3wqspZ0Xbt2berSe_bs2StWrEh3KvCrcJEdUURUZNNsMFQJuHq6dOn0agFo1z948GDXrl2hbpYsWSD2K6-8wu2DDz7Yq1cvsVebPWQoV64cHIOKrVu3JgdfsNd75Dz--OMwkysuABvr1KnDI4A7QO9q1arRODyEq3JemUeIyJcvHwzHxXCBG264oXTp0uzWoaoxozCtMH_-fNxHEkQmWfwdPHgwbothxYoVe-6558hHCdkhOVlgq8NglebqIjvJsPmMkMhmCYKtcYuLiXKLFi2CilOnTtUjgRj-9NNPd-rUCYbnzJkTk5588slnnnnmtdde46m9xGFjuuOOO9Do7FYvvvgiJ1IjIVtV06ZNu3XrtnfvXrwJqkPshx56SGSAkPi7tpg8efLwaPXq1fgLT4nkEyZMIBQ0a9aMp40bN27btm27du1eeOGFbdu22VsYNjjUP9sibtKyZUvCMpnSHCj1d999t27duitWrGB0RYoUKVy4MGPEp0JVIwsX2ZGDGBtFIlsnT0kF6AfVUTWoHeUsXLgQZubOnVt7kDYgO3CqjIasMItPccujsMgglUimqqROsEC2Rikjsu2YzkzRJeqwRo0aygGsBDahgEkTQY4cOdKoUSMWZlUIBDiC0ebNm3W4P3HiBLfPPvssW_vDIUitsgAyCaFJ3Kxater06dOJrQQjntasWVMrRKDkKUBGUJJ2eCoZAdAK99xzD3VRDyjpRx99lCCLYs6cOTMig_hIIyh4wu6WLVuWLFlCXYKj6tI7WLBgAbKDAWL_xo0biYZEW_in3iHQrbfeir5B2cBFlARi_eWXX1YLdEGYpvGZM2fyqHv37rRPcNdT5q1___4MtmPHjuzxnEkIxGz89sbx0KFDlCf0s7pEwBEjRvTt25dM2zMuDRfZEcVv8ybbrnTEKRQ-DBw4kBxupQ8OHz7Mjn7__fez8cPw9u3bIy9wIo6RHIB1BkZqFChQ4KmnnsLpYBH7d4MGDcgX4DBaE4HL-RB_4RDLuG666SaREJF99913jx8_nvgCwzkPY4P9Fse-ffu4RVWgDJAmY8eOxQwIr90aWDzCy3DwWbNmMVHBVxcSNDgCjdM1afu1imSErQ5eoDRXF9lJhs1nhEQ2hBfnw9rkljgJSWCabgFrevLkSWhD2L_22muhLmqbwAu1LJgD2MUZleC8bNkytgm2AMRu7LMQ4DCbC9GesPnmm29yUoXtKAnC-KeffsqOM23aNKgyefJkNjiaunDhgtyQmE_vBGoMY7vB-_BBRP_SpUvVMt1hWIsWLXDhYcOGUR3gI5IpQN8Ea9OmDYcENogBAwZQYM6cOXoaUbjIjhwU_aLr6yIYSXzGWiJ29erVUW62WUBsmFyqVCn4qRwAyaE0ygRpdODAAarr9SWJrVu3smuwj8ArNiZ8FvVCvqblog6eeoBttkYpI7KtMAGOGFShQoWKFSsy3YjgypUrs9Gid1VM2k7bKsaxoxM7smfPjsWaX876HJgIMchZnpLz0ksvIRe2bdumF-EELyLOjh07SAMkJu0TEHV77733ZsuWbcWKFdRVzEJMXHfddfodA8Io0W3Dhg27du3KmDFj1qxZyRwzZgzdYRj2sNJoiCZNmsgYDENnkK9bzcMNN9yAMfbJIIMyZsAtmgp-F1ZtqnGWhFA-ePBgbFNOw4YNkSBSyRRD_VOAtAQNzdI4IM0xBmWDzR988AG3Fo5pRIlfhYvsiCLSIlsta7kJeQA6QbZggBMrcEAWFx9kuSESmcYWoKMaSogWRLDnnnuOnE2bNkmCg-LFi-Mm6BLKcIvzNm_e3EiiUx-9kIaT6IDZs2fLMHhFU7lz59aJmjJIEEiLrLfqmhl9J3vKlCnqVITXsQHdb5mPPfZYrly5Dh48yBCYVTKTBbY6TJTSXF1kJxk2nxES2SyBIaxZ_f3MxIkTY-9_WS8xn32hUqVKIqcinlgkphGK7fXQXXfdRY62GO07bDpZsmRBl2u3Gj16NEI5pugvBQTsGTlyJJyH6srBAIQF3Ca2K1zjCCHbYwz74osvaNY-GsKevXv30jWbDgXkcQyHHIqJhwCxzhapdEThIjtyEA-jS2SLkPgOBz_0NAdLmEl8huHIKiQmzEfwSEmz6aC-qlSpgrC5OgQ2qVAzMWBPQbwNGTKEFpBw6dOnL1eunBXQ96aSMcgnL1ggW6MU-7oI8659F5QuXZp5LFmyJFfWgEihL0UArRlgq-agwyMiVKZMmfSJA-EM-ZshQ4Z27dqp5NmzZxkM7egcTyZplHRMEyFQJX_-_MQFxVB4gEbXnq2dft68eQQ7fajNIQyrNCn0QtzEML0L0Ud1rDTKW8bgAxzUUPDr16_nlpAtDdG1a1dugYKvoOmCZJTXPCgQS98ojQiDdqwKnWpC2JBo0L7y0b17dwLrHXfcwamRITBYBqUWaHPPnj0ULlSo0PDhw_VXpHSqpwmBi-yI4rd5kx1cKWhJ2EKS0pdWk4Of9YtQ1j_BBmQCSAjzhw4diiyeNGkSDIQ8x44dI0Rec801qF5KUoaOqlWrRqCUE0l2yBnlUAIVuaUunNSH9ZT_9NNPuZ0-fbp9_IL_koNGt-iJqYyCnYZ8xISpHMK0jtNYgmEnTpzAwhdffJFiBDWVSS7YLGGM0lxdZCcZNp8REtkCDbIWYcuxePFiGGICV7BdBpFdu3Zt5UB-lluPkM7UWrp0KTGcI9yRI0f0KeLatWtNQGfPnr169epKKxP_sncrgC0PF9i4cSMHXVpbtmwZjUttALyATMyD-SI_feEO48aNY4vRq3d4ruHgqmxbStPC22-_TV3pDzLxkYTH-cuEi-zIIRpFtoQKgN6YDRXZPojb-E6BAgXIR7GMHz8ebjMcdAVxW_qHvSBnzpxdunSB_PLcW2-9FVY__PDDSCAKjBo1itvHH3-cNAXMR5RIbcB-W6MUE9mAmVIgq1q1KnL23Llz7777LvMozQoU4Fgn1C0NsgbYKkU-Y8YMCQUO-tx27NgxVCNGW0yYMIEcRRz9ZRVP6QirZCRN0SNpgJ5G6Wrn1mLv3r2bKvrQuX79-vpeHQXIRHCQiUTgTIaEJY0ZbPMIJlQIAgLZRDH2fh5RZfbs2ajkfv36GQ9oytLQ8YYbbqhYsSJpMhWOTYgzdqQGrQn0ogQnP70XJ44jTV555RWUE_l58-YldhPEjX8EXw4MRYsW5SlTx0lj_vz55NuucGm4yI4oIiqyjQPBZhGCMEGnx-AeDOXwjsqVK0MV_V0XkOQFbdq0oZbolytXLq4A_o8ZM0YFAC6JY5IQSQAN6u0yHQ0ZMqRMmTIoEmoVK1aM6nrHRmF0P7ccArkl2nLFBylWp06doOXMkt5kv__--4xLh0y60NdYCeIZM2YkgWvoB9pWrlypiskFMwablebqIjvJsPmMqMgGrEWYc3344YcwRL9fySMV0CMcATnLmpIm_GpTABSAaWjozJkzZ8qUCZrRgrBkyRIKQHI2r0KFCiE3uQ0bCJyhNXQw51j8CE-RH6mugR2ETKSJHAfAcK4S0DCftHll27ZtOehK1II5c-ZQZs2aNWZz8E_EIgoX2ZGDCBBdIhtfACSI2OXKlcPOpk2bNm7cuGXLlh06dGBEKCLpKIajmE-CYsgzNEzNmjVjWgmhRIkStKAyAodYon3w78pML6U2MCKgdMqIbKlnA-GJ2VQatc2WuXXrVjvic4Ihur366qsKHMQmNmxO9qwl8evMmTOcjV5--WXii6qMGDGCiLNhw4ZTp04dPnwYDfrYY4-FWooVAaVKlUIWKIe6eoEnZrDHIygJo4R-IhoKm1UnyCJMOYexrTJBs2bNwkL9gSPW5suXr27dupy6aKdevXo0iG4-G_qVBgI6vQ8ePJi0SVsbF0I5T548zL79wTjAQgV9yj_44IMMhKngILF27VoShFEUtlrQlVEjtSE0PKYwaoZRB7cHrqtWrXrmmWfy589PAaSzHv0qXGRHFL_xd7IBuyAE6Nu3r_Vl2zlAAaCzSfBUXIX_OIV-6mfy5Mn79-9HShIvNm_ejDiGD_iCSkJj1RUU-OiRpmARLtC7d2-VlO_g0aGCMWdgtAKHQ3kfPerPiO-8805uRTlAU7hS-vTpESLKUQAhcGMb5N-0adO-fftWr16Nmxw8eBAvNjmSLLAZwySlubrITjJsPn8bkR1cEdjC9qE32baaSlOMc2aNGjXIVBVIK97efffdMG3p0qVw7NNPP4W3eMGuXbv0XkZELVKkiHh78uRJroBG1P4LL7yAtoC9-qYfvXOS1CsPWqAL6CqhLOVNRSMwKhbmz507l_3CrGrSpAmFaU2-xpZHGWI13alHkLwuEB9cZEcOUSey9aIQj8MjZs6cWatWLewcM2YMbBc_ecpY3njjjVDxGOAFnTp1gs9yMb3c1MDRaegZpeE5zT7xxBOUsQOkUT0VgoHbGqXYm2x60hyRqFChAps0k0j42L59Owd9pC3S8_z585QhTeyzI4u-VGf7NDNO_LJf5KDYxIkTWVEd_bmlNUlqgg5GEgGRxXfccYdiUKVKlbhFxfJIO_2gQYNoH3EAUZo3b64vwyFbEQejR4-G6--99x4FOE7ROIKATCpiPMWo0q5dO3Q24YYGKUPJ-vXrK1Jb1DNvISjDP8UmC82ABplDDnzZs2fXH4lzq0dAkZ02aQda0zVAMOl0gU8GiwHqMsmUZ3dB2CnzV-EiO6KIqMjWYgFRTh_hIUChx9tvvw27KKCu6VeF8UEOimTKC4Dy33rrLbxpSOhX9nQaFJkBjVOGFgiFBERlGtRO4cKFq1SpYvYsWLAga9asw4YNIw1jt2zZgkl4EDNADqJBnyPhg8ZeAHsRGZkyZcKpLZ_e9QHijBkz7OCKS5r9yQhbHY1XOS6ykwybzwiJbJ3BIJXtGkYbAhqcmTp1KssEhYD6JcG1XLly-sqHnT8liwcPHowXWGgFygeiLmCj0WahptSsyKC_1bFXS_SODcgLyqgADCfOk_nBBx-IwNIrQB6BA2osGkiJEiXYZULPY4ALUGbVqlV0rWJWPdJwkR05wAqu0fUmWyAgc1yU7oKKKLSbbrpJzCRTIhsXa9GiRbZs2bp3744i1yc5Dz30UEz9kBMhTIPvbgASnDL2jRRgPpXawALZGqXYm2wjDbOJhqa8HhGzBg4cqL_jVg57P_srhpLGkzt27Mia9enTR9ENkc28P__88-z92MAuqO-cICl4yno0bdqUeEQY4pZGKlasmCdPnpIlS3JLFUn2Z599lluAmiTI6n0wtw0aNNAy0zLF9E6aOEgawTF8-PD8-fMfPHhQGkIzsHr16uuvvx4JRRro1w_69u2rBukRbp09e1aBePny5ch0tKz-YxwTcujQIeOQVBEGawvX-2l9z1WngsWLF58-fVq9c2WkOXLk4JSiQMxc7dq1y3YLfefvtddeU_lfhYvsiCLSXxdRQkyQLN6wYQME0HeyuWVByVeQIg42btwYN9y2bRu3AF5xVclq1apRERqQVoNnzpyhoslZBLr8V2QzQnKtV68edUVg2PjII49wi3DXU7rjlqPmjh07RPvatWvjPuQzMwA3kZsTsinJ-RaTVBds3ry5ePHihOm9e_fap4qoH2KC_Cu5YPNJ10pzdZGdZNh8RkhkG0QhpUmwvUEk9vspU6ZYd3IBrRoBX3SyfBGeaJ8hQwbItn__fmkF9jiCsJ7qmi9fPrYqulCPJr7hDPqbp3qNwkZ77733QuZp06bpF_oojyiR-tdXDYF6B5AZ6c8WhtrmlvY7d-6Mj6BuqagW9JUSvQWXd1AsEvMZFy6yIwepsSgS2Vgom9lQMFtfTyCwT5w4EQ3NI4Iz58OhQ4ey9eCD11xzDUdNCRtEUYECBZ588kmKqRHkeLFixRRy5Q4onLx582qXsd1HhVMbWCBbo5QR2bZNEolYD7y0Vq1aClWAKIa0LVy4sH7iQzoYYY2ixVYmmtkn_dRTT_EUjYtORbIotNGy_tSaY31MWyHVW6pUKXIKFSrEog4aNKh-_fqESwyW-EDr8BR52qhRI2IZ67p06VIeYRvnKhQAachRsGBBBAppRDZBEx1wzz33NGnShBbIhAeMmjZZ-_Lly0MvgiO3R44ceeyxxzAecjRr1oyR0oVJcAoTpLAfw2655ZaaNWsSponyTIVmY_z48cwD5lWpUuXuu--GhZkzZ4a-mu0bbrjh2muvZTiVKlXCbNph4w81HAN9m5YDw_33349SZ5Ogd-yJffxrcJEdUURUZAP4o8bRf_AfgkEPeAj9SFStWnXq1KnydqkBznv6cj86o0YIUr0449y5c_HH6667DjENJWBpxowZOXDK4wiRUBchTlqwZhnU5MmT8Vlaxr9wW3yWrhVMKQO1MAwvy5kzJ94H1TFv7Nixmg2LEgyEIACBEdncYhIF9HTmzJnYhtmcjVu0aJE7d27UDJk8knnJAlsdOlWaq4vsJMPmM3Iim53YtmGwYMECIiT0KFKkCGzJlCkTUhvmwG2eWtejRo1Kly4dj-666y5cgKhLJoGdCL9s2TKFYiIquxU-RWv6hAdADBwEJmsvIMfohxmE8fTp01MXDpctW7Z169ZUx54BAwbYV_swuE6dOpRhn2rYsCF8ZmvQ-3L2OEyiLr5Tt25dvK9Vq1ZYpYqAjYlaH374IWn6Vde_DQ9dZEcOCqTR-CYbELH192ZBU_GOokWLSqXoj4k__fRT-SlH1uzZs0Nv0vpkkkjOlmGKBS-gPMzXtIjnQR9PVWDUNvAU-7qIoAMKYnrx4sVwiClTO5s2bXr33XdReKRZmBMnThBHRo8ejYnkHDhwgPAE-dhuKT9hwgT98i4tcEvhOXPmnD59Wq8cwO7du9m5kdd6GYC80HtuApwWiZVm4fv160dT-m0QgcChF3hg9uzZp06dQjqw6rSPVegSKuopsEhNLSZUaUBJunv77be7d--O2bNmzdIrDU4XGv7hw4eJ9W---Sa0Y9RbtmwhU-EVC3mKrOfpiy--SETbsGED-QBL9u7dy7zR5rBhw2bMmMFOLxskmwCWjBw58vnnn2fsTLIGa9rl0nCRHVFEVGTD_GCbS5YsgXUAdr3__vskyIFXYasJS2ER6hm2jBs3zl4wcIWNUHro0KEDBw4cM2YMvIK95Gs7J3bQoHokgphuUPs43fTp0-H_mjVruCXiIE304z808tZbb3E9duwYBV599dVdu3bJKYCqqwvanDZtmlxD509dAb4Pt3v06AHPkde0j82YYe5_-bCZdJGdLLD5jJzIFm2AaMCiQGCYD_8Jp8RbJCk7yNGjR7WJQEI4Ri2U4htvvAGd2A6Cf90L2OapC1F79epFU6y7uKpPKVEVSPlQwRjQlEYkPhC3MQARrz_m2bp1K462evXqmKK_vJZDZ8-fP79___49e_aka-1W-_fv58qWStc4JsDd2FNiqoUA1dlQ8Fx9-qQcu0YaLrIjB61gFInsoFWE6_Lly-NcmA29jY358-eH4SSQcxwdOViiNIj8efPm5RjJ8VVf9MUXUNgUQIRQAIKhUznWkjABQ-PG-dQGpsJmI4VFdlggCIuz2kd1ZLetV9DHZHH3Ue39QC2b3AT2NYywXvTpAyWtC2uWQZm4VIPs3zBGEVyNy0gyKUnsA9YpOSIB7YSNVFEVENkxzGYvGD2BNRWcXpmnkdKO5ufLL78kn1uV1NdnjY6G4wn-q3MX2RFFpN9kA9oUt8MAT8xNKCMKGdPQ08ZVJYxFFJaAtuoAxiIyaDMu2WhW4-KRPbUfMLlw4YJcUlwVxO0wmR4G-wa2wYwngT-qkWSEmcEolObqIjvJsPmMkMgOMgoSig9wA4jSBHA4ZgGffGUqsANFdRXgqREYh1IiCOXQstoJ26pAkJDQA5PMg2Js-oW9gLrQW-VlA_4V3CzErpA5MZ3irWYzCHIv2Gzk4CI7chBXo0hkQzm4KuJxgOzatSt2BnkIge-77z69YQFDhw4tV67cjTfe2Lhx4zVr1qBBr7_--qpVq-r3Q6pVq9akSZM333wTtX3VVVfVrVtXfyuM79gORePB9lMPGLitUYqJbFOTBBSluUIjxQ4Wg3yIpe1WcYSnJBSemFll6kpdmU7Q0aQrMFEFwwhbeqrGZSrp4N8aqiMD5dUChVUeUEXFRHeLfQYZo_JhZyyNkRZM98hOGcY1zADUvE0R0dZmQDmA8sByzEg2GKVpk7lSRVrQsQRoEn4VLrIjioiK7LAlhifasEmIb0JYvzwSW4D9CYFuAbzCr2NvQk1ZYYFOLfzxVJlBqgRbA-K_3JlHWGKqQq_PDTSCX6t6GPfwJipK1kigKB9jgiO9TNgs0azSXF1kJxk2nxES2QKMtRcrBjjGAgW1Mgy0NJwRCYPGiEjQT1wVRH5zAVt0mqLxIAfEc0riU2pWOQLlTYKTjst8rhSQVbqy7wTbp2XFduxk01EXyT6Z8cFFduQg4kXX10XgqrwJC_UhDAkGYp4ithOoyTe_Y2hyVQ1ZyB_6fyYqT77tPnIfvEATEtyVUg8YHVA6ZUQ2jKEnCwQ214AoE4xB2jVlVnBJgmUEgqAtpEFdmMgGX3zxheoqYGmxQ0_-9_2cElIkwOaCfLMZsMwySWobA0DoSQwsdNIOnSptZlj0J2HjoguZShXryNpRXXVqVQDDkcEEd3tNaAi-1JGdCYSL7IjiN3iTDWHYfY3VcIMcfITu6Jc0V_qVQjWeQBKjnAjD0pudpFUeoloxQGtBplFMzkhFGpHHAXHYnirNVe0D8m0qqBV0KBB8SkKthcGsTUZYpzSuNFcX2UmGzWfkRDbkuXS4C3sK07QjACyBaYRTo5_xlqsdIPEs0rRDebkGmVQE5ho8Ip924o5OW5tgbRrwJhyNxtUsUBnasYpWy8qYo1lOpOEiO3IQ66JLZEPOMNfTfsEVup775Td58BElAFXkaEHJxLVcuXK1atUiwVMbNV4ZU-IX7yMRbCr1AFNlM0gZka1uII31Z3NHpiIF66QEV2VqJXQN607tKJPlZN5JA8VNVQG2HiKBOlU8UuSiKRVWgzIAaPnVPsAevQU3C7mqcbVjGtqUhwVES9CFCSBgA7deeGoGqFmbLspgJ5ZTgIrkqHfyGZqN10B1imkU1ual4SI7ooi0yCacieR0wbpr0eGerb71SI5l4jvBxSU_zGUES9OyFQAinkVV3dKgEdIIDGhEfelVRNgMqBEl9ChopHJkhho3hcStnqrZZIHZhhcozdVFdpJh8xk5kW2ANmoZoopCQcYqUCtfMRbYZgTEMdOsKqm4bZkqg3NZDi1YL_RuQwt2DWhNbKEij8TYML8gzVP1K5BjfmS6RDYAeYf1GGm4yI4ctMrRJbIFXEkBWWEc9pprkC_3IZOnQWKLzKoCn8uWLau_PJbX6Kl4bh_4pNp5wDCzLYW_k-1ItXCRHVH8Bm-yHckFWx28QGmuLrKTDJvP30BkOyIKF9mRQ_SK7MsEGyJjR08zaq6ko268GGw2u8h2XBwusiMKF9lRBFsdF9nJAptPF9nRDhfZkUOaFdmMTjr759Bv2wffdkcLGIKtkYtsx8XhIjuicJEdRbDVcZGdLLD5dJEd7XCRHTmkWZENGCxjZGfkGo2RAbOB0i6yHReHi-yIwkV2FMFWx0V2ssDm00V2tMNFduSQlkV2tIMFsjVyke24OFxkRxQusqMItjouspMFNp8usqMdLrIjBxfZ0QsWyNbIRbbj4nCRHVG4yI4i2Oq4yE4W2Hy6yI52uMiOHFxkGxh7dA0Za81gF9mOi8NFdkThIjuKYKvjIjtZYPPpIjva4SI7ckizIjvu6NgiTZtGBRiCjcJFtuPicJEdUbjIjiLY6rjIThbYfLrIjna4yI4c0qzIDtsQSTMV9kvwUQEWyNYoeUS2ysED3X777bdlypQZO3bs_v37jx49ynXXrl2HDx8-fvz4wYMHv_jii32OVAmW6ezZsyzQ5s2b-_Tp06RJk7Vr13744YdctbL6Wfi4tHAkFs8__3zbtm3ZljiRHjhwgMnXNaqxc-fOCxcu7N69Wz6Oy58_f540Xr99-3ZuiQY85ZaEqkQFiGAnT548cuQIA-SKjxArBw4cWKpUqZUrV65Zs4ZTqJaVGBhdb1xSEOydeEHr1q137Nhx4sSJ06dPQ4y9e_cShSAJc84tiCK_wHiIzUC4wnaYr42PUUAbRkQOgEt79uzZuHFjbLWoBePq0aNHw4YNFy5cSChj1_jqq69MBjiSABOX-h9bbLhLly4tXbr0jBkzVqxYsXz5cqLNokWLSACCT1Rj2bJlHM-IpQiMBQsWzJs3DxkKYh9HLRgCO8Lq1atJcPgcPHhwyZIl58yZw3mJtZOI0j8lvOj7tXjfZAO97ARffvllkSJFEO-FCxemda558-YtWrRosWLFSOTKlauEI1UiX758LFz-_Pk5OhcsWLB8-fIwBgfAsbWyWmIX2ZcJ3Ax5gWuULVsW78iWLRuzHbsG0QyYw3Dy5MlDAvdngBkyZGCMAPeHVOwWJIoXL06aArHVUj1YHQzGbMbFtWrVqowoa9aszZo1Y5PAR4insUvrSAD0f3B_-umn5557Lnfu3JxVCDtMqVgBhQCbBVMNSMQuQ6pHoUKFsJ_hwHwSDAowKLY8mF-gQAECLMOxYcZWi1qUK1eOAdasWVMvYjgaaX0dSYaJKJ1VuOX0kj59-ho1asAZyFOpUiWYg19wG-3QQPAXAixcwkHKlClDZuzjqIXkLsDfiQn4Ps7CMenTTz9lp5B80n_EvKiUildk238IVzVO6ps2bfo8BI5cs2fPRshznT59-rRp0yY4UiWmTp06adKkyZMnv_vuu1zHjh2Lh6MhENnm_EBnL5faSca__vUvNqTNmzfv379_7969GzZs4IA7fvz42GWIWsydOxfa4OYEFPDMM88QMe-8884pU6bAKwpMnDgRUo0ePZrruHHjVCv145133sF-gOVvv_02OYzuL3_5CzmsI_Ji48aNSMb_DsHfZP8qbIpOnjy5PgTmEHdgj3jvvfeIQhCGbYIoxH5BWquQ-gEfuGI_o8ARYDtDYCDNmzeH8LNmzdKgYP7MmTNxFtWKXuAOrA6-wAouXrwYL2BN476ZcyQc9qUIve9kMk-cOKGc48ePnz17ltuPP_542bJlCxcuXBLlWLFiBRsfAoME5OnZs-cHH3zw97__PfZx1GJVCB999JGkLyv1_vvv4yOffPIJUkorq08qEiGyKWqliZsmuAG7DkqC_qBF6COO5aT_4UiV4KSFA8MDzlvr1q3jljQ5qMDgh4Ba66Dsdlwmjh07xnkmdhmiFlCFoAlniCagXr16NWvWLFKkCJk6xFOGKyE1uoIAcZ8r4wJ_-9vf0BPEMQbIQFg10ps2bfr---9j19KRAKCzz5w5E4whyAsmkxmGRdCDqzYqJlmrkPqBtWyxxg0A29HW5cqVQ2RzkOARXII_DJPRxVaLZuDXIUWxioHv27ePdTQl4EgCbJ-14zo6-7vvvsM7pL9Pnz5NCMI7mHz4FtXAF_AImCNh3bhx4wULFuAmsY-jFgwHx9e3AABhDYXNAD_88EMyz58_r2XlSgCM-1Lm4iKbCkHXUujUl04gze7du6EFs0n3eKPCqCMVgr2BZVLE_Otf_8ot-wGM2bVrlzxcwP-5ushOMr799ltchgnUrHK0xUcImrHLEM2APFwJMTAnf_78kydPLl--_KBBgxR3eIT7Iz4UiUI1ogBERjxi2bJlDAH7ucVNyOeWyMajbdu2Kdw5Eg69ywF2PvnnP__5-eefc7xnknXIZ4sSbaICGzZswIsxeMuWLVxlf__-_QsUKPDHP_4RzkMVhsYjTmWcPGOrRS0YrPwdLyC9d-9eZEDwFZsjsWBHkJRig9ArzzDs2bOH4MNssztHOyAPPqKX2d26dStRosTcuXNJxz6OWrD34fiMTrseA2S9yCECECK--uqr2LVMlMgGMIPKEulh1dh-Tp06xSPcjyvFzjhSJVgmwJ7H_keChTt48KDyJawFrW8wx5EEEEPtMyOc4vTp01qF6MWJEycuXLhw-PDhY8eOTZgw4Xe_-x2ZzZs3f_HFF7_44ouvv_765MmTFCDzyy-_PHv2bKhSFIDAhQscPXoUm0kzBMYCWDWGfOTIEdK4A7A1dVwCUtXICPDjjz-aLNPWcPz4cfjDxDLnXElrFVI_9Gk-9sMHvIBbDs9PPfUUIhsv2LdvHwNkUAcOHID_0Ca2WtSCUeDRGgvLxMC1jo4kgxhi7ytJK0FUQXwjyMjBd9iX8Ro4RiCKajAKoiUDYYytWrXKkydP3759yYl9HLVgRAxNK8XQtFKk2eJJB99OEgBjUwHE-yY7NvV_EZcuAvmOVAiWxl6vnjt3LrRWMQgeqSkWfKvtSAKYTxD0GtLkaBWiF3JzoiTD6dy5c7t27bgdM2ZMw4YNERakFXQ0cL2ziQpgLSDB8dJC2UWD3kUzHXGhWbXp4tb2npgZ_2XOBeWkfsSaGwK7LNeDBw_WqlWrbdu2t9xyy969e_VIXgBiq0UtWDINU0Btc-u7Q5IRdAdLKDM03_-HYFfYPN9222116tSpUqVK7H2Ug1UDQRGldQwibEENFxfZOJtVUAThCgnUro5fKkCmv-lJ5dBux9lLt4g_JQSe-gomI_CIuB8YRTW-_fZbGEK4HDVqFLfHjh0rXLjw9u3bSesVphBFm4QtEKHMTkdcLZ8EwwFBzeG4BDRRzKEmMxhSiDBhL2WiBRqLoF8P-Oc__5k1a1ZOmCVLlpw2bRoyVE9BlI4xDHKBoF87kgwTURZY8AXNLWwhvGhrBsqU-0QvzOuXLFmSL1--v_71r-XKldu9e3fs46gFKyVPZ0HZL7RqrKmCXlBbUzg2FUC8XxdxOBxpHHYeQ0_cfPPNZ8-eJU1wadiw4cCBAy2gEIO4njlzRrcOx5UBqI4L2Itq0DYEMvv37__QQw9pu_0q9KVMeYHDkWah4zT7QqdOnR5__HFyKlWqNHLkSD0FpkdxmaBbXdlwke1wOOIFJ_ivv_66R48eLVu2tA9DiJv169fX25dvv_2W0OlvfB1XPCB5o0aN3nnnHdKLFi0qVqwYB0vpBn_163AAHTgbNGgwbNgwEu3atWvatKm9sOd0iqekteOoi2yHwxEv0NDnz5-vV6_e448_rj-s_uCDD4YPH54zZ84NGzZQQB8Rpp3XEo60g-A3QFAGn3zySYkSJbZt28YthC9duvSsWbP0eY595uNwpGVwEN27d2_ZsmXXrVvH1vDZZ5-VL1_-yJEjsY8DMOV9xcNFtsPhiBfojN27d-u_dtWoUeOqq64iaBYrVqxgwYJ__vOfg9HTPy53XNn405_-dPvtt8Nzvb3u2rVrs2bN0AqSC8GvZjocaRY9evSoU6dO7M1__lOxYsXRo0cjvkHwAx-9804LcJHtcDguDsKiXtEpOG7YsOG2226zf9Siz_5I2NdIHI4rDPoRW_3VY9u2bfv27YuYRlXjGn_5y19uueUWCuh4eerUqZgKDkdahdykadOmPXv2_O___m_c5H_-539efPHFhx56SB8K6QNPHUf9O9kOh8MRA3v9sH___kKFCu3atYv4aH8vb8E0-Nm6w3EFADWAmFb6zJkzRYsWLVWqFNcSJUrccccd5cuXz5Ejx5w5c5z5DoewY8eOGjVqdO7ceciQIWPHjh04cODLL7_MrqGffBXYO4K_PnTFw0W2w-G4OL7--uuff_lvLCjpkydPIi_WrFnDrSlvKQz_rNxxRUJfBUFqHzt2bNy4cQsXLhw1alTFihW5jh49GoX92WefUeD8-fPuAg7H---_f9ttt919993VqlXLlStX_fr1b7_9dq7Lli2zz0X_J_SjeCqfFuAi2-FwxAt7Y43a2LZtW5kyZfbv36-c7777ThJEcJHhuMIA-WG1_rSRAydXjpS7du0qXLjw0aNHQ0X-o9-1DDqCw5GWIQH9l7_8hc1C2wfaWu9iuJWnsHfIrdICXGQ7HI54YR-FozYOHDhQpEiR3bt3K8fhuOKBFJAssDPkzp07ixYtum_fPt0CPUo7osHhuAS0ZSxcuBCRnaa-FhIfXGQ7HI544SLbkZbhItvhSBRcZIfBRbbD4YgXLrIdaRkush2ORMFFdhhcZDscjnjhItuRluEi2-FIFFxkh8FFtsPhiBcush1pGS6yHY5EwUV2GFxkOxyOeOEi25GW4SLb4UgUXGSHwUW2w-GIFy6yHWkZLrIdjkTBRXYYXGQ7HI544SLbkZbhItvhSBRcZIfBRbbD4YgXLrIdaRkush2ORMFFdhhcZDscjnjhItuRluEi2-FIFFxkh8FFtsPhiBcush1pGS6yHY5EwUV2GFxkOxyOeOEi25GW4SLb4UgUXGSHwUW2w-GIFy6yHWkZLrIdjkTBRXYYXGQ7HI544SLbkZbhItvhSBRcZIfBRbbD4YgXLrIdaRkush2ORMFFdhhcZDscjnjhItuRluEi2-FIFFxkh8FFtsPhiBcush1pGS6yHY5EwUV2GFxkOxyOeOEi25GW4SLb4UgUXGSHwUW2w-GIFy6yHWkZLrIdjkTBRXYYXGQ7HI544SLbkZbhItvhSBRcZIfBRbbD4YgXLrIdaRkush2ORMFFdhhcZDscjnjhItuRluEi2-FIFFxkh8FFtsPhiBcush1pGS6yHY5EwUV2GFxkOxyOeOEi25GW4SLb4UgUXGSHwUW2w-GIFy6yHWkZLrIdjkTBRXYYXGQ7HI544SLbkZbhItvhSBRcZIfBRbbD4YgXLrIdaRkush2ORMFFdhhcZDscjnjhItuRluEi2-FIFFxkh8FFtsPhiBcush1pGS6yHY5EwUV2GFxkOxyOeOEi25GW4SLb4UgUXGSHwUW2w-GIFy6yHWkZLrIdjkTBRXYYXGQ7HI544SLbkZbhItvhSBRcZIfBRbbD4YgXLrIdaRkush2ORMFFdhhcZDscjnjhItuRluEi2-FIFFxkh8FFtsPhiBcush1pGS6yHY5EwUV2GFxkOxyOeOEi25GW4SLb4UgUXGSHwUW2w-GIFy6yHWkZLrIdjkTBRXYYXGQ7HI544SLbkZbhItvhSBRcZIfBRbbD4YgXLrIdaRkush2ORMFFdhhcZDscjnjhItuRluEi2-FIFFxkh8FFtsPhiBcush1pGS6yHY5EwUV2GFxkOxyOeOEi25GW4SLb4UgUXGSHwUW2w-GIFy6yHWkZLrIdjkTBRXYYXGQ7HI544SLbkZbhItvhSBRcZIfBRbbD4YgXLrIdaRkush2ORMFFdhhcZDscjnjhItuRluEi2-FIFFxkh8FFtsPhiBcush1pGS6yHY5EwUV2GFxkOxyOeOEi25GW4SLb4UgUXGSHwUW2w3G50Db8zTffXKkbLXHzwoULx44dK1Wq1KZNm2JzrxSwcLGpEP71r3_Fpv7zH98kEgXkplwAj_jpp5-UGdVgOPDBFPa333574sSJEiVKfP7559zK8X_--WeuP_74Y0yJaIbWzgaiUeP4unUkGVAIiCcKKUHvsENatAPv0IgY3fz58xHZZ8-evQKGxtppXF999ZUSti8QASigdHxwke1wJAPYdN96660xY8YMGzZs8ODBXAE5UY0___nPb7_99siRI8eNG_enP_3pjTfeKFq06GuvvRb7OGoxdOjQN998c8iQIQxqxIgRAwYMeOeddxjslClTvv_-e1NUwF7kOy4BaU2wfPlyZhXODB8-fNKkSbHTHbWAGwwH2nMlDUOgSo8ePYoXL07mqFGjVAYuwZ_Ro0erVvSCVQOzZs3Sal4Zx6SUhYKJrprP_fv3v_TSS6-__nrPnj1feOGF3r17v_LKK5Dq2WefJRHVYGvgimswqPbt2-Mm_fv379Onj55GL1gdRsRYOnfuTPrll19m7U6fPh2zwL_A1LYFQ4OLbIfjcnHhwoU__vGPN998c4sWLRo2bFi7du36ITSKcjCQBg0aMKJ77rnn9ttvr1u3bvXq1Rs3bhz7OGpx55131qtXr0mTJoyO4XB94IEHihUr1qxZM0S21jT4PRklHJfGv_71r44dOzKNd911F2xhemOnO2oBN_BiaI8LMKimTZtCmxo1atSsWRPCkA8gD7cwB8RWi1rcd999lStXbt68uXM-WcA0BiUXDvLjjz9-9NFHmTJleuyxx5544okHH3ywbdu2v__971u3bt2qVauHoxyMiB2QsUCkxx9__Mknn2Ro7B2xj6MWDOGhhx5q06bNU089RYhr2bIle_3Bgwe1puwUyOuff_45vlfaLrIdjsvFTz_91K1bt6effto-acX3vv76a6WjF4QPG9F3332nTwPjntSjDoqJSrNSpBnphAkTatWqpUwKWBl_mf2rgCTiyUsvvfT888-jLa6kSYMJsakQbGi4AyPlqcZ-BQhTfHzAgAFICtLm7C64kwy4oWhpc_jDDz8sWLCAo9qJEye4jYkyl9Rn0QUbBSNS8CS6XhlDA3J8xrV69eoSJUqcOnWKoTFAPSU_vpG6yHY4kgFdunThsIvalmiLzY1-6M2uwoc2jCsmaAo2nEGDBjVs2JAEO6JWUNcr4FDxG0CbTevWrTlqkmDS7DOB6AXcgAymkILgkTFHuDJ4MmzYsEaNGpE4f_68cq6kaPbbQ-QJfvFm6dKlefLksS8bcEL76quvONKE0SkaEXQBDTk48GgHR1D5wv79-wsWLHjo0CHlCwRABosQj-svLrIdjssFDta5c-ff__73uiVcSnOENuIoBkPQHwVa4NBt7OOohcbClkBMtNsRI0bUq1fv1KlT-_bt09_rCFfSPhEhaHch0a5du7Zt25JAW2iqoxpiiI0lNNYYaLACni4hRULFohcIa0T2_fffz3BwAXn9Rc8YjkQheOD86KOPypYty6wGWQSugHnWRzr2549XHnPwCNx8165dxYoV27Nnz5kzZ-zzatxHZ4ywZQUush2OZED37t2feOIJEleeJiN8WLi8Ml7XSRgRH7_77jtiok5Ef_7zn--4445PP_30H__4BwFUJcGVMeSIwjj_7LPPPv3003G3mSsYIXX6vw4S1fjhhx_-9Kc_ValSZe3atUuXLl2_fj1Di33mSDwsdAQ3hWXLlpUsWRK5pp-quJJCK2yBQgxEY7liyBM2kM8--6xo0aJLliz55JNPtm3b9qs_v-Mi2-G4XOCEr7zySqtWrYiY6DZyLMpENUKDi30NY0d2JFTs46iFBmLbmzLfeuut-vXr_-1vf1uxYsXnn39u72McCQTE6NSp0x_-8AcEhOZWExu9YEQMRAkGBfBrbhlaSEj8ryrSO7xQpSgGQ-CoichevXr1hg0bNm3aFByjI7EI_tCbElBo_vz5hQoVsgkHVwZ5AKPQcYItg5GGBdjoBUPQ9qd1XLduXalSpaZPn75o0SLSZ86cIZPB2njD4CLb4UgG_PGPf_z9738vN5MMVX4yQvId6IPp1LD_KbKwl0iIa_gyLOzHp1MVbHUwVWmuyIvbb78dkf33v_9dv4Ks4ejquARsPlHYQGnLTBawCsEGk7fxZASMEmG-_PJL5UQX_vSnP_3Xf_0XXvDJJ5989tln5Dj_kwv6xOyvf_3r7373O4S1OOxBJirAAtka_fOf_7z55pv_8pe_fPTRR__4xz-0rEAFrJjBRbbDkQyIqMi238AHdKHGU_B7KXpLQXCx-BKEXsxQhiv6O27QSXHY6rjIThbYfEZOZMO0Cxcu4Fm6Td7GIwFZeOLECbM5KuAiO3JQtHSRHY1ggWyNXGQ7HCmA3-BNduqB6XsS-pvrmAj0__5fUPczA0CCO7XBVsdFdrLA5jNCIlufjQjBdGoDQ2bHDR4yU_PnOReFi-zIwUV29IIFsjVyke1wpAAiLbK__vrr4LeE6ci-JJ0iiBtKgISFQIFkn4TkghnmIjtZYPMZIZHN4Y2V-uGHH7766it7MZw69audM-0wkDrPmfHBRXbk4CI7esEC2Rq5yHY4UgC_zZts_Nn-mCZlgcQJqhwGrh_WxUJNgs2A_eBu6oHZ5iI7WWDzGSGRLaBf1SZnuVT-HYzvv_8--KlOFMFFduTgIjt6wQLZGrnIdjhSABEV2bQW_JT8q6--sv9lkFJA68ukCxcu2K_AMnD9dSYGg-CL7VQFbFPCRXaywOYzQiIbjllrqVle22dNOn_CHLRUKj8PhMFFduTgIjt6wQLZGrnIdjhSABEV2fZWzL4iYro2RRB8lWi_efLll1-eOXMGPXT-_PkjR44oM3nnIblgVrnIThbYfEZIZIfBPi1JhcAd8IJz586hosL-J1xUwEV25OAiO3rBAtkauch2OFIAERXZErIzZ84sUqTIk08-qV-_N3WbIrDIIqxatap-_foZM2a84YYbrrrqqnLlyu3fv5_8uBEnNcBWx0V2ssDmM3Ii206VI0aMwAueeOKJMAamBqxbt6569erXX399hgwZ8IIKFSocPnw49lmUwEV25OAiO3rBAtkauch2OFIAiRLZQT_86aef5KX6srWuqv7tt99-8803tKby77zzDiq2SZMm1jgJPZIEkeymBSI4CV2BfgGQdvQFD_uSNNUtQFhCBqhBdaS0fQObdlRYWh8cOnSobNmyuXLlWrBgAcUIPR9--KGMUUm9ibcWfv75Z_sCt3LUhboWKEMLjA6bgYapq73XZ4DqxUYq0I5KxgebQFpWmquL7CTD5jOBIhsKgdibAFgOJc6dO6dpN47ZKvTs2fO6665r1qyZboNrLYKpZTHq66-_1tMwCsk2_ZQ1j-y8Kk8RnURRcVJX5Vt3KmykpXz27NkrV64M-dHWW7Zsee-993hqXVsvgirKBbhq7Naavg9Gj-YjPNJTfSnl1KlToez_Y-1FZzVRcJEdOWgpkyCyKUldY4JgvAKwnacKjGSKEoAoCpQpglFM_YowZFLAXFWUBhBJ3VFAZSxfCfmXIL-jGNfjx4_LKmygljKN1dxaF3gft3pkWwNDkPFyFj2NGfkvDqLGZQ-OoEzLsYEA61TTIq-hAAiOIhg0LgH6VdfARbbDkQJI7JtsPNO-wQkIPdTS_46Sw9s3LoDiDmU2bdpk-QpzaoQQo04tWMgA29cHDRr0xhtvWDgApAlDwRwUiUU9gfCk9q0YnWqMwSDLZnzVVVeNHDky9j4E6qpksEEimo062LVgigpY9ASKg7RjBUxhACxRGCVToVajDrYQBlsdyijN1UV2kmHzmUCRDXhqkw9skllBkwj2_1zIVHnS0GDbtm27d-_WI8GcQkwQbOcmAdm4ssR4ATniSTARtspqB0vMQsvhyhkglBfDNOVj28KFC6---urBgwfrETh27FhsKgQKY4NGoXbs21_0Tkc4uLWsfs134v4NRhjJaYGxBI2UikosXGRHDop4SRDZwfCrBKsv6hrztehyE2Js-fLl8-bNq0dAZKAdMU3bBCXFIm6DsVdpSqpNg3Wh1kgcPXo09CSmZVpTRfUCSFsLtjFhNhtltmzZ2DLSpUvHVCxatEiPgr-XRSOaHxD8v04aNU-tQeZEJclRC3iBjSumxP91FhVmiqx9QEX5TnywEQEX2Q5HCiCxItu0JhEkzL2pK7UNLIEnmzMDyhC_1Ii9G6B323T1iACkuFy9evVixYqFnsRAYYuAxS5OADI5IhBxLK4pPBE96VFN0a_1cuLECVr49NNPiZjvvvuuNAFmWLhUTATYY9HHpIO0MuOifQVoQWmKUYXuZINgLZ88edJiKECdaM5pDfOCj-LCVoeSSnN1kZ1k2HwmXGSzTEEiAZZMK06ausZqyigT-hlzBDggglEAxvJUIvXs2bOh5zGgKXOc4sWLV6pUCbZTXm2SNm_FDUlbg9yK8F988QVXoEdySdrkqbXMo1WrVmXIkGHOnDncisDBrd1gHmGQJQbpElpW41w1A_JoixuYx3jDujDa04uqJxYusiMHrUjSvi5ilIYAkDZsy2Ddgy1A0UyZMmXMmDH2_pcjooAZ4gn8UUKUAyKnxVsZbAc_MV9mU0Y9cvwLemUwLNMsDaq8gDqXwu7duzdH5XXr1o0fP37Lli1BrgbLC9qeGAI9BgW3-QLVLc1EWRojeYQZJMxH1D4eGuaYlwZda7zARbbDkQJIwneyg5EFSFXI8wlbRAoFr1GjRrHtVa5cuVGjRqhAopKEJn0pnJUpU2bw4MGEqpYtW-bIkSNPnjzvv_8--YCSTz31VIcOHXLnzl2gQIEXX3zxueeee_rpp1999VUVADRCm7Vq1br66qup3q1bN0VkYqsi-913300VQtXDDz983XXX0VSdOnUoQ8UZM2bQ_gMPPIDIvv_--19__fWOHTu-8MIL48aNU6SeOXNms2bNbrrpphtuuIGKTzzxxMGDB_UiRAWwsGfPnrfddhtm58-fv0KFCjRIPtBkon3r1q2bPn167H_55ZeZWKZIU6cWgM12AuNmsLzSXF1kJxk2nwkU2bYNGyisDV6PTBOwZ3PlEUzDCwoVKgRVqlatCq-kgMGBAwe4lipVihU8evQoi5glSxbE9MSJE-VBMLlPnz6dO3eGYLly5erSpUvXrl07deqEF6hTYeDAgRD72muvvfHGGyls9kuC0CwVDx8-_Pjjj6Ng4POdd95JPgbjfY8--ig8xwsaN2780ksvtWnTBl-bOnWq6uIO9913X968eWkcnuOPdsqVizEWfKdIkSI4IC5Wvnx5nIJ8AXEzduxYjatEiRJ4qDxIo1M0oCMjalCIJBYusiMHRa2kiWxoJsTeh1xDapIrTRHKrBHSH3_8McsHwYJHQUVOFROFAL5m7gaIfm---aa9ohasQPD4auEXyI_MmygmU80kErIW37nnnnvQuBTGHqsCGIXmBNtMuFNRUdreBPFITyWdg10oIchUM5IqYZ8sCRRQp8FJiAsat_ZdZDscKYBEiWz58-nTp-WfChnEi3feecc0Cop21apVNLh69Wqi3muvvcbpn12chAoIx48fz549-7333svuiwShOmXy5ctHIMAMYlmrVq0ee-wxyVykAGnEOgqA4CKZgkSgCgICad69e3dKNmjQwN4jgpo1ayJZ2Hpr166NEGnbtm3hwoVp_MiRI2-88QYRs379-rRQrVo1ZAdyHGMQMar7_PPPIzjmh9CjRw-K0YUe0Ttht2HDhunSpaPW4sWL582bh-7p16-fKQamNHPmzKiK2bNnM8NUZwhMGgEXJUG_hw4dIkyvXLnymWeekdqwSBo32BlsdRS-leMiO8mw-Qxp7AS9yTbgCywohYEkKXITfpJA0UKAhQsXkmZd8AIkIActpKq-9WGaA8EBTzjs5cyZk0Vs3rw5VClYsODevXt5un37dg6KgDLXX389epfDHrSEM3SKAaBv374cAlu3bg1RYSAl9bVvHkEwiIoLcNBF36PyOfdCe_yOAih4XPLBBx9EoNMpxWhZjjZy5EgJIHx5wIABSO1Zs2a1a9eOYvpWiRwQ9y9btiyZDHbFihVz585lBmC7TQjewZBxPXwEX8CREfrkgy---AKT9OUZND0uJikDqK5EouAiO3JQtE-CyNZTpKckKdHPhB3taPsQpCmDylUIa__gwYNKWF0kqco8--yzONGnn35KOrgLiKtAmRSW_RhAFMUTgQlWYOoWBNuB57iD0jRiH1rKDZUP1A4hXe3I0-lLRtIjVYKPgObEDg8qyVMdwtW4HIrGBaUpQ-HgNMYFBdQgcJHtcKQAEiWyLRRSkqCgMDF58uQcOXIsWbKERpCz5cqV0_sANYUnoxiIUOyy3Oo7mjwl9pEJUAkKE6NHj-aWdkirDNd69eohwZWjfpU-ceJEtmzZEAT2iuKpp5665ppr7EvPGFO-fPkMGTIgDhQQaRkxbW_LiHfvvfceVcaPH88tYVEGE87YDJRWd5S87rrr7rjjDtKagSFDhqRPnx5hrQIyTHNIO-vXr2cgaAv9RANP77__fqwlLSWBmq9YsSITSIFbbrkFC5VPI_QFSF8UtjqUUZqri-wkw-YzgSLb6AdjTRQKkIENbO3ataShGQdCo3ro-X8-_vhjWIEO1i35on2MD1x1FUJTZy1owy1bIGmoKNlRrFgxeGIff4shPEWjo2KRF7bN0zXVpUUYCPm33norOahzFYAn2GbKAz7jBTfeeOOMGTO4xSrMsNbkOLIBz8ILGjduTBpq0UKvXr0yZcqEBKc8JpFDa1IDZ86cYSNH9KCeaZPyGFO3bt08efLIQynJI3I4SOzcubN48eI6316C_JeGi-zI4XJEtnEYtkuzwhbxCojzxPBatWo1adKEONmwYcMOHTpQUZFWJXGuJ598kqY48kEVDpwEbRUgc-zYsVCRFuA5LIJXXbp0GTp0KLyiAL3DTA51HPBKlSrFKZQTqbS4AD-nT59evXp10sOGDePMCW85PW7ZsoVHuC1nWrbIXLlykcl2yUbGngX0ippiZMJkPJGKCPE9e_aQj3kU0ABXrlzJ4TZ__vyFCxdmf-zUqZMcUNdly5a1b98eHwePPPIIs2G7GJMmj5CLKZM4oCXgqsQlwEwCpV1kOxwpgESJbBA83IN33nkna9asY8aMId2yZUsiESFAUZUQQ6DBk48ePUoAQguSqT0YHDp0KGPGjMQ73aI4Z86cSZTUd0MtuJQuXZqoZLUADWInooTCixYtIvqgZrCfqEfOggULLH6VKFECLatYbK9AAPJIDaJKqYLIUL5EjwED6IiIiXIqUKCARLZenCBqkRd698A2IFFCs_ry35tvvkmza9as0axiQJ8-fcjRjwOqVtOmTQnZpJlPtAuym8zgMC8KWx1sU5qri-wkw-YzgSIbYjOrXFlruKFMFhFlzDkTAvMIUVu0aFFt8ABuwCuwefNmtOzgwYM55mnrBUhMjnkPPPCAbin84YcfQhV2ZYghJtNR5cqVOTGSto0WL6Avlp7Cs2fPJocDG1QcMWIEMgI9JE6C7NmzlyxZkgRVaJArB1RuGSZpEh988AGN2De1yKQXGgfcYjkC5dixYzt27GCMVapUUTGAR6RLl-748eO6VWtA7aNFOIjiBbRAU9iDTrr66qvRN2Im88BcoYy5nTdvHgIFNWOtJRYusiMHrWwSRDbUZfVJUEuEXLduXbNmzRRFh4dAzIS3L7zwwqBBg9DKWbJkYR1DtWNA8MTXYB30aNGiBSoZtUo0Fu110O3ZsyfKmFMomWj0qlWrItZr1KhhXMLL8ubNW61aNfQlEpzAi0doI4OEWIK2pi69syUh8WmQxLZt2ygwYcKE--67D5MowE7HIZO-YP5TTz2l3vFB_Be_xnM7d-6cO3duDNDrFcBcvfXWW9QlkwHiZa-__nrbtm03btzIUxxt6dKlOGylSpXYhjCDjbJChQpMmlxV5wG5dvPmze3PprUEKqac-MDogNIush2OFEBiRba2eR3i3333XXQD8ZE0J3j2YL2BU2v4vwrj20QZpKcCLldpFAKZvWADEydOvP7662fNmhV7H5IvbMNEdt1im0l8og8bNs3q962VIAhOnz6dlgFlypQpQ1BWeYBViBuLLEhzwg32E6zD1C0dEQT12T3HhmLFimEYUVKvVWincOHCBFPSFuNM0wBCPPJCVgGECNcMGTLoZaHAGaN48eK0QwBFExBnn376afIxT8ZfFLY6TKzSXF1kJxk2nwkU2QIFbI0QlIgPhOxLL73ELV6ASmBT11PpVIGlgQbsuKydlo-nLDde8PzzzxuxJ0-eTLEVK1YEqYUsQEOQlgfp7ErioYce4oQWQ7KrrqJfrmzScI-jprhKF3gQGt0-nFFHsl-tsbvny5cPqa02g_TbsGFD7dq10TQ0i8qn_SZNmlAAf6FwoUKFOMdSTOdYoLAg1KtXj_NDyLSrlMAFJLs1NFo4efJkkSJFOAlzu3DhQspAZpuKRMFFduQgYiRBZAOozlVflYZOLDcyl8ypU6eim1ks8sVDaVYOqNWrVxdD7FNHZC7caNCgATsClD5w4AC3KFoVozqZXbp0IZhLGWMVRiom8-juu-_GTQj-6og4THXUs06DoE-fPkRghPjBgwcZIMXYO7CWR3qpTF02F_Q3VJeDmB9RWPOjqcDIbNmyqSOu-_fvh_w4kWZAJslfNDO4Fa4dExH-_W-ejho1CtvYmHgE3nnnHfyaDZSBs1fWrVtXOtsmn2FqOeIDZVQYuMh2OFIAiRLZigtAIWb16tXsspzsuSVoEqf0lVMrQGsEmj179hA4-vXrZ7oBEEDZcVu1aqVbWpa8QLhzS2RUPhIBMUrCXv7xiDiIskf4UoUwjbjcsmXL5s2b0THa_ilGwKKiBLpGJwWgUK7EokWL2PinTZvGLRW5YiHtnz17FtmBNNH7BqozzGrVqpFW9CRU5c-fn4QmhKsMlpGPPvoo4X7JkiXEMvZ7gjWREdvsQ0CgLw_07duXgNupUyciKQUUfBWILwpbHXpUmquL7CTD5jNRItsA0-ADRIIed955J6uvT2NYEZ4y_8Gm4CePhg8fbkqUBCoTBnbs2FElUcboY4ohaIJit3Tp0hUqVND2zy39iuTs-hSeM2cOREVebN26de3ataRFZqFgwYKcD4OtiWCWw6ZLI1yVw3BUnXMg8hoFrNdymMotTCMtMzhnkkNCYkiZqktaf1WMPahqHGHfvn2cPaCoLBfef__9TJkyDRgwAD4_9dRT-NSqVatinyUSLrIjBy1ZEkS2KKEgCRMIm7gJabzghhtumDRpUkyhECFVhvJ0AcegonIEVDLlYaa6w5506dLp-_3mYi---OJNN92kTyzNKtrBHZC5eoUhwGQ0t94N0TUtwEC4SknCuNxTlqsAV9ohRKP1SatHcx8DXoAUbtu2LU3hyDTFEAYPHnz11VezOZqdPMI8ucm6des4vvbq1YuSlKdT9gVO7AQQbSX0zrhKlSq1dOlSdofGjRujyPXXO_TF1c4J8YG-bDZcZDscKYAkvMm2FwzgwIEDZcuW7dy5M2nUKmFOnzvTICXlxuyvxB0pD0FKFyXapk0bEhKXbJBZs2alEQuvxCOUbpEiRezlFiVlod5GsLMqXx0RmKTjFRk599eoUYOEbQzAIgtYvnw5Qv-DDz4gTcuqyySMGTOGxglDCrXnzp0rWbKk5AVg-MhoJD4hksiovoAdA_Tho95GKBSC4Es-Iiljx3iMGT16NDoD8aExxo10QdgomCKlubrITjJsPpMmsqEKqw9JOEThBbACFrHuCIK5c-eqDKugA9iOHTsg29ixY5UvUJfV134v-nE2gzyspp7KF8qXL48XkAB6Ra18tvAcOXJMnz499CR244efeqqBUFHf8SBTBYJPsQ0FgA24LW6iRwAy0ziWcEKGpRw7eZQz9NeZKkBmixYtKMDOzS0FuGqk8oi3336bp_otYfqS38l4QEncB-FC_OH2pZdeYiCaNPvlwUTBRXbkoLVL2ptswFpzTrs1BCL__PnzCxcujBjVU4uQEIzWOE_WqlVLOUB9NWvWLFeuXJAH_6IM5ISx-qohjYtvEsqrV6-OqRbyAtlGkCefAyF7E2obyZsnTx5y2rdvb1_q6Nu3Lz7LPqVbgDFAvQOaosAjjzyiWzqVGaRx0oEDB9J-xowZaRygm-UOoEePHuQg_XE9eQfN6hGNT5kyBUtomcjANV--fNwCdmQK2M7SqFEjHnFYPXr0KFskPNduon3z0sBOoLSLbIcjBZAoka09Us7JVVEAWZA5c-ZJkyYRdEaNGlWgQAF8WNu5WtMfAvbu3dsaJ9RSnUx9F1laVu_w5s2bR5pQThyhzJNPPkmmCgCTqliSLVs2xAdRFXUikwisp06dUtdcS5UqpTdtQAUEBqtbhAWNS_cExz5x4kTy-_XrRw7QK_bq1aufOHFCE8VGTs4tt9yir8cAihEBeQrQJURMNqQtW7bwSGcSDCam8xTJjuhhXOSjKoiemGFbArDYGhf0ooRtAFxdZCcZNp8JFNlMafApt9AGLnHdvHkzfNAnOSNHjsyfP__WrVtZJlsFnALOvP7666RjNvDQXgsZyHzooYdCRWIwYcIEcvSXCUDF6tWrlzdvXu3cOqACGAXbUQwc2PSHXKdPn9YbMn0blTSGsa1WqlSJW9SMtnkDT2lN51WdjYFcA8MksmUwo8ZNrrvuuvr161sj7ProiTvuuEMfYavrQ4cO6RObDRs2UB2vkeRV6OAkqXdvVGFE-o4Nuz5eIMdPiG64KFxkRw6iRBJEtthLGWh29913E40JiYRHDn5t2rQxJSpQDGqVKFECLa4YSL9UJL9GjRqoWHM9Mq-__nr7SwZARf3F8K5du7gNWqVtBX2M_UTIpUuXcvD7-OOPOfSKbFyffvppysBJbTRiMm3q3EsmZSiArDd-yhhKVqhQAfa-9957FKYK42JjkgOS07lzZypynlSbqqJpAdTi4NqzZ09MWrx4MV68cOHCVatWSe6rL9IMv06dOswG5TkqdOrUCc8NNfDrYCpsNlxkOxwpgMS-yQaUUXmChU7zR44cse9SE7-4pSltqwDlh2-zWwff5rKLE3P1Y2Tc0qD-5Es_fMatAtz48eOJpxkyZGjRokXlypWbNWtGyFMIJmISobJnz16xYsVHH30UiUN60KBBPAIE4po1a1JFEQ17LLTROE9JEH8xDElNWmZwxezt27fTGsaUDf1CWa1ateg9S5YstWvXZguPaSL0B-_kZM2atWrVquwflERY06wkCKMoXrw4dZs0adK8eXPkfq5cuZYtW8ZTgqx6BNLZmkygIdtr-7iw1WEsZrCL7CTD5jOBIhsWASY2bpljx46dOXNmxYoVup0_fz5qkuW2kqxO4cKFUeFUZ_m0nXMwQ4537NhRZWgckY1fyAuACq9cuRKyoWihEy7Acuv8RuOsOxxOnz59yZIlW7ZsCRthHbpZvsY-CjPLlCmjk565AJBhWMiOC3XZv5Up1wB4qPhfrlw5pDyN4GWZMmVq3LgxDiLv5jjBAZsyZMLzQoUKwXNVJzIgF3Be6tLCXXfdhRcgETiy8hTFr4iBSZyTmRzGHqr3f4xMOFxkRw5JFtkKaAKS-sEHH0SS7t-_f9OmTRCJHQGXgWY8ZdHVFCRBU5rXADylYcOGOXLkIJPeuaUpdgT9XwLRBrZ369YNHgb_wB2Okc-RDxfDL8jRQNSR_ctJ0Ldv36uvvtreqUvdGiGpRZrGu3Tpgp2K8IBiKGDiPP5LAeI23T333HOQ3F6KDx8-nIpDhw7ViGxPZGbYxfSlwQ4dOnBLa9aj5gTgRHfeeSfTzpCJ7QykV69eeqQAAi69BDy1Ai6yHY4UQGJFtl5TUUx7IVsygQ93tXiK89s2STwiTTSZPn36mjVrLJMrxSZNmkSmBYuTJ0-is4lTMoZmlU9oGDx4MMFl4MCBVKG6dAAtE3oQqf369WMUL7_8shSwBQs0tL4KAqjF6MwwhTOE0dixY_WbxGHS9sCBA9iMJEItccsAhwwZgjhmLNipowVlUDM9e_bs0aMHwVR_cwP022309c4779BC586dSeiHAoEFUIM-H9eg7E3JRWGrQ-NKc3WRnWTYfCZQZDOlhmAxWCG66vgXBEyTa7C-77777saNG8U9uQm8gmbr1q2zHCTIlClT7NMPMZYq7Iv9-_dnm-_du7cOaVBFxVAqsBT-o1rwFLoIOiN6XYo8DGoZoDbYd4M_EkIteTSyA2O6d--OyucRQ8YHOQZosBQjQUCA3uTjg7gDvZMfaikGGDl69OgBAwZwKKUiozC_pgucjpnUraDwkgS4yI4cWCmuSfu6iJZb4pJj57333tu2bVsyd-zYgeDTdwiDIZFDmv4Q1gD5OcKhXGPvQwo1Xbp0Etk6TAKcC8EKxzCJKqaYAedSHk2dOlW3irF6j07XlIecFJA34cLmGgZyKMBGqeFrQmgHtqPOaV9OTSQvUaKEmsLfqUUib968lEFPU4C-QEyLv8zqbbfdxlP75IqdhabwaG0xjJEC3LLXVK9ena3E3AdoyzBnvyiCPbrIdjhSAIkS2RRTNAG4qGpZFW2Q9qcYkggKAZSxrdd8W2qbAtYCZbg1oakgAuhIO7q9fjA1oypKU4weKRYWdyxoYnyYDLK-sIqnlAwWkGHEOI06-JS07Q0MhDIUNqVOMRsmXSh8G6TCsdZ2AkV8YLUuCpsoeleaq4vsJMPmM4EiW6AAcxt3erX6tqbwX02Zy8ATq2WZLKXSlmOclMuoiigNt7klTa2YEiGmqSOpDQrQCy2oAC3oBy6DezPgqTGNfmmEHPljEOaAPOJEqgFS0ZQN_dIF1SmgwdJO0EdoAYT5I_aYR2AqdWVMmJGJgovsyEGrkzSRLarAAfkFARxFG3oS8z1DDm_S30AMpIs6depwCy2hjThZo0aNwoULGz0ItpkzZ77nnnv0lJLURbUjcPPnz9-gQYNHHnmkbt26-uSQAtu2bdPvx-t7ei1atMiTJ4992wQC9-rV69prr0XIcit7NC6YLB_EfqqwUZp3mzEcANKnT1--fPlSpUrRBWEEU-l99uzZWEWB9evXYxhKGoH7-OOPY3bp0qU5l_II8zZs2MDoaKFMmTLt27dv1apVztBvWdI-rsGcb9q0iZI0xbxhBmnyZZ6E-KVBSRUGLrIdjhRAEr4ucvLkSYUeYoQpA0Ba7RCnzIEV5oIJg8qoStx-CSvqRQUsqCnQAIvOBB3bswmLKq-6IKxfu6WYdapM7Dez48IKE_rVBdDmERwCG0DoSczuwhDCGpRMCX5SCQ4fPqy6eqrQfFGYDZRRmquL7CTD5jNRIhswt0FnYZXFRq0-ulYJIyElRWD5i-ULYRSlcJAD0NtYTSNWmDJkhjUFZBVVKGB6l1pBPmDGRWlmZYy3Spj3GeyVM4_sqSaBxtn-Mczciqtxm-GQAJRRAZxI_ap60n4q20V25CAOJEFkQz8jEmHTlt5Ct8HeMowbN276L3_IC1R9_vz5-tUpkRYD3n77bdbaDnsCInLAgAEdO3bs1KlTjx499H8JVIWu33vvvZ49eyKy9ZGLvtEhnbp27dqRI0eKxuqRWmFeOXz48AULFojMeqTeMebDDz-kzaFDh6rNiRMndu3aVaFYZc6dO4f9mIRtaGV9vmq-SfyHtM8999yjjz5KmWnTpun3Q0DQgzTtNmTzHd3GBxbI1shFtsORAkiUyA7u6LgooCJVlC-3tz3SnJZARlqRQo6tcGZvgqUh1HUwtKkwFZVJoLSnCp3WhUH5QHWBbOPWqlgtC_qCjU6Ri2IWB0nzlPI2P3pkVTQ6IfjeTmk1GOwuuP0ICvdm_0VhvVNMaa4uspMMm8-kiezgDNtbN4H1DS4lSy9hQT7ts_SqG6QK5ckUK3AQEkYqZdqGqpb14QkJGpFDiWBKU8aq0zUtg6BJ3HIlB7PVPq3RpqoDCEkL1illlEYuy3Pp1xwEcNClTTVlkA3qC8hg2jHblNA8cLX8xMJFduSgNU3am2xAeVtWKw9XpRcVQi2QArUvMovbygFwUhy28uTIPJ3ihKAngqAWDz5Ss1yVSYLGjdJms3o0G1TABkIxlVS-DLNegg4C9FSvhKhl_ZJQ_Dd3s1OHymiMGggzI2PU76WXgKdWwEW2w5ECSMKb7LgI7pq0oEa4KlPfjgDECytmIISpPI_k9iQUWSziyDxlEnZV_rcB3QU3AKyVwbJWJmk_CIunkYAN3CaNq4vsJMPmM4EiWxuhroCSUodBfgIRhkwYwr5onL_MFQmqDYNYxyNZkmbhIjtyUFhOssh2pCBYIFsjF9kORwogWUQ2QPYRf2NvQoKDHDWLDjBRSOJC6If6Q6ViZEqwR8vHkqDnS6aguYkLUrcxhSIPk0eC3WKATJV5GrgZHznYXLnIThbYfCZQZAt6EWUkZC2UIIfjFjS4xMzTePCVWwIRH7XoKOwRVPzNvCNVwUV25CBGuciORrBAtkYush2OFEByiWzhhx9-QILEfaeLPv4-8FVm64WEpfVUgjX48phYEPaWjpIUi_vFvggBHcOg0E9YYtYKzBhPZfNvAOvdRXaywOYzUSJb0PTqAGmEDxO4tgQQ-OtfvoKcBASbpTtADp1CPxkA9DTNvs92kR05iH4usqMRLJCtkYtshyMFkCwi27zUNnvaQVWgAOzPsQXyrQzgFighYU0Q1wtj5RMIlBCC3677DSCTsEEmGbjV60wDJeMGqWSHTQVzaPPmIjvJsPlMrMg2VS16c6vZjlG7IXpDfk5lYacviARibxKJMAYGF5ceeaqcJOv4aIeL7MhBpHWRHY1ggWyNXGQ7HCmA5HqTze4ueQG-_eV_sgDpj-8DPzrGUzJDeiP2jxEFvRJWPrfI1q---ipMplBRRtLmb_AmW1-2FtD3J0-eDNM6AvYEX71HDrY6zJvSXF1kJxk2nwkX2bAUMp87d-6iqldUV44BohqR4InonVjQSLBHnTblHXIEeRzGp811d5EdOYixLrKjESyQrZGLbIcjBZAsItu2f6qbbiZTr3vVOArVvJpigAJWkYQkNfJl__7958-fD_7vLuHMmTOnTp2indOnT-_cuTM2N5KQwZiqW-HQoUP69zHkUwBgvEpGGmaJi-xkgc1nwkV28Kn0tDhstLfEkSNHwjhM3SQfxuzduWCHWBD35wKVSFNwkR05KLi5yI5GsEC2Ri6yHY4UQLKIbBQAFQEKA9c9ceLE7NmzO3fu3K1bt4kTJ86bN0_FpD-C-sAc-9tvv0WUXH311VdddVWWLFm4Fi9ePPi67sCBA2yi1157LY8AJQn6oaoRhLo2fYP9CxcuvOmmm-rVq8cY9VTgUfC1d4Rgq0N3SnN1kZ1k2HwmUGSLCevXr0fJkdDPjNg8a9O6cOECvD179mzHjh0zZ848fPhwuK0CIEj-hMNM4my5aNEiFnrp0qWYsXHjRhL6X-52Xr2E_VcwXGRHDi6yoxcskK2Ri2yHIwWQXF8X0Vs9qk-dOhVPvv7661GiDRo0KFGixI033ogkRRfSvnS2QNpuid2U2bFjBzLiiy--qFatGlJbj4CkCTsoj1Db_fv3z5Ahw28gss085kdp9A0Sv2TJkspHdYV9jh9R2OpgjNJcXWQnGTafCRTZgJ2J2S5fvrw4GTxoSUzbG-XmzZtzFOSQSYPUsi3NEonFmTNn2rdvnylTpuuuu07nzPTp05OoW7euPgWSf4moaQ0usiMHMdZFdjSCBbI1cpHtcKQAkktkA-q-__77yOsHHnjg7Nmz3Gq_X7Vq1TfffIP40K31Ym-IpU64mp-jG_LkyUOCKioclCbvvvsu2mL-_PlBa4OvFdWgtQ_IlwrR-2YVBpTUv2xU-51D4NbeOOoLrzylItUZhY4T-iE2cvSUq0FtkpDekjGAThkOLcf92m4CYeO1aeHqIjvJsPlMuMgGkLNAgQIkrKQ-cmFZtb6kRQlybK2Di6JM-y0_8QSCqRaUu_POO0eNGiUCqwqZVgwmUwC1TSL4-Ym6hgYcbrdv307aXEB1gVqjpOUAVaQ13TIupUVjulYBQL6MZ6RYa-2TTy1y-vTpQzyxfH2VRSDT_sWGgDG0owRXeaUcjYR1pKu1eVG4yI4cRMvkFdlU1CqLNiR27949YcKEQYMG9e_ff8mSJfpCoPEnrCPd2lNFZiWUw62YI-rSi-KwjDcE3UegFplqX34tWBhnHtjjhg8fThoXXrFiBaymivETBm7ZsuXEiRPmNUDGAIppvIBerJa5Bh1ZYZo1gy_N__hAFxoLcJHtcKQAkkVkU0txoWTJktmzZz9-_LiFPwKNAp_UKiBME08PHDhAmn4toODz5ucJFNmkaY1wpnyV-fLLL0-ePGl_mqanFqF4iiW7du06ffq0CSCgIdSqVatUqVKK15SUbaqrgCtjTB4BelEBhkxMZGhIE4oxFmywEQWDqf6tuhRMoqDegU0LVxfZSYbN52WKbKYaGkBF0iZeoZlt4SRYMlsRKvIUF0AKi2NBRm3btu3GG2_s1q2bcSYoiMmknSZNmmCDtU912uGWp0uXLr3mmmv0b6gBTmFaQbShGE5x9OhRGIsLBD2LHA2Kdii2f_9-ObI8RfZg-ebNm-G2mqW69AGNow9uueWWatWqcWuiRFLD_lP0oUOHaFb_lZ26Gpqmjl40RXRE-7TAVfny5UvARXbkIIYko8jWXgAxjMCLFy_OkSNHzpw569SpU7VqVQhMHNZTuG2OFoQysceYpv96BmPVvnFGt0ADgah0LfZiP7dc6YsznvmC9SgbjIGU2bBhA7vP1KlTqcjumTlzZogXKhvDW4hdunTpG264Qf87HfPoS-5j82Zs5wq4lZdZSfqS11DYRnHRSfhV0AJQ2kW2w5ECSBaRrYjw8ccfE32effbZYGZQPYAhQ4aUKVPm-uuvT58-fZYsWYYOHcouS2xSKDE_T6DItgAE1BG98wgQ5h5--GHb2gHtzJw584477uCRyuTLl2_UqFE84lTQvHnz--67L1u2bOTff__9DRo0aNGixZNPPkm_BMFFixYVLFgwa9asmTJluvbaa7t27YphgLoKi-iMPn36MKKrr746Q4YMqN5Vq1aRT_RkdC---GLZsmXR1m3btqV9ijG6oG0JhK2OTQtXF9lJhs3nZYpsAzSAPLAItmTMmDFv3rybNm2yYqLoxo0by5cvDw3gEmUg4fDhw8UiNr9GjRqhM3hasWJFOAkPaXDatGnmTeJ8_fr12S-VyZW1Jv-dd95p2bIl-VSni3r16sF2cvRHEZRBjkBLiRjK3HTTTbNmzVKzsJQryuC6665bsmTJjBkzKCBPkVwAgwYNgmnkyAtKlCixZcsWPYKQtWvX5ozKGZsC9957b7NmzZo2bdq-fXuGJqWyfv168tU1M_Pggw-SKatI4GW33norTrdnzx4sZ1rwIwpr0oDcLT64yI4cFHuT_esitAPrSECAu---G8aSw3ZAmxyuli1bZjGfTAlliCQucUsmUKZkqzmayujP7m2PgG-DBw9WSUDXZrxVBIhvMc1KGvH09-7r1q2DwJMnT8a8V199NXfu3Nzi-LSGVbNnz4bb5CxYsIDC9pEpYFBqyvqlvI2RQy9Xs1ZDACqgiUoC6Mu6c5HtcKQAkvHrIs8__zzyAu9VQGRzNb8l3pEeP358oUKF2IzRgjt37nziiSe4RZuqGBHTyif8TbbUiYAoYe9fvHjxjh07EC5oYnQ2EVwBi6iHuKdlzEDvspdPnTp16dKlCnzdunXr3r17sWLFcuTI8cYbb5DGMI4EPCLAHT58GDnCKQK5gzBCuMT0F4JiPWPBpP79-584cWLlypXIhZw5c1JeZWiHp0R5dqmJEyeiP7Dkscce09OEw1bHpoWri-wkw-bz8kW27cSIAzbg999_v0OHDiw6PGejtb2TLRwO4AIs1v79-9esWQOvOMKpwN69ezklPvfcc4jLmjVrvv766zDq5ZdfpjVVt72WFmQDMBdADcPbe-65BxH8yCOPvPbaa7169aIR1K0KbNiwoWjRoohREocOHULBYyH-wiOUOjbMmTOHHKQwfoSb0GCRIkXeeust-sXyYcOGjRs3DseB5DzNnDlz69atT58-bR7EYRKphGFIXtJYPmLECNl88uRJPKtUqVLEhwMHDtAmfsRBQp_n0Dt-Wrly5cKFCxcvXpxzBXqI6vgRT2nfFE98cJEdOSj2Jq_IJmbGpv7zn3379qVPn37o0KGkdW4MJvR-GnKSo2Arruqp3gFLT8MTwFOA6pWd8IpMtiT49tJLL4lv5GhToCSjkweRA7HjGxHFsJME3srhkwMtLRN7GzZsCLEnTZqkET3wwAOdOnXCAXErkZZ8fIfGuWI2XdMF5tE1T7nFTo0Rz-IqA_QUyH1McycWtKYGgYtshyMFkIwim-DCDr1t27Ywd1Vco2U8HOlJWCSykMOVPfWmm24KlUqiyBYIUshlMvVmjioEKbZqdLbCMaGqZMmSWbJkQdyEasSANtUsQVYmlS1bNm_evIpoZCr4GgjlBEcMRj_RrH3fg32dCH7fffeRRlHR9cGDB3Pnzt24cWNGxC3Sh-NErVq11DLtcHvLLbeEaicCtjo2LVxdZCcZNp-XL7KBdlmBR4MGDUqXLh1a1gQBYGNmh27Xrp3EgRCsCDgiwmR9IiR-BgvISdnaCxYsaPxUMQG_oPr06dN1C1XEbZh511135cqVCxsAOV999RUlEcrayOmFDRjz8FNEiSTCq6--am-ygfky7EIio7qUT-OyARFPdRJUxzzIr-FzcqAv-xIL6NevX_bs2efNm0dT-AUlkdd4KPkqsGLFii5duujEHhzgReEiO3LQ5CejyIZvQaeAVATq0qVLnzt3jke0z1MxSiSESDNmzChRogSHT0CCW5FfJXfv3n3jjTeOGjUKApQpUwamodo5XqJrCYlt27aF-WQSulu2bPnYY489_PDDqGQoZ2PhUHr99ddjRr58-TguEufJ5ylOAeAhSpoWOPoOHz6cxNSpUynwyiuvVK9enbrEBLVDC3PnzqUAV3LA448_TqgnFJDJubR9-_bKZ6S4YYUKFSA8VL_tttt4SvU333xT_qhp1wwoJwnAJKC0i2yHIwWQXCKbFiSy9-_fz619yAu0MRO2MmTIoGAE9GWJ1157Tb8Toohpfp5AkU34Q6woXtevX5_MJUuWbNq0af369Wy0nTt3Jkef8e3Zs4foeffdd4caiBHl1FWaUGvpKlWqEPUwxrojTPNUMU5ihTZpOfQwFsRrMhcuXIiptKZMNFC2bNlI0ALDpADiyQbIPlGjRg2lEw5bHZsWri6ykwybz8sU2SdPnlQC2sAWAA2GDh3KkXLdunXasAX8gups53Xq1IEwKEhrxFhHa2y3vXr1Im1vsFhxKWPKgEaNGuEg0FJ7sPLlCLARwcEeDwHEWAEeXnfddUiQw4cPwxPEKBstR8pKlSrxFCMpP3LkSET2hAkTyAnjD7W4Yv_evXvff__9BQsWcFDkJInEId8KV61alY1clpApmzEDwuNZpHmkzM2bN-MUTzzxhEoCTqE0yK3AzDCo2Jtfg4vsyEGrkOzfydZVYPmQoWXLlrXDoSAiTZo0iaf33HPP6hBIcEumLIFd27dvR3w_-uijMKp3796zZ88muiJecR8i_4svvsgex0YDCTm7ytntvIeyL1eu3K233opwZ7NAE1977bUvv_yyngJOoTSL8mbPevvtt6W2x40bxyP8BYW9ePFiqhw9epQEkYFimLdy5UqMxztatWo1a9YsZDSWI-6vvvpqBLo2FFwSVU1A4Ojbp08f8pHjNL5o0SKeEhCYXjk4I9VUJBa0YGvkItvhSAEk13eyqcixnt192bJltIbOIN_iAgVWrVqVPn36559_XjmEP8pMnjyZ8PTWW2-Ro6-U6GkCRbYCkLZ5tlh6J5-KWUK_tA1QFVu3buUpWy-3HTp0II0x1hFpxTtMJeQVK1Ys-IJZLQvICyzBDNrR10kBOVTv379_xowZiVzKZGgUQ9AzNAmsV199lVrqiB65okWQOzGlEwNbHZsWri6ykwybT-27SltmfIgrsrWmYRg8eDCLvmbNGt3Cdr295oDXsmXLokWL8hRlwK6PbBU3YA6UpgDMQTGE6v3vXxCaC9AvGj179uykJeiVr8SHH35Iy2ylyqQwoFn2fvMLdvpMmTKhp2kEHtIFjMIFkM48_fjjjykPTOILyCzEPSeE6tWrQ29aQMrgNeqX8owCya7veJhVcqIiRYpw7CSNMcrfuXMnw2_atCk56ohzMmX01E4mWKUvAwQjQFy4yI4cNPPJ-3URENwjENwIVqgF_apVq7ZkyZJQkZg3uBAJDcp5la6VSYJbMpUDeSgPmZHRO3bswDzIjGYdO3Ys5FQV7KRlfI1HNEin8jgwfvx4HumVjXIgMDkkKLN-_XrSOvFSC0WOgr_pppuGDRt2_vx5DtJt2rSBq-QQhxHchBG8iX0HVxLz6U7fBgHsEZyfEf0IaGloNg7aR_KqAEodl9SHorLH7LREokAXQGkX2Q5HCiAZ32QT6QgZ-mNBchQ9FWhIs6eyK7du3Zpb24AJVWTOmDFDt-bnCRTZpLU9c23WrBkaYtu2baTplAh14sQJYjeBmLqHDh2iCrZZgyRs1FyVrly5skQ2TwmCJICCnQZy_Phxgnv79u0pr65B165d6fr999-nioZGp7Vr12Y2NKUvvfQSsubAgQN6eUOD9KJP1RMFWx0bBVcX2UmGzedlimwAx4zVYg7bPIsuwWffLIIPYjK79dy5cx9__HFoCXX1VNi_fz-Z-rqICCOKQhv1yMrWq1evePHiYiYIesfEiRM5zepFHeWNpez0NNuqVSvUNqai-Nm2uVojQJ7FHmzkV4IesQrm069Moi4c5lAaKvW_KFGiRKFChejXSCibsVanAqAeN27cSF_2oRAd5cuXr1atWroVJK_VApwP5V0cLrIjB7EreUW2KrK-8hopSG6ff_55pDaO89RTT-kfphLS0aziCfoVkOCWzE2bNpGmhT179sClAQMGcAu7RBWzDalNDgX0tzSiH6OQRn_ggQduvPHGVatWffHFF2j0I0eO3HnnnTly5CBBralTp1Jx4cKFMQ2FAMfI0ac9r7_-evPmzUk0btyYswHSn1nC2ZH7dsqlFyzEfRYtWjRnzhzkeLt27cincVn1wgsvmKmEhQoVKnDGpgogh5mR-8vaxIKWrXEX2Q5HCiC5RDbRgaveARAWcWAiiB4BxTU2UZxcsUOygwiVLVu2zZs3W796Wr9-fcQ3CdvspXEBMnfWrFlEYX2mBhSg-_bti7ZAedOCxQuqK0KB3LlzFylShDiOMepFNlPAypcqVQqdTULv54hrGgVVFNyJvBjWqVMnjQhQ4OOPP06XLl2PHj241buTr7766oYbbmjQoAESh_YHDhzItNjfn2HwbbfdhuzQbcJhs0SnSnN1kZ1k2HwmSmQj5kwvAjHEXlYBeAVzWBdYqm9PoWXNHUgAW506depwGIM28ETb3qlTp2CL6ERJZVIeQgISAB2AluVWj7gaZs-eTXWupOUaQDt0uXLlkMX6ppbpfvtmFy7GQdE8i7q0bw6oF_M62TJF5KMqaJBbfIH2uZKP-5BpTke-7OdcikfoT4HVNTKFBjkS6AU_QKBXqlTpV-f_onCRHTloBZNRZBupxBNIrlvlE2Nr164NN_r16wepVqxYASd79-7No5DrxBTmlsxly5ZpX0Btc0uYVRmuQeBcxGFE-dNPP62njEJdMxZ9hxtdy_Waa66hHYI5heUmTz75JJlbtmyxZnEBNppRo0Zh7ciRIzkhszXoL4Y5HuA18BkljStpj-ARGx-qnc1RH7c-88wz5FOd3umI4wT2MJMySd97jOkpNBbyKabdJwmgOlDaRbbDkQJIxj98BDNmzMiTJw8yFIXBrUVnvZEiCBKwunfvrpAxZcoUokmbNm1IA71-Vvquu-7Kmzev0gqIwdBJmKAikULWUoDr4cOHs2TJUqBAAbSmlO6FCxfWrVtHX7qdPn06tYiJR48eNWGxZs0aRXaaIj7ed999aBdt0igMtY8mUBcALZU1a1Yirx4pLNJ-3bp1ic6cFrjds2dP69atiZ4MMKZO6IUHXX_xxReMQmMvXLiw1HyiYKtDO0pzdZGdZNh8JlBk8whWNGnShMMYhz0IBtDExjH2cpv2QYMGseisi24BLNq4cePkyZOREcpZvnw5woXDWJDeNMXJE3rs3buXWylpAD9xKO3i7MSZM2fGrYB9I1yNwF76RdTqW9Qofmtcv3IDyfWvagBNzZs3T-4JUAZ4qH5vRNw2oHWo-9BDD504cYLxIoC45eCKPbElQsAwjF-7dq18X9MCqI6O4Wygk-3u3bsJFGXLltXXQpgZyiN39AXxJMBFduRgYTwZ32TDSerSsgluXMm4RIhGleoH11lTQiu7hswAJLglU9-ygKiEPsLy2LFjRSQy1bg2DhLcQlfitspTTJbTO6dcxDGEhNW4AzF8XwhQl8j_xhtvIKn1e3yCvkCiP3zs37-_vtqxc-fOokWLdurUiTRtUkBONG3aNNJdu3bVwRLhzi17rnY6LMFs4olNAsifPz9uhdnm-CDMGRMOhqmRAhfZDkcKIFlENhGEFhQ42KfRqYRIRADBgvjF2R2vVhePPPLIDTfcQIFcuXIRbth0t23bFmrjf0GEbdSoEWVIxGaFQNRT3JkwYQIbNqJZkYjQrCCFYq5QoQLNslvny5ePBGasXLlSIgPzhg4dSiYg1rDHo4MxIKbpXzaSJUuWFCxYkALFixfHeApI6ACNjr4I7s8995wmSi0DVEXTpk2pWLJkSYbGkJlY8lWsQ4cOBFMiOJOgKmxX-upqomCrQyNKc3WRnWTYfCZQZANmvl69eiw0W28Mk0K_GMD1wQcflKgVoOWwYcPIF73RwTrXLVu2DF4hZOEnDKcAshLv4JG-1yEe9u3bl5MqahU6Ub5GjRpiuH6jg0dcQbrQTxbgLNLZdCEH4YyaM2dOjqmc5dize_XqhYIhHwwYMEAGk692qlSposapjoOQqZ_oMdCmREnLli0pD_-5PvrooygMEmiLDz74gKcA7-AUIde-5ZZbMIBDrwbOo_feey979uxU1_fRsW3Dhg00jl-oI5wC76Mv3SYKLrIjB3EyeUW2veaQDuaYR7PB1giP1atXh5k8YsuoXbs2ERi2ABLckinm0ALrDqNGjBihuoA2AYX1UoOWKdCqVSvSdvAD-EXnzp3ZpAjgckDKByOA3gSNHDnSbIP2dI2nMBX4-L333qsu6EsF6JcCiGwkNZEfSpOjR-wmtPbSSy_plh651d_-CrSJjzz22GP4C1N06ViUEGC2We4i2-FIASTvm2xiBGHx-PHjqNXhw4cPHjx44sSJendFF9rLkc7z5s2bOXPm6tWrQ5ViPyUk9pmfHzx40J6SSfziak8pT4xQUFNkBJIRX3_9NeESFT516lT2-0OHDpHJoDQurgToFStWYADRUy8bgHVBGqlEGJo2bRrSYdWqVcRH65dxMUW0rzfWBnVNxYULF1J37ty5-kkToBd1GPzpp5-aGQA1rF9dTRSsOlYpzdVFdpJh85lAka3V3LVrF5sl7ELMbdmyZffu3Tt27AgeCNkgucJh8tkptQcL8IccxCUUnTx5MiQXgaU56BpJoePczp0758yZM3r0aE6t9EgODoKqoC61WGva3759OyJ-z549sBdKqCnt6DABrTxjxowPP_wQC-mXTOH06dMQm6eo3q1bt-KzJgLgDBswhQUeKV8fnTMuehS98QVyYB1N2W4t4Aj0juLBidavX49V1j5DwHhcb-nSpQzWnFd64sCBA8QKEyuJgovsyCESIhsu0Y5ahkuETW0TwpgxY1Cfb775JmnK4JuczaCTnpLglkzzLHyB8shf0kZaQRbCtBIlSnCexJXERv3PUdJwlboNGjRgX5DnAoK8PFp_IIHix4lIc_qlkRtvvHHSpEk87dOnj_0RPGBE7AUYkCFDBrYYmPzMM89QHTfEm-jogQceuPbaa1955RVZzr7AmbZ06dI20ocffpgCeAe3NEUt852kgeHbGrnIdjhSAMkusmmEhN4WSC4AfT6uyEJfFssoYDHRCsv5uSW-mOdbwmKxOsJgaXSlreXz589TILhh0xolacc6AlQJvtgI--Rds0E7tGZN2RTRlIw3rQAorPaDwxTCWpD9iYJ1jXlKc3WRnWTYfIY0dkK_ky1BbCzSskItKrIuIEiwuIAzQQ4bSaxfndkEMfbEiROk8Qtbd0A7VpeEkVAMpBgVjWNKqDyNcKU1zLDWGIX61XBoXPyxLnRL3SBvpQOUZlrMBjxdzg5UAJNs1HJwtRx0f3ulnQS4yI4ctF7J_nURruIG58BcuXKlS5eudu3aiN1ixYplzpz56aef5pGkMMxp0aIFarVMCCS4FZ2gK8TjpEdmv379ZFtYpAWYrT8qyJkzJ2q7WrVqTZs2tW9tLVy4EN183XXX0TUylGuBAgWIpfKIgQMH5gj9bN8111xTqVIl_RrJxIkTeTR06NBWrVrJPc0R9JVCfVeQIyV9oZvz5cuXP3_-zp0716tXL3369NWrV-cpJ-pChQqh4PXnDXlD_yqyV69ecgqNghm-nKm26sBFtsORAkgWka1aCAKFTkAiGOn0jbQg6DG4YQe3f_N2NUtm0CrrAkjNKFjQlB5RWB8-xpQIgfyg7qGkxZevQ__yAJ2t8kqTkHC3YkA50gFmg_25m3I0HNoM9o5wVz5XbVGAluMGtV-FNUt3SnN1kZ1k2HwmUGQjHCES7CIdVJ_ka4kBS8PiUox2KGN_aUC-CUpApsQ6MPqZMAVkqryRUM1yDVqIl4mZgOqSuRSIu_rW-9lf_tscwDxxCfuDVcjULY3TrJlqFYHGBSijNI1o-Mo34DWWSWt0p3aCc0JOcH4SCxfZkYPWLnlFdlj1rVu3Iv769u3btWvXYcOGffHFF_rwxPhGgpUdFwIJ5Qffjyxfvtx2GREJTpqTAp7u3Llz0qRJ77zzztixY_UvlhiaYjiPli5dOmbMmLfffnvJkiX2JUY5-6ZNm4YMGbJs2TI5AtZiIe3vDYEc2glOBXNl3oGUx7ZRo0atW7eOWxqcPn06pwJNI6q6TZs2HBgY14gRIw4fPhyfF6h8YoFVZpiLbIcjBZAsIltxQY3QQtBdL1y4wFaqhHLYkq0APZqwIG4qJvLU_B-QaVYpwVNCmGUqDgrUxRikA2kapy8K60qOrhZ5ZRjFuBKvKRbKjgEllU-DslBhXaHTQr-6IEGnYWZzy5DDLDeo8cTCGsFypbm6yE4ybD4TKLKD0PQGVxxu2DYPQ4IKQGDRVYuE9ULCVhNAXeOnMtVF2GrSFzDfCULk5AonacGYJj-ilm7tNR75GKBi8ggbVNz9XmxXsYvSjNaCtWjKemRyVNEku0ZK1-ZQFLZ0ouAiO3IQHyIhsll6xWoAGaR36QLfMRKKD-JnDOl_Oc5x1YGNhHgFaJbyapx2LmFeMNqrTTUF1GNwmOoOYBV2Yp71GKyliiDomJx79T4e6CsotEYtWuZ6zTXX2C94mtnkyzUMlxjIpUFFq-si2-FIASTX10UsrKgpc-Aw6KkCK9FEwYuAEvRwBaDYmziwQAbsA2h6V5vB2BQsCfSSj0650q9Ev8arIEunsscCqCBNoIpAZRhgMJIqk9aUaV3bB-iAsE7LlAlrP-Gw1VE7ynGRnWTYfCZcZEMw2GLLypqSQ5WwWirAMmkVVCb05H-pwvXMmTOiirhBQtJcNOaRqpOQJrA1Nf-iFlVETp7qXEd5elFHAGNkj4qpIzUVPBXQqaqogECmurangIRcBsiPsIcGLVPgkXmNdaShkU8vGrugCQl2nSi4yI4cRLZkFNnwh4W2lyOkxQoAJYwV6hd6q0djlxJBwiht71YsB9AaZQA0lnMxBJXhli6M1TSrFoJtGrhVdcunImkKy2DbjAQ1EoQUtjxR7-mZvat--e8N8hSbB3MTEliup0kAXdgauch2OFIAyfudbEdEYatDUFaaq4vsJMPmM-Ei25E64SI7ckh2ke0QkPX9-_cfO3asZlin2eQFC2Rr5CLb4UgBuMiOItjquMhOFth8usiOdrjIjhxcZEcOX375pb29DvsgKFnAAtkauch2OFIALrKjCLY6LrKTBTafLrKjHS6yIwcX2RGC_XEC0_hz6I8o7KsyyQVatjVyke1wpABcZEcRbHVcZCcLbD5dZEc7XGRHDi6yIwqml52XBJOpb2wnI2jT1shFtsORAnCRHUWw1XGRnSyw-XSRHe1wkR05uMiOHJhApjT2JgJbMO3bGrnIdjhSAC6yowi2Oi6ykwU2ny6yox0usiMHF9kRwnffffdN6P8cM6X2Djt54w-N2xq5yHY4UgAusqMItjouspMFNp8usqMdLrIjBxfZEQJhPDYV5ydikwsskK2Ri2yHIwXgIjuKYKvjIjtZYPPpIjva4SI7cnCRHVH89NNPYT8NnoxggWyNXGQ7HCmAF154weQFwPHiOls0gshl7wk4PDAu2xsEPYo6MBb9vxsNh3EhL6pWrUrcXLVq1ccffxwqFYPgV_0c8QGSMKUdOnTo0qULt6T1Q1ok2PmSfc9zRAiDBg3iqLl69WrUA2IiNteRJCi26H-vCLjDe--9V6JEiTNnznBr_1oIBItFLyLxG9WpAYyL_UIiftOmTRyTZs-ezXkJT7E9kQTrC0I1_hcush2OywV-9eKLL953332ff_75jh07jh8_vn37dtI7oxyMYuvWrfv37__ss8-2bdvGvvv1119v3ryZTB7t3buXwbIT7969e9--fVxjq6V67AqBWHngwAHGxSgwfujQoXXr1kVhf_rppxs3btTKEjft51cdv4revXu3bt2aCWRuDx06tGfPHuYWtgCmnVsQRTxJa1i_fj1xrHHjxhw1Fy9evGHDhth1dSQJegcRpjuZ2OrVqy9btuzvf__73Llz14TAVLNfoNiiGjg-O8XatWvZKaDQunXrlocQ-zhqoQ92iGlbtmzhdvTo0cWLF585cyZjZMjS1qxsfL8b6CLb4bhc_PDDD927dy9QoMAtt9ySJ0-ekiVLkgbFohz58-cnmjCoIkWKFCpUKFeuXOQULVo0X758N998c-nSpXnKMLmWLVuWArHVUj0YTqlSpQoXLswQuGUI2J85c-a77777ww8_ZP9jewi9koh5Cxu7xo5fw5dfftm5c2dmtVy5cpCEK7OKLzDD3EIS0iVKlIA5oUVwpDpojRo1aoRIQlggKZCJ-sDHkQRIe-ljHNLS3Gi1bNmy1a5dG-9gwsuUKZMjRw4iKq5BXIpqMAQGxejYCxgXt1zx99jHUQtcA79g7ysYQsWKFdk45syZg5twLrWvqQS_Gh6Ei2yHIxlw-vTpHTt2nD17du_evbt27Vq6dClOODXKwWF91qxZ77333uzZs8ePH9-pU6ebbrrpoYcemjZtGplcp0-fPmXKFBIUGzduXGy1VI_Jkyf_5S9_mThxIgMkwdAYDnjnnXc2btxI6GQjDGnsmK_HxC6wI37Y7nL8-HGU2fbt23GBAwcOzJ07F2K8--67MITrjBkzRJjYZXCkMuACRC2WacOGDbj8J598omV1JA1B1YUO0-3JkydPnDjBTrF___5jx47t2bNn8eLFf_3rXz_66KOFUQ58fOXKlSSWL18-YcKEFi1aQCdGp6fRiwULFrChE81Yo2XLli1ZsoSAhrxmsKtXr_7uu-8u_S7GRbbDcbmQFNMXs3788ccffviBAPrPf_5zVZRj3bp1KM4VK1YQUNhxGzRoULZs2fLlyxNc1q5dS6zR52WUJNZQTLVSPz7--GPGRdzEbFQ1o8D4v__97-QjrxkdmXrtFL1fOv8toXc5ttMwafgCV6YRejDVzC1XZpsEsx27DI5UhkWLFuHmeMHnn3-Od2zevJlF9K9LJRkXFdmaTyYWkDh16hR-wZz_7W9_w0eiGmwKDIRYysbxzjvv3HzzzfPnz2ebiH0ctdCXP_EOtgb8QtEMkGa83377bXChg2nBRbbDkWz479Dng4TRnTt3IibkitELqU_94AYBJWvWrJzmCxUq9Oc__5nNmBx9psxTbdKx1aIB2MzQJLLXrFmj7w4SQwmajAupbbFSe6Ej4bDX_xLZ0tZc4QzX6OJJWgPrhV_gBaT37t2rdXQkDdoOAGdO0heNJEePHv3ss88IQfgI8SeqQdhEUi9btox9oUOHDrly5erfvz_p2MdRi7_-9a8MioT2QRyE9cJHcBbWju3eFhrEPZS6yHY4LhcIMlzrxx9_NHnx_fffnzlz5ssoB0M4e_Ys1xMnTowcObJkyZIM7e677_7DH_5AzldffXXs2LGff_5ZZc6fPx9bLdXj3LlzwdX5-uuvuTIK8sHp06e51ecSrKx-JcORQOACQLvOd999x9yKHkwphIEkzHDMpDtSJVipgwcPovzkzn7CvBzY7JkIs4TtFOwaFy5cwDW--eYbElGNU6dO6beYjh8_XrFixSpVqjRo0IAgEPs4aoEvsEBaL_3jG3Y9dnycBU8hMyiybWUNLrIdjssFwTToZihsvQdFqEU7NAquHTt2bNOmDRHk7bffrlGjhn58Sn8UxWAVWVQl9QNrtUAs3EX_rks_2EQZlpXysbmO-CH-BzcYo0TM90h-_lmCg1sSMWvgSH1ggVhHW0QtnNKOJEBTCmx3YD6ViRfII4Sg40Q7kKEbN27MkyfPkCFD8uXLh0iNfRDNYFBKhBwlZgeRa-i9NTsFmbanxJQLwEW2w-G4OCxenDhxolq1alOnTiW9d-_eYsWKfRz6JWn9OhVbiO0iDofD4UiDMD393HPPPfjgg6dPn65Spcq4ceOUGYRp1rQAF9kOhyNefPnll1yXLl1aqlSps2fPSkw3adKkW7duJPQaGC2uwz1ph8PhcKRNfPPNNz_--GP58uVfe-01bjt06PDwww___PPP34egMoCcK-Of7yQELrIdDke8kIx-5ZVX6tSpQ-Lrr7_-97__PWTIEG55pA_LUNhc435M5nA4HI60AzaIEydOlCxZUv_JaPHixYUKFdKbGsAe8cMPP1z0G3pXMFxkOxyOi0Mf6qGha9So8cgjj8ybN-_jjz-ePn36sGHDSpcuvWnTJhUTJLUdDofDkWbRv3__6tWr__TTT__-979R1aVKlZo8ebIe6Svp-u6yvtOcFuAi2-FwXAqbN2_OmzfvrbfeWrhw4ezZs5MgbmbJkmXo0KE8tb_2SFNfs3M4HA5HEPpOdrNmzXr16sWOwC1Kun379s8884wK6M_lBXu9fcXDRbbD4bg4fvzxR72f_umnn0js3r379ttv__zzz8n517_-pZB65swZ_za2w-FwpHGwERw9erRSpUoDBgxYvXo1O8Xy5cvfeOONIkWKHDx4kAL6gT92k-D3s694uMh2OBzx4rvvvlNA_OGHHwiUN9544_Hjx7_--mty9EeQxE3_aRGHw-FwfPDBB7lz5y4TQtasWStXrpw3b97ChQvPnz8_tkToY8809bVsF9kOh-NXoHfVBw4cKFCgQPD_wOlltp76-2yHw-FIs_g59K_jEdDnz5-fMmUKCvv48ePfhKDdgUcobBVOO3_D4yLb4XDEC3tLTXBEZBcpUmT37t3KcTgcDocjCG0ZCxcuLFOmjP-7XOAi2-FwxAsX2Q6Hw-FIIFxkh8FFtsPhiBcush0Oh8ORQLjIDoOLbIfDES9cZDscDocjgXCRHQYX2Q6HI164yHY4HA5HAuEiOwwush0OR7xwke1wOByOBMJFdhhcZDscjnjhItvhcDgcCYSL7DC4yHY4HPHCRbbD4XA4EggX2WFwke1wOOKFi2yHw-FwJBAussPgItvhcMQLF9kOh8PhSCBcZIfBRbbD4YgXLrIdDofDkUC4yA6Di2yHwxEvXGQ7HA6HI4FwkR0GF9kOhyNeuMh2OBwORwLhIjsMLrIdDke8cJHtcDgcjgTCRXYYXGQ7HI544SLb4XA4HAmEi-wwuMh2OBzxwkW2w-FwOBIIF9lhcJHtcDjihYtsh8PhcCQQLrLD4CLb4XDECxfZDofD4UggXGSHwUW2w-GIFy6yHQ6Hw5FAuMgOg4tsh8MRL1xkOxwOhyOBcJEdBhfZDocjXrjIdjgcDkcC4SI7DC6yHQ5HvHCR7XA4HI4EwkV2GFxkOxyOeOEi2-FwOBwJhIvsMLjIdjgc8cJFtsPhcDgSCBfZYXCR7XA44sX_Z--846so2r-t9CoivSOI9KYIqAiIir2gWEAFFKwoAgqiiAqooFIsCIqFKogUQXoRlCZFepHeBEMNTbA8xffifOP97i8xGE4OPDnhvv7Yz-zs7OzM7pRrNpvEJdtxHMdJIi7Z8XDJdhwnUVyyHcdxnCTikh0Pl2zHcRLFJdtxHMdJIi7Z8XDJdhwnUVyyHcdxnCTikh0Pl2zHcRLFJdtxHMdJIi7Z8XDJdhwnUVyyHcdxnCTikh0Pl2zHcRLFJdtxHMdJIi7Z8XDJdhwnUVyyHcdxnCTikh0Pl2zHcRLFJdtxHMdJIi7Z8XDJdhwnUVyyHcdxnCTikh0Pl2zHcRLFJdtxHMdJIi7Z8XDJdhwnUVyyHcdxnCTikh0Pl2zHcRLFJdtxHMdJIi7Z8XDJdhwnUVyyHcdxnCTikh0Pl2zHcRLFJdtxHMdJIi7Z8XDJdhwnUVyyHcdxnCTikh0Pl2zHcRLFJdtxHCcMgoPnsWPH_vWvf2kX_vjjD7a___57cJdkUQ1VoJrU5bfffps1a1bp0qVTQaXgyJEj9oz--9__sgWeHYd4xMCTBYVBCQyXbMdxEsWGDAYUl2zHcZwkwpipAGaGk7FVgEHVXvGibocOHTLbjmpssqCaI0eOLFOmzP79-xUT7VCjX375JW7nzz8JBx8uFbfdhLhkO46TKC7ZjuM4YYB-xYX-Em6Uevv27SNGjPj4448_-eSTYcOG9e_f_7PPPhszZsyXX345JMoZPHjw8OHD2Q4aNKht27YVK1akdp9__nnc4aiFBUPv3r0HDhw4atQoqsaTGjBggB6rwbMWcfsBXLIdx0kUl2zHcZywCb7j_O233xYuXJgrV66rrrqqSpUql1xySfny5StVqlS1atWyZctWi3KqV69ORZgjaoagXrVr16aOcYejlvr161988cVUhGUDlapRo0aRIkW2bNnyr3_9K_hwMWxiEv5QwiXbcZxEccl2HMcJG8QrLhT6kHfKlCm1atX6-eef9Y0BEJCZ6VVo9HL06FFq8euvv4bqegLCf_zxR9zhqIUHdOzYMarDw2L7_ffflypVitmQqkE81U6IS7bjOIniku04jhM2QclmFB03blyRIkXi9v9CehrtBF0T-2QbFO5UgKqzdOlSnmDwc3NmSUDH4_b_Ly7ZjuMkiku24zhO2Eg9TbWR7BIlSjCuHjx48PDhw_HENKpRXY4dO4Zu6t28tnGHo5Y9e_ZIoAkTQLJ5gtu2bWNpdPz4cXuyHCLsn4s4jnMKuGQ7juOEjfwM91Jg_PjxJUuWZDiVkuJtCqQCgu_sId5fLYxeeEA8O5sK169fX7BgwQEDBkyfPv2HH36IiYnRkxUJX967ZJ-ADhD8eU1sbGxcyHHObvQtGuMLfeSnn36qXLnyypUrdchxUjcoQjwBYja1GPRIAU2xqcMnnNOHGsykSZMuvvhiVEzNRs0psp7922-_0RoZugkoxgTxfwKFCWroSeA-pMwvTCiYPaMVK1aUKFHiiy--mDlz5uzZs20cUAJLZrhk_3-OHz-uB-zDpeOARsZffvlFgcWLF5cuXXrJkiWhg46TyvlbMyBSK0_BnKpZI4ka4Zy1nDHJFkGNIZwSrIY7IMsK1pf7QDyRCT-0SDlQYCuzS3Y4HD16NDY2tmXLls8991ybNm2effbZjh07tmrVioDjnLU0b96c7vDII4_QHZ588skWLVrky5fvqaeeijvsOKma1q1bazpgXoC2bduy-8wzz7z44ourV6-2ydVxksIZk2z7Vylc4sCBA9Jre6t95qGyf_sqPVgkCkmxMbHgCjblwP20Z-SSHQ487D179hQtWrRx48ZNQzRp0uTee-9l6zhnLUg2K8_HHnsMvWjYsCH9AsmOO-Y4qZ3777__gQceiNtp0oQwE0SjRo2KFCny1Vdf2T_tA_spqOMkxhmTbGuZMleF_7drQipIAQDbBgqmj9QVJj6ydyDiUDwroUt2OLB-2rdvH01_wYIFPPW4WMc5u1FfYMjWu5CVK1fSR9asWRM66DhnHdICJJv5lV39gJsYm2gdJzHUSM7M5yJkePDgQXtV_D9_PUxl49VRcwpQSNBRIoNr15QDxbPyu2SHA7dpy5YtefLk4faxy5PWawlahuOctagv2JY-ki9fvg0bNsQddpxUDfMlW1o-EJBMIwQlS5ZkciWS3VDCuDSOcxLOmGTbx82WbWTzDwMqS6mCbzCtkKEO9P97UDCccuAG2j10yQ4TBKJgwYKLFy8mzFoq4Z1ynLOQQ4cOsT127Nj-_fs3bdpUuXJl9RHHOQvBElhwli5desaMGXFRoSUo5u2fizgn54xJNjBu680ILVNqay74v4IqU5i4nZBMB3c5yiyTYr2LglnZXLLDZN26dTR9_eUErbFOLK8c5yyGXsCQocEa1qxZU6BAgfXr18cddpzUjlo-EEZWmBqwAST766-_tn4hgokdJyFnTLLJ_KGHHnriiSf27dvHrq77P2yfwZ4SExMzbNiwe--9t3jx4iVLlnz88cfxVKt-iu1ElNAK6ZIdJj_99NOFF14oyU54mxzn7MR-wEen8H9G45yd2IyABBw7duyiiy6aPn26dhXvOP9I2JKtz5RR1eDnFkeOHCGTuJ0Qe_fuVYKdO3dmzZr1_PPP13__4Lr2oTNn_RZCu6BD9vHGwYMHFaB4yp-AihrcKr0up592grIiUvHCrs4plOftt9_OkCHDVVdd9c4773zyySdNmzadOnWqUup3NJU_HD58WLvkRiYqDFspu6qmSye8h1STU-yXPjnFstVTILFyII0-WD_5Z-ukt_xdssPEJdtxEmLDJZ3CJds5O7EZganaJdsJD9lYeG-ysUYFgn4M-CsxjNKSUUXGxMT0DIFcmiiTTJmYrbKVWeq_7x04cIBdzp03b97PP_-sC-3atYst6FxpKxcCKxJQfq5ltTCntxgz0Rw5clx55ZUK2ycD2oU9e_YoYCea_YNKy6Utf45SJDKn8IoB2bNysJRAjWw9AMHrxrurCSE3K5JLdpi4ZDtOQhjRFKBTuGQ7Zyc2IzAxu2Q74ZEcyda5eokLOCUqSVPkRHtfCybHxt69e-NCIchHMTawW0DladGiRfbs2bds2ULYslKABBJrlXb__v1suWK8whMvG6aOOtHU9uDBg2nTpm3evDlhXZcMqRRVsHJyCjGSYyuAlgRArXfv3q0wzhZUcAiqtvLXi3lqTWKLJHOVmdNVa8s_MUhv1XTJDhOXbMdJiA3BdAqXbOfsxGYEpmSXbCc8kiPZeKde0BLQdxQKKwBE7tmz580333zrrbfat2__wgsvDBw4kHjTSrZDhgzp3bs35jpx4sQ2bdrUqlVr8ODBJFA-RH7zzTcY8DnnnPPRRx9NmTJl2rRpo0ePjo2NJY1UHovt06fPgw8--MQTT_Tq1Sv4Yphk8-bN69ixI-Effvjh8ccfr127dtu2bXfu3EkM1j5-_Pjvvvsuffr0VatWHTly5Jw5c8aE4KgKQNmee-65W2-99YYbbiAsLeamIcq6V2vWrOnRowdXf-CBBx599NHu3bsrgVSb6r_77ruc27Bhw48__pg8dZa9zA6uRrgJtsvNh2BdEqI0Crtkh4lLtuMkxCXbcWxGcMl2wiY5ki309prA3r1733jjDfSR3eXLl48YMQIT5Wj58uXvuOOOxo0bI8oVK1a0Lzp01rXXXluwYEFMlKNZs2bNnTs3ge-__15prr766nTp0pUsWZLIQoUK5QiRNm1a8leCmJiYSy655Pzzz0eg69SpU7hwYTR99-7d9joZReZcVD5NmjSXXnoplyPDVatWUXGMn0Pi3HPPzZYtW65cuTJnzsyWuuC7ffv2LVu2LDk0bdr0sssuY6K57777NPuoFng5ZS5SpMgtt9zSsmXLK6-8kjC-G7ryn6tXr6bk5EbdH3nkEa7SqFEj3eH9-_fj3PPnzye8bdu21157TU6_b9--oIWfvC_zgOwZuWSHiUu24yTEJdtxbEZgJnbJdsIjbMmWIoO-0EB2UUxkmvC8efMQ1vfee4_wzz__fCJRKH2ZMmUQYu0at956K_aJQC9dupTdfv36YcwIq7IV7dq1w60XLlyoXQnuoUOHMNEGDRpkzJjxxx9_VMnfeecdcsN9mSOoDqrdpUsXYtKnT0_vQPqJZBfJJjFhtsg0ZozNx6sv8VwI7HuPq666inNN39GzPHny0O-or2JAR_Vev0KFCpUqVdJFyVy6b_9bsG3bthxl_uKUa665pkWLFrqlv_31OTvhk0OeVmaX7DBxyXachLhkO47NCC7ZTtgk5002CeSUGHadOnXKly9_9OhRVDhXrlydOnXCgO3zZV2lZMmSVapUUYxARuvWrZs2bVp9hqG_7pc1a9ZGjRoRIAd58Msvv4yefvvtt4pkq5wZ9rF5fU4t8162bBkpW7duTRiYKZ588snzzjtv_Pjxqo6-b1F5qCwJWAZwCo6r9LZ4AIm-rvWvf_2rcePGWbJkIR8yIeXw4cM5sW_fvqG0cUjNSbNhwwbq9fDDDyue9JMnT0bKn3_-ee2SbdOmTRE8CrBy5coCBQpg4fpcW3BF3ZDE4CqgsEt2mLhkO05CGKEUoFO4ZDtnJzYjuGQ7YRO2ZEt_AeO86qqrihcvjpIuWLCgYMGCN998sz4-Vm5KSRgLrFixIl7OKeayN910U6FChQhoVMcyMVfMWF8ncxZZIdkZMmTYunUrMaa8XA7tTpMmzQUXXFCrVq369evTBW688cYcOXI0aNBAMg2vvPIKGW7ZskWFAS7N6VwOtEggQZMmTYikyjpEpO7MN99807BhwyJFilAvJhq8efv27cq8VatWnKjX2AcOHOBEuwQB5Juj1apVq1SpEsVjdXHttdcS8-KLL5Lg0KFDpKGOlStXLlq0KAHkmKPkSebsUhKrQmKQBhR2yQ4Tl2zHSYgGQaBTuGQ7Zyc2IzBbu2Q74RG2ZAsa3r59-7BkDC82NnbMmDGZM2fGa_UOWG-dzafLli2LZFv71Lvnq6--Ok-ePNpFebnoueee--ijj6pgyqFz584I6IYNGwjjsmyBBEg28Sh19-7du3btSrJOnTq1b9_-yy-_1Onk-fTTT1OknTt3qhiqFEel14JMkGwCXM7qjuM-9dRTGDyFmTFjxurVqx977LH06dPrpTs89NBDWbNmZV1BOGTs__8bjx07dgwdOpRs77jjjjfffLNt27bvvPPOSy-9xParr74igVIePnz41ltvzZkzJ1Vbu3ZtlixZEHqtLkBVOAkUUqUFl-wwccl2nIS4ZDuOzQhM2C7ZTnjIxsKQbAZh08Fdu3YVL14cXySsN7Iopv7QtSyZqxw4cKBAgQLVqlXjRH1QceLMP_-88sorJdmClpwuXboHH3ww-B63devWREqy4eBff9kDs0ybNu11111nM4L47bffrBfg3JTnxx9_xM5B2VIeFQzNpTAkaNq0Kdot86ZeJECUc-XK9cADDxCj3LBqUupbcGqnX9YcNGgQdSG90nBUb-6JZ-2B9HOISLZExrul1Ou8885bv369FirNmzffuHEjaZSMU2x98rdYSnDJDhOXbMdJiEu249iMwOzuku2Eh2ws7DfZoF_y27t3b-nSpZ955pn9-_dPnDgRPUX1lIMJHxZ4zTXXEKC56kIcuuWWW7Jnz27vlZFXzPXxxx8njMtSJA69_fbb-fLl-_rrr4m05i1Lvvrqq0mvP6FNSpl06PiJd97k37t3bxIwTRDDxGFfm4SSnKgjhSGBZBr0fh1wX-IRa10oJibmiiuuIAYFl0aTeZo0aZBjfcdiSw5AmrlWyZIlqZrWBtRLdeRczV84erZs2dauXUu4fv363JmVK1cStgpaIRODwusOg0t2mLhkO05CXLIdx2YEZmWXbCc8ZGNhSLZOJI1pK4Nw06ZNtTt06NC33nqLgP6fC35JfJkyZXBiJRBcDr9Mnz49Qzo5sNV75fvvv58TbZyfOnXq-eefj8526NDh448_7t69-4wZM-S-CCWOxCnNmjV77733evXqddNNNz3xxBP6qyaHDh3q1KlTunTpli1bxm48bZVPE5k1a9Z77rlHkaD3x5SZZUOWLFluvPHGhg0b5smTR3_-76mnnlq-fDnOTQL9EcBSpUpxRQrWunXr22-_feTIkcqHVQGenTt3bo5-9NFHb7zxBtXXL2VyabRef8Jv6dKlhFUduznm-ieBm2_PyCU7TFyyHSchLtmOYzOCS7YTNmFLNsgLkVRS_hKCXTRRedIm9cfv9N8QUVJ8t0ePHnoNDBJKzPiZZ54hwKXJh-2TTz45YMCAUJITv1WJKBOghHffffdll12G0d52223Tpk0jUu-Gt2zZgtDXq1ePLlClSpXHH39cf4cEyHDEiBGPPPLIrl27uJwk25YHVpKWLVvaHwnR5ZSSGqH11atX59ITJ06MjY194YUXbr755rlz5-rSgChzes2aNWvUqMGWOuLfxKt2ixcvbtWq1fXXX08mtWvXpqZffvkl8forIpaJfRsjvwfFnFy1qQIo7JIdJi7ZjpMQl2zHsRnBJdsJm7AlW0cRSs6SEaKVaoqETfLAxPHw4cM2dFtKzjLXRG05kd2EbZhIjnK6EkvoBfHor5UWf6VU7JJYrizLJ6xdikH-kmCtE_bv32_CDcpcW9NfuyIn6gsZhdlazmRLPnZd5Uk1lYnVXafv2bNHu9SIfKgCYaqvZMoheBsTQh2t1i7ZYeKS7TgJsdGKTuGS7Zyd2IwgX3HJdsJANhbem2x9i2xvW2WcoBj81ewZTEzRR2m00iuNrkWkdrUlH3kqgqsXzMKuSLMP_iVpK4CIZ6iUR0pNMmYQJd67d690FojkFH3fAoonkrJZVtTCrk6prK-pRgqrzFzLBJ2jwZtJvDJRtrpE6MiJsnEiWVluJ4Gz7ESX7DBxyXachLhkO47NCMzHLtlOeMjGwpBsSbNUFWsEnRtsfmQIUltQYkugy4FeEnM5pURJEdzgv2Ux9PJbOWzbti0UF_ciGaTmzA4kI6xdbXVpg0uzpe6aSjgaTEwxFFAdLY0loABE2ikqDwWgCjrEruCovQIHMjFHtzfZwqoPtiCxwN_CKaCwS3aYuGQ7TkJsFKNTuGQ7Zyc2IzCvu2Q74fGPkp1QPPBpBaS8IvimOSIwyKOnJosobNgNm6w43RQWCJNbPPMW1Dfo90pz8kujwsG7ZNlyUbbBWkQWLmrXdckOE5dsx0mIS7bj2IyAAbhkO-Hxj5It8EW9HiZsw69sEue2mMiSMFu9gT4lgqdQ2X379qmO1EgSbHBUFRSoM1UGkv2tjgvLn9MVJn_CnGgvrblF5CzXV0xE4AHZM3LJDhOXbMdJiEu249iM4JLthI1s7CSSHRsbK9FUjHm2vc8Gwhw6-bcNYcB1VQYb8IOfXiQdfbNBTVVZ6hJP34mnmlJkXZFT9LY7dDypkC1ljtv5qydyOeUZccjWcnbJDhOXbMdJiEu249iM4JLthI1s7B_fZJsvykRxUMVs3779xOHTgDVjLhrvA4ywUT5UmXwAjd65c6etFriiXUhrCd0BhRNDKxD7FkW7bC1GeZLJzz__HE_ukwnFs2fkkh0mLtmOkxCXbMexGQE5cMl2wiMpko0v7t27V3ot7I0yDQ-J5BBjcmQVhZwVQIJNGcNA32zEE2WbQSg8TkwgWHgurU_MqZclSAy7V8FCcorOSk7J_xEuqquDS3aYuGQ7TkJcsh3HZgSXbCds_lGyE2qive6VdqPgemurdhg6EhlQecuQzJPzGtjy0d_MhuDnLob-ew5Vpmp2Cvfh5J-pkFWw05nQWw9FuP_2j6UkE_K3S7hkh4lLtuMkxCXbcWxGkNy4ZDth8I-SjSAq0n6Nzz4RsX-Zzlb_xvxvzTU8xo4de_3117dr106Ce3LNPQn2pTi1--677y6__PJx48ZZZPCPomzduvXee-8tW7ZstWrVqlevznbp0qVJvy5Z7dq1i0DwFPs3N6xDIv7NOg9IzwhcssPEJdtxEuKS7Tg2I7hkO2Hzj5INSiNH3LdvX7169QoWLKhXwjpEwytQoADOHUFLGTp06DnnnFOnTh3tSt_t7XLSsSKxGJg2bRp5Dh8-nF19zkF9Qf9tEd577713QzRo0CBjxoyLFy-WIp8EvcU_cOBAuXLlcuTIMXnyZHuxPXXq1PTp0xcqVEj5Hzx4UBeNFFTNaueSHSYu2Y6TEJdsx7EZgRndJdsJj3-UbPs4BPQyu1KlSqjqs88-q0gsE7MkRgasLdkSsIFab7t1SJdA2e0ol-BawXbL6Zs2bZozZ87SpUsVI5dVYTiKrSoGfvnlF2Wl19IqNjGK1Jb0MGzYsHPPPffzzz_nWqo4W84K1lHxffr0SZMmzTfffEOYxGBXiafduhyRVatWzZYt2x133KEEnPLUU08h2RBK-P_vJJewt92qBfdHAc5iy322196ktMRASq6oi1oAXLLDxCXbcRKiwQ7oFC7ZztmJzQhMzC7ZTnjIxpIo2dLHihUrFixYsFChQhs3blT8tGnTUMnY2FidjrYGvxuRmmvQxhel2kD-pN-_f792dQpb-3yZy6l4CKiN-bBjxw4FFIl36rrK2fKXy2pXdfnyyy9ZDHz66aeh4_8nW13IrphQsk8k-mu1ACot8WRCfTF4JPumm24qVarU1q1bif_5558LFy589dVXo3DkSQLScznlD0F1ViSFtG9ydKt1Fc61ApCDsgLSq17gkh0mLtmOkxAbGekULtnO2YnNCEzALtlOeMjGTiLZ0krFa1uhQoV69erhoG3btmUXOD1Tpkz79u2TkU-dOvWxxx675ppr8uTJU6lSpS5dukgZ4cMPP3z44YftUxN9xMz20Ucf5SyEFV9_8MEHGzRo0LhxY7ajR482GSVz_BIF_-6776pVq1a0aNF7770X0X_ooYewZ6WhI_To0YNLX3DBBaVLlyYrEnCKbJVkWbNmJU9yuOqqqy655BJymDdvns4FrqUbklCydTco4eDBgzmXq99www0ff_wxkbJebsvrr7-eLl06fY6CtiFvb7_99vnnn68q7Ny584033rjllluw4eLFi991112zZs0inuKRYOnSpdSX0o4ZM-bKK68kN26vLRgIWH8PCrRFumSHiUu24yTEJdtxbEbAAFyynfD4R8lWgmBjw_9w6EceeSRt2rTr168n5quvvjrnnHMOh_5FIlLevHnz66-_Htl9__3377nnHg517txZgzYXYveDDz4gbCLYq1ev9OnTb926FYWdM2fOc88916ZNG_yYlB06dCBSyWScKCzxyHH__v2feuqpwoULc27Xrl05iuzi6HXr1m3UqNGIESPeeustlDdz5sworDLRZy0vv_xyjhw5yOG2224777zzrrjiCkSLo1ohqFQJJVtXf_LJJzNkyMD2s88-Q_SzZMnSt29fvX6uWLHiuHHjyK1hw4bsNm3alHXCwIEDWX6wy23BgEnz4osvfvTRR9yc_PnzM3PpF0aBK1I2pDxnzpzNmjXDszNmzEin1m-X8mjsBba_yY4kLtmOkxCXbMexGUEG4JLthME_SrYGW2tsBJBsPJUhFw199NFH0ccJEyYgiLiskm3YsIEtzh0bG7t___5s2bLdf__9xJAVlC1b9pJLLuFCekfOFvW86667CAM56K3ztm3bOPGll14iTGJFkjh79uxotN4No8XDhg3DmFu0aMGu7PPQoUPKmQLIWdUvsKkpU6ZQTnoKswYxgC6zVBg1ahRh-_t9bP_2cxF2Meznn39eOo4fc9PKly9Ppbh0uXLlWGx8-umniPuuXbuKFCkyevToN954g10Sy9E5UR9bU82WLVvmyZNHJSEHrB2rLl68-I8__kgMUCkqy2pBu6TRdTlX5SEAoYMu2eHiku04CWG4UYBO4ZLtnJ3YjMCM65LthMc_SrZirFERQLK7dOlCuE2bNjjrypUr9Wc0pI8SQYF6bt--vXTp0pdffjm7e_bsYfv---9zFiM2WZEYKVQm8mZgeMeSN23aRHy7du2IYVfl1EfVQ4cODSU8YfPkSQwuqxiw2eHgwYO9evXi6Lfffssu-et0CqAE8PXXX-sq5E8C-tFJJJuVQObMme3dM-DonH78-HHOxbY___xznI2Y9u3bn3_--fv27aMAuC_lV-2UOSVkJWB3T_EDBw7MmjXr2LFj2dVfI-EQCewXTEGZcFdVHh6QnhG4ZIeJS7bjJMQl23FsRmDGdcl2wkM2dhLJBr0h5pAGXn3zQGDjxo158-Z96qmncDv94uOJ1KE_ON2gQYPixYvjiIULF86UKdN1111HJroWfkniRo0aKf-rrrpKf6fPBJSUbHfu3InRvvrqq0QanTp1ypAhA5cjLOPEs7kKwqpflySTAQMG1K9fn8gcOXJguhdccMGIESNUBRSW-FGjRu3du1d14XQK07BhQ-s1KkZCycaY9QULVU6bNm2-fPkyZsyYPXt2Crls2bIjR45UrVqV20ilCJDs7rvv5tx-_fpRfX1PQoH79-9_ySWXcMUsWbIULVqUuqxdu5b7RmHGjx_PWRMmTFBRYcqUKdmyZXvooYe0C_roxb6f4Vq6h-CSHSYu2Y6TEI2PQKdwyXbOTmxGwABcsp3wkI2dXLLtKwUFKlWqZL_ySABT1AtjNJcctm_fjrRceumls2bNQiv37NmD7GK9uhC6SSYtW7Yk_a5du9B0jHPMmDH68hhsbF-9ejU5t2vXzmKgS5cuuO-0adMIy1yx5HPPPbdz5876ROSdd97JkyfPk08-uWXLFsrzwQcfcKG5c-fSQSgM2srlBg0aREpclkjKgAQ3bdqUGJGYZBOoXLkyuWHDI0eORGfHjRvHdujQoTqlZMmSxGDAH3_8McmGDRtGPH6PKHMUnnvuuZw5c7722mu7d--m8C-99BLJ1qxZo6NDhgxhlwwl2UePHt2xYwcx-hJG6JB-YgA8EXtGLtlh4pLtOAlxyXYcmxEwAJdsJzxkYyeXbEBhbZeW1rFjR71PxQWR1Ny5c6dLl-5Q6M9U9-zZEzVctGiRjJBkhQsXvuaaawibHXKUNO-99x42XLx48eD_tZErs8WSyfntt98mWwrGUbL66quvUOqnn36aNCrAwIEDzzvvvGeeeUYlz5cvX506dezvnEiy9fdDSPDpp59yOplQNjIkBo0mQb9-_ZSAOrJlftG_wsHmiVHFKcPDDz9MNcmNNHqPbpBGv_hImAKvX7-e9IS5GwULFuQoxp81a9YmTZoQr_mLMuPfyLGqzBXRevSdMHeVUygnpwwYMEAfi6sYwNUVIMYiXbLDxCXbcRLiku04NiMw6bpkO-Hxj5KtLyv0e4eiSpUqzz33XNxO6BMOfBSU_pVXXiE8ePBgwmT-5ZdfopLly5eXdB45cgSnJFyrVq08efIUKlSoc-fOJ3L56y9Do85cDgnWN9nYvI6qnNhzhgwZqlevPnXqVJK9--67FSpUIFmXLl0oORDmWjpl-_btTZs2JUbmCkgwlozpymsR5euuuw6RJVvOlZcD4XfeeYcT9cpcMWy5aNq0ae-55x59XL5z5062dD221KtatWqjRo1iIaEPVxT_4YcfckUCnMJSpEyZMsqKaathw4asIrQAoDycyxXvuusuvdTndH30snbtWnaBR6CJT8sDAtxw3XNwyQ4Tl2zHSYhLtuPYjMCM65LthMc_SnYQNBTVu_766_XbePLI3bt3MwJnz56do8Sgm3gwdoi_Yi-VK1euU6cOfvnoo4_u37-fPHWJTz_9lDQ4q_1nGYkvRxVYtWpV5syZUXZiOAsPJhL57tu3LyfqL_dx0dGjR7PbrVs3pZHx4-6I-AUXXHD77bfj0LVr137__fcp3oQJEzJmzFijRg06C4579dVX58qVi3PJWYatz8qpBenPO-88fS6C93NntMzQEgIef_xxanTDDTeQ__fff88hnHjQoEH2_p4t9OvXT39dhFo0a9aMGnE3SpcunT9_fgJI9iWXXDJ8-HCOfvDBB_ny5aNIiHjr1q3LlSvHVbRWAaY8_aAAuD-aAakyKNIlO0xcsh0nIS7ZjmMzAjO0S7YTHkmRbMRR4qvtZ599hsmFjsQ1NjSxV69eZn5bt259--23mzZtihAfPnx4z5497UPYP3dExPfu3du7d2-TSIjXbnHKrl27Llq0iAwppDKX1uPfaOjYsWPJZ-HChcho9-7dZbdsKQxHO3fuPHHiRAr89ddft2rV6p133uHod999h4WjywMHDnzuueceeOCB8ePHE2_ffijAtdasWfP6668jYJTKCia7ZVFB5g8--GCjRo1YbJC_jvbv35-K66ZxCgFUe8uWLVRTNxmDHzBgAN7fs2dP_VGRIUOGPPbYYyrDtGnTqMi4ceOw7Ycffrh58-aUQfUFHo0qCEGB1uXAJTtMXLIdJyEu2Y5jMwIzuku2Ex7_KNnEIMrBz0XslxQ5l6MajX_77Tell4hziv2xEbJVwMZtsNYLeovM0WAC0DfcJpeAtlrz5ijXQq9x0x9--IEYlQFMMXVu8I_u4eW2NVQ7WwOowHpzrOoEoQA63dSc9MToLLaqhVWQXbsDguKRnq0qCOT50UcfZc2alYUB6XVRtsRzLliNiLEiqbIKu2SHiUu24yTExmI6hUu2c3ZiMwLzrku2Ex6ysZO_ySZgYUDytKuPj_Wv0YGsJLXkoxgSaKyWxZKAE3VFmSKeyhV1URRZGQIxppImxCQg_qWXXmrXrt3o0aOnTJmCYefIkeOmm25SAmEn6stpFZWtGS1h0qiQFEwfooB943HgwAGdBRJ3W2MQtrsk7BCRaLoWDEbQ5slWZbNThBYt-DGrBbaK5ERdhSuCIrmZ9HS7RPCQS3aYuGQ7TkJcsh3HZgQmY5dsJzz-UbKJEYRB6W0EBvM5AwvEvM0F5ZRmlog1pyvDoNUQQwF0FnnqEia-6LsMvkePHrVr186VKxdKSpt_7rnnaPycq_fQhEPJ_4yJiVFADq1sySEouFw93ocigtzM1AUpKZtlzmJAZqxCknm89MSg1HbTgBpJ642g9LOdNWtWtWrV9HuQoLfvqrJBtrrbdvd0Lrhkh4lLtuMkxCXbcWxGYMZ1yXbCQzaWlF981KgrGSVZ8GsKdkmscFA3iTeVhOCv7tmurmg2qYBlqwCRElwlDr7bNpsEPDuYm8Igp8eMVSP9xUCwD1qAPEmG06tUXI5LS_GDpqu_pgfKPN4tojzEWzV1ul0OKANpCLCV7pNehI6fyJBDutV6E8-heFcBJSDeDrlkh4lLtuMkREMM0Clcsp2zE5sRmIZdsp3wSLpkOykNHpA9I5fsMHHJdpyEuGQ7js0ILtlO2LhkRy88IHtGLtlh4pLtOAlxyXYcmxFcsp2wccmOXnhA9oxcssPEJdtxEuKS7Tg2I7hkO2Hjkh298IDsGblkh4lLtuMkxCXbcWxGcMl2wsYlO3rhAdkzcskOE5dsx0mIS7bj2Izgku2EjUt29MIDsmfkkh0mLtmOkxCXbMexGcEl2wkbl-zohQdkz8glO0xcsh0nIS7ZjmMzgku2EzYu2dELD8iekUt2mLhkO05CXLIdx2YEl2znVNH_lLF_szJhwgTaz6FDhxha7b_JKECMk2KxB7Rq1ary5cuPGDFizpw533333dGjR3_77Teer2zbnqnhkh2HS7bjJESDC7hkO2ctLtlO2Pwa-hffNCExatSoChUqHDx4UEfBW1G0cPz4cR7WwoULGQGGDx8-c-bMWbNmsYgK_qPKhE_TJTsOl2zHSYhLtuPYjOCS7SQdmgfoBScBVIzGM2bMmGrVqiFqO3fu3B9i9-7dMTEx69ev_9lJkfBoduzYceDAgcOHD_MEJ02axDJpxIgRGPZ3332nf95u2Ncjhkt2HC7ZjpMQl2zHccl2wkNurQCtCAObN29erly56tSpU7JkyaJFi5YIUaVKFXaLOykSlLpUqVIXX3wxz4vHVLFiRQJI9uzZs-fOnRv8JhsOHTqkXcMlOw6XbMdJiEu249iM4JLtnBIm2TaQxsTEzJ8_H9WeMGEClgaffvrpRx999NZbb33opEj69u3bu3fvwYMHDxw48J133vn4448_-OADnuA333wza9YsBgSND3rE-gQ_iEt2HC7ZjpMQl2zHccl2woMWwhAK9tmu2gy7v_76K_EHDhyYNGkSrrZ48eI5Topk2bJl9HeUeubMmdOmTVu0aJHWSISJP3ToUMJfdgzikh2HS7bjJIRpQAGXbOesxSXbCQ-1HNpJUCqCn-0ywOJqePaUKVNQbScFwvpn_vz5EydORKxxbgx74cKFOPcPP_ywYMGC3377jQfKI05sNHDJjsMl23ES4pLtOC7ZThj8K4TCNBVa0a-__oqTKcxWf2Nk586dhw8fPnLkSIyTItm0aRNPbffu3Tt27OAxrV27dsuWLUePHuXBcUjPl4lSvwGZ1F985AR7Aa4z9aEJzSJVQn25lfnz5-feUc3Y2Fi2-nPxUY16uJ66toon4EQQ9ZGE0K6iGvvjU6rO1q1bCxQowEATdzhqoS7aArVjhmOXES_4HDUA6g44SeH48eNsGWcYdqzNpA40bFKpUPP5d9GiRceOHatDqammmhqY_ugRwRjHccLm7yWbycZ6lwL6g9uKSZX8-OOPF1xwwcKFCwmnmnGTZ4claPJjblCkczpgmTt79ux169axzF2zZg3NadWqVdujnJ9--mnPnj0bNmzYvHnzsmXLEIvq1auPGTMm7nDUsnHjxuXLl7NmWL16NY-Mh7Vr1y6quW3bNj3N0BuouFdQ7tn_SExMjAL0gp9__nn__v36c1c0ntSB_sga6E96XXrppUOGDCF-7969-_btI0BbglDaKGbLli32KIXPGo6TTBJ9k62AdFOeTSS7qRJqt2LFilq1ai1YsOD333_XS9-4Y9EMtQj-pXR0AY4dO6ZdJ1LQQTp27JgvX74KFSrkzZs3T548F110UdmyZQtHOdSoaNGi1KhcuXKlS5cuXrx4tmzZqGPc4ailVKlSBQoUuPjiiy-88EKqVr58-SpVqmTPnr1-_foIop4pPUUdJ-Fvizt_Cysx7meJEiXKlClDU9Gfu4pq9OfVgHqJ0F_0Kn7eeedVrVq1UqVKuUIUKlSoWLFitKK406IW-gIV-eqrr-KeaKgXHD16NG7HcZxT52TfZGNphw4dYuh89913hw4d2r9__76pFCrYrVu3OnXqvPXWW4TfeeedHj16xB2LZnr16kW9PvzwQ54driDtdiIOU9Fzzz139913r127dtu2bZs2bVq3bt2yZcvYjWqoyKoQet37ww8_rF-_nm3c4ahl5cqVLKepF4GNGzeuXr164cKFXbt2veaaa_RAg78tfuTIkbiQc1L27NmDhvbp02fJkiXc3lmzZn0f5cz_i3n_F-o4atSo6dOnk4bmtHz5cio7Y8YMnRW9TJgwgaXC8OHDGdD27dsX91wdx0kGfy_Zwf_5OXv27KJFizL9XHbZZWhoqqRatWo33njj5ZdffvPNN1955ZV169atWbMmgbjDUUutWrXuuOMOqlakSJE1a9bEPVHnNNChQ4eHH35Y4T_--EMf-P43yqEuUszgT41ZqsUdjlriahLg6NGjmBMjAGEenH9hdUpwo7hpu3fvvuiii1i6KMa-641e4ppLAuIOpzro2hUqVLDPzYHK6ue6juOEx8neZDPTMHR---23NWrU2Lx5c1xsasReXDGm2McVqeAbdBnSrFmzypUrt3fvXsLIhL-Zizg0lZYtWz7wwANx-6kI9QL7GUhsbKx1kKiGni41VNXYvvfee_Xq1dNRQWeRbTtJYefOnQULFvz----5sUDMCSGNZlQRoHkIxRNgylBH4OivoT94nArqSxVYJg0bNozAoUOH9AvBhB3HCZtEv8m23jV79uwyZcrotURcX0x1UDWmW5bsTKsMoKF6n_gGIO5w1KKKrFixgslv-_btFuNEnOeff_7---8nICul-6QCGbVBAFJZ46E6PCAc2hbYvXv3RrKXLFkyceLE-fPnaxzwLpMUtG7fvHlz6dKlFy1axC1N9fct2DXUVGziiF701wk_-OCD9evXr1mzhlVT3AHHccIl0TfZNkoy5RQpUoQRJHW8wUoMuZFqrXk3FQyaqgiTH09w3bp1Bw4cYNd__Hc6ePnllxs1asS9VUOC4DQcpeg9rjr-nj17QnGpoV_8LW-88Ub16tXnzZs3d-5cffMA6KM9UCcx1NTRsjJlyixYsMDmDgJRDS0fqB1tHoixeiVcSGCoJ86JZujvlSpVev311ydNmkRH0F8a8fnCcZLD30s2_U0BRpZvvvnm4osv_uWXX1KBNIQNN4RRlek2um4Cj4_t6tWrixcvPnz48G-__XbWrFm_-p8kOw0899xzDz_8sG44jcR6kJMCsaeDQinM9p133rnyyisZ7r777rsffviBSD1NbZ1_5Keffrrooou-__577XoXiDrwaeb6t956i5kCfv75ZyLP5nnfcZKPS_bJoMo2xRJgV-82FJPyUeFdss8ALtlRhD0dl-wI4pId7bhkO07Eccn-Z6J3tnDJPmO4ZEcR9nRcsiOIS3a045LtOBHHJfufYeiBuJ2owiX7jOGSHUXY03HJjiAu2dGOS7bjRByX7JPBoPN7CGkTEIgi4XbJPmO4ZEcR9nRcsiOIS3a045LtOBHHJftkJPzDAtwE_ybbSYhLdhRhT8clO4K4ZEc7LtmOE3Fcsk9GcH7FTY8cORJFr7FB5XfJPgO4ZEcR9nRcsiOIS3a045LtOBHHJftkMOhQ6-PHjzN_rFixAlvdv39_3LFowCX7jOGSHUXY03HJjiAu2dGOS7bjRJwzIdn6lxaHDh3SLpBbXCj07x4OHjx4wQUXpEuX7vDhw_Rz-x6DsBmhTXXHjh2zkvwe-mcryl9hHbLPPI4ePUomBLZt26YYC-gqZkW6EJHKgXgKQzn37Nlz4403ZsuW7ZwQGTNmHDVqlN0fXYhkujpwSDVVzpah_mWmYtgqPacTUG4Ula3dJZKp5II0VuukozK4ZJ8BwpNsGr_1BXu-nCuCjYo-wpz35ptvfv3114o0aP9qVPpnQ0B6xRBgq0uobEJrRZpfsFcCV1EytUYyUbu1pkghrU-BrqLdoUOHNmvWjJvQtGnTl19-OXT8BLQ3VU2t3c6NjY1VOBhJgDJbqdS1gRx0LdAIoGZMeuKtv4NOOfliWLcFOFdhti7ZyST5ks0ztTZMo7Wnb0MWz2LYsGGtWrUK_lCR9mDb3bt3s1VT0Vm2DbYT8qF41uOENTDBrgqwd-9excCuXbsU0P9mIp99-_aRkqxotJs2bXrhhRfuu---e-6559VXX503b576EdeyvqwycCIBKw-BYGFIb7UDwtYIg4fsttgYIig2l4tXnaRAzi7ZjhNZTq9k22RpwwHdOBjJWMC1GJuQVxTWxgVTUkYfymCDCN1egymQhtFEoxho-GPw1a6uwlFy0FhpAdCFgroglJuVEBguM2fO3LdvXw2mM2fOXLNmjY2YnG4DJdhwTNWI123UVrM-95B4qqNL2IwC1EvZkl7F0FHVPXiVpKOh2SX7DHBKks0jsHYr9FDidTEysXw49N5776VJk4YpXI1HTSJek1bAwjRIFYlTFLBDtK54hbRmrzwtZ2yYbbBTAOXX6WRLyiZNmqRPn75OnTpPP_10w4YNWZdu3LjRqkPtgh2NE5UnoPUKWB9Xs1c3p0fY_3am5FYkiFf4eN0_3tF42FHyVJitS3YyidSbbAZ2G6MYNtUw1Cpo8yVLlrzgggsYhNWiaGM8ID13GbauS0o1ISWzwpBzvFZkrVQNTBkqkgDDvo5yKFgjElghdRZzU74Q9NA2bdpcc801Xbt25agtXIEiBTuCNVfBIckxsMvlbLIjXsUmK8tNWWnWsLCdEgZk4pLtOJHl9Eq2xgW6vYYkdjVmMQLaCCUWLFjAUS6nIQNIEDTLeKfYlD9p0qRmzZoFX1wxRtuJyk0DtI1NNm0rE8qmQ3aWig3cB-y_QYMGhBkQNfYJChPvhugoJbGyBcdTID44TFsyy1alJWetMZS_bl3wxKSjerlknwGS87kIiYOKqeZnPc4CLPCaNm2Kap9IF4KWo6cZExOj1qsp1k5kS4a0Q1LitcqZxOprhAmo-dnpSqPGSQ6KVw-y_6xuiqwWToaskJ944gmuq_SqvgRaJSQlzZtpWwmsa6hstqjWMlVl27BhQyjuRA7m4urp2qqoQVRlE6PEsKfDpRVm65KdTCIi2cEXHzx3tWQi1UqhXbt2jz_--NKlS-25kJ5GZROHWpRlAsqEJkTDICWNhDAJKCFnkZisSMOulTleDpyoTICuoe4AROrqhG-77basWbOq0SoxF7IMhbVYCkA-1lBJRhmskYNasp1uJ5KzOhQx6gXEUFq7FtuE_SKJUBeXbMeJLGficxGNF4Kw3uEpN3q1jmrgMILDBEMPuzbkMSxqjpf1MiJky5YNRyfG9Fq5STgUlh_YVbioxmh7ociJuAKBYGm5D-effz6STaQ5MXBdtuRGtrZsCB2Ju4Ttqqjs2risfHR16kLOoPpSI7vJpNdVLCsLJB1dxSX7DHCqb7IViPcqC4JTOyhD0DzKifEMUnqqs9RC7JRgh82XL1-FChWCMVr6Kkw75Fxaps6l8LZqpYTBQlrYeij5MESkT5--Z8-e7KrRCtJYhuqMYNfVTWCrQEJUHbsQmVBO7cY7hZtgHVk9jhtykkdghyitwmxdspNJ8iXbhrjt27ezVaum2avB7N69W3lqVy3NxlVIOELa1x20uq-__pql4KhRoxRDVuRjp_CUrYkyqlsrYmsrQLU6GqG2tuYUNWvWvPTSS9U-g4cov22DvUNwiWBj1oxAQPlQPFWWXZJZCe3ekl5h8iFMeusvKvwpwSku2Y4TWU67ZGtckL8S1tAWOvLn1KlTq1evnjNnzsqVK1esWPGOO-4gAcOETeT33ntvvXr1sIqmTZsWLFiQIfKxxx7TIMJw0KtXLxKULl06Q4YMDRs2vO---x555JHGjRvv2LGDBBrO5syZU65cuSxZsmTNmrVWrVqzZ88OTpxdu3YtUaLE-vXrX3jhBaYH8smTJw-DC4cYkR999NEHHnggU6ZMVP_uu-9-_PHH2b3tttsoHplzW7gWp1MqKFu27Ny5czWuUUfdwE8--YQEF1xwAQkoP0Pwxo0bidcwPWHCBMZlDqVNm_aKK66gbETagKu7ZLdClTpVVE2X7DPAKUm2TZbWF0hP46GXadYnH_kf8xzuMnny5E8__XTgwIHTp0_XLxWw8kQr5RC01WXLlpHn2LFje_To0bt3b8VzLn5A80ZEihYtSgvcunXrhg0baIQ0CRKouarTffjhh88__3zfvn1XrVpFpFBfGzly5LRp0yjSmjVr3n777Zdffnno0KHE0zHXrVtHY-7SpQtt-OOPP0ZNVq5cuXPnTnxIakLOdHM6WufOnT_44IN58-YRqZtD3WXGpP_yyy-5esuWLWmlWFpQ66nagAED2rVr9_7772vW1zKD_NWPdM_BPBuCOSTEno5usmJcspNJRL7JZkuzJMDp6iYayb_66ivaxhdffDFixAg6AjGWP9edP3_-mDFjeOjYeZ8-fWii9AU1b6A70KrHjRvHYEsHIQ3tf-3atUpAO1Q7p19069atTZs2XMXaD1enVdO0GMzZpT0PGTKkU6dOL730kl5a0xN__PHHLVu2lC9fnmF2yZIlpKFfLFq0yEZaCtC_f_8XX3yRRk7fUTNWJ9WlacxMB7RA0tB_R48eHWzbbOnjzHdcl3opUr1AawwS625QF1WKS4fRbjnXJdtxIsuZkGxGkKVLl1aqVEkC8eqrrzJl7t-_n2ECdRg0aBDTZ758-TBOnQKMGpx4__33582b95prrqlSpcqTTz5ZrVo1RklsgFIxNjEkMSAqEv194okn2EV0Nm3apJcBM2bMyJ07d4MGDVATRsYLL7yQ3BhbOaSRiLEY_27RosUll1xC_oyDadKkYfxlhGJQI088m8yxZMKtW7cmZatWrU6U788_GfHZZUuGZJ4_f35GWOIpm37qhzFwLnbOoM-AhaZwCYxHaUaNGoW-N2rUCINh9MeBKJ685NChQ9dffz1zCbukp-5sNeaeKhpnXbLPAGF_LsIsbq-NCaMLnEsTmjhxoh46c16OHDmYwmkhtChsVYkFrYVImuWDDz5IayecLVu2yy67jC7Ag967dy_nEsnqMV26dATShyhTpowpCH2TDk4jv_nmm2knpEG1iVdd6Gj0jquvvppmzCEaKlllzpw5dOqf9evXJ1LQd9hmz56d7Y033qhzWf0WKVLkqjy0GZAAAJK1SURBVKuuohdzCS7NgkHnCkYATjnvvPNuv_322rVrs2ZmoCCec7kbGBsr8Fy5ct15551arKLjOhHvwUUIcK82b97MfVM8UDWr3d9iT4dLKMzWJTuZRORzEWC4ZovmwuLFiwnTyK-77roCBQowgNMMQCM8T1k2jIDSNhhLafxqhwzIn3_-OYf27NnTvHlzTiRSMPCyJYZ5xx5u48aNzz___KpVq9J3SFCnTh1aIB1QK7fx48czU3Tv3p2-oHO5EItGprCZM2eywiRSvU9kzJiRJk0X5tyFCxcSU7JkSfoXjZkwLVyTqbZI_x133EEvYKinC9DX6GXURfMIgwMDC_MjIwDFoxczO6C_GmRYNjPf0YxJOWzYML2L0T3RbHtKcD9dsh0nspxeydY6e_bs2YxQzNyxsbE9evQgrK876NL6VRUCpUqVKlu2LGGNLMAYx5zH0HPffffJNsiHEeqpp54KTnsMfERahhp8ISYmhjGrRIkSimGYZvQn5WuvvaYEjJ5t27Yl5oorrpD7Qr169RgTFQYulDVr1nvvvTc4YXAVUJh7wjhL8RjHyYpdsXLlSnZvu-02JQO9eGDE1-sZRkwIHTlxFW4OJvHRRx_plT-Kz0QydepU7gZrEmrBiWSr9ElHN8ol-wxwqpJNm9EsaG2JNoO_yqGZL5mPBw8erENq_zTyc889t2PHjmRujUGSXa5cOeSAZoNVM0kTox-MwKpVq3bt2kVjY54mMbvbQnCILsCsjE_gRnqvRjMjK2wjdGrcG3em9pw5cxYrVoz2ye7HH3-MN5MVYVr1xo0b3333XVpv165duTqmxayvjk_rnTt3LilV0yVLlmTIkIH1Kt6g8s-bNw8XqVu37rJly1RH7gYZ0vcVxmZq1apFIQmTJ7VglNAQwS5HWfoSZgXLnWG1QNh-Um9DQULs6bhkR5DkSzanvPjiiywmWTXRBhg_kVrlo4UoY1eLFi3QaNmkWhEPsVu3brR5Wvgnn3xCS_7qq69oGwzmaniHDx9et27dqFGjChYsSCtljKXxLF--XE2F58vYyFqUrqcGP3DgQLy5U6dOhMmBAnzxxRfkT-1ovRrJEeXevXsTIKstW7aQrFChQpg0rRc2bNigEtL4mfVYKqioXBGbJyuuzi6tGliIsmrl6pJjasqIre4AL7zwAvrer18_tUMMmNMZHwjTEXr27EnXowDssrJt1qwZfVDnanlwSlAYl2zHiSyn_U02Ez-jzxNPPMEIMmjQIAavcePGER-cusiZ6ZNhS2Mcw6uGm8svv5wRxIYb4HQW_QRISTyleumllxg6sWQbU8iN8jPTMxY3atRo-_btDG0MPczB6dOnf_TRR0mjczF-BqxFixYRwymMhiagDJ2Mm-wy-N5zzz2MPkTqTbPCKiqgPnDnnXeSuRQZGH_JefLkydIFoRNhzJgxHMUPMJ6dO3cyas-YMYMYxlkVgLMY98kQe2Akvfvuu6mjFiSnhG6yS_YZ4JQk244SUPNeu3Ytrf3666-nXeHH6AINm3hrZrRhGnCmTJn0JwuELkc7R4KtpaHmLE1HjhzJUZqc4hGXatWqKT1b9WW206dPp-ENGDCAXX0IS6egl7HAo_2TkhKyWCXNmjVrOErHpEGioYRlsZSfVkoCRITEGA9n0cb0ds1KRedii6lTTQk6oBcsuWn8hNW51Di5NGX79NNPqZqGC_XuZ555hjuArBMGPIbuiZaR-O233yY8ZcoU4jV6nAS7_y7ZEST5ko0y0pInTZpEo7r33ntZ7PFkgUOW2w033EDvoF3RYHh8tHAOPf300zSMIUOGqJkRwzoQQefZadQlJZJNK2UYZNe6lTJnGVmgQAHFAJmz9qtduzZhsqJNTpgwIWvWrEwEFEwNm2pi80wTSkM8jadEiRLsKk-SqeXQmNmC2vDnn39OMZgWlY_-stY111wTShJ3LqgiZMvkS10UySDAtVhPcnPU-2jqiHXhwoWZHbj_jPMPPfSQ4kNnnBrcK5dsx4ksp1eyN2_ezLjDJM2A0rdvXwaXPn36MElrgADGHY1QXKJmzZoENDCpAAxznKJkJ1JT3HPOueuuuyiJCkO2OAGDjl4MEGk_eWdYZPBikuYU_QgbsAd7Lw6vvvoqkWbGfwsJbrrpJl1OaNDEjFu0aMGUwOCLvuTOnZtrMeyqatgAJ65YsYKw6khAGsEIjo4g0CcKdM45-iE-qsH28ccfJ4HGRwZZpI0qoFwMoAyj3CLiTwndTJfsM8ApSbbNu3rWW7ZsoZvUqVOHeKyXttGmTRvi4z0p_dxZhwQXoh0il02aNMEbOJ1pUks4lMLaOYdq1KjBepWwXrCByvDKK6-Q-Pbbb6fttW_f_rXXXqtcuTJNun___nQu5XDppZeWLVtWXcD8GGQqJBs_fjyZ4MTaVRdQn-WGIL7PP__8ddddV69evQsuuIBmrGwpKrUuWbIkYcG5bKUXnPjUU0-RLatilujcW0SKTIhBgpWSm4yCc7swbKrzyCOP0A21ADC5_1vs6ZCPwmxdspNJ0iWbQzQn3VjrCx999BFD6GeffcbRu---G81F8uTQ1pJ5Xpgu8k07VP6cztG2bdsi2fpRBjDFXHHFFaVKlSJsPi3JHjp0KOmDaz96GfMCIouesoJlS3sjZcWKFSmkHH3gwIEM0Sxf4zUGphsrP7MAa0iFuajqqF16xOuvv07Jb7nlFgpG5iwkiGdG0JfivXv3VpE0IKhqHOWWcpQ1AKWiezKtvPDCC9wl5krdQO4D96R69erly5dnnP_xxx_z5s3bqFEju2OnhEu240Sc0_4mu2HDhpgofsDpDFtMqxqnGNo0fgnGiAoVKnBdGxNJ37hxYwZKRjGVhy3DKyMgYU3kjC_M3wxDDEZKYFtskviWLVsy4K5bt279-vUbNmxg7tS7B03SGAYWKxVOjIIFCyLTSg8aUhGIG264AfHVexG4__77uZyGNi5BqRjshg0bpqGTKlu9gAUAiV966aWVK1ciPTjWmjVrtm3btnfvXkvG6I893HnnnYTJh_T9-vXToaSjW-2SfQY41c9FaFE20w8aNAhRbteuHWGeOI4rydOKkaau5kdrobl269aNMBfSc2RWzpw5s95sqXEitbQWfQ9KpNokUzs6qytSPDUz0jMfswTVD5pp0g8--CCrUHLT1yYk49IskiHY_Wn_dF7FUFOGiGzZsunX0YTyp2yIBW3vgQce-OSTT_AJqsmSlSJpwXnhhRfSvyQ9VMcuofqynKYi-Bb3hD5IUdH01q1b04yVjJtAl2F0Ygmxfft28meo0fgAGiL-Fns6XMgGDZfsZHKqb7KD4__mzZu5-TQGmtbUqVMxbHzU-ohSqnkwKdCKiOeoDWWoJ01FUqhFWqVKlfLkyRM6eALOpXkg0zaK2rkxMTHEk5j-SxegvdGEbr75Zv36jZKNHTuWbjJixAguSmG4utaQZKtq0kiY3WjqZrccUuHnzJnD-hZR7tGjByM562FqN2_ePPVu-gUlJ2fyUTU5y2aBtWvXotTUhfLQK-lH119_PQGkXBdSSpouawxWKXSryy-_nKln165dwfVwEqEALtmOE1lOr2RrJMJ0GcLQ3D179jDZo92aYgUzPSNXuXLlrr76anY1pdHbGd0YZxkv7OU0ZzEeMW0TthFEn3zgH5yolAxSnE7i_Pnz169f3-pCPAOTxiauyBYVRmT1QdvfQhkYvJjsdRZ3QDeBKYGLcrrSsMWYmeBl8MQMGTKE9cCLL77ILgWwMlBCsmKE5br67oXEytyg8MwTlStXRkcIY-SU4Y033iAclyLJ6Ga6ZJ8BTlWyLQHtHzp37sxMLE-tVasW9rlp0ybCwWTLly-n1emXCmgzOkRHIJI1XijVCXjQNBj9ARC1cyhTpgyirClZ7Y2-SUtA2TEM_QYhGe7evZtIyQFXZAssJmk_9u5QeVqPoM2PGTMmXbp0FJ4T1UHUVr_88ksU4c0332Shyy4wDuBSOpfCXHfddSwbNJcL9SCgpzRo0IA1-aJFixh8uLHKmWLrdL3zq1u3LsqCYXO76O9YCJEaXuzWJcQOUReF2bpkJ5OkSzYPlKNqSKHmf6KlMaiWL18eR-T5zpw5M0OGDFpPWhsW-mmGnj6orTL8EkkboPWSnhxKly5NYThkKXF30qCzhK2H6tIM3dWqVeMsPWtWbhxVmJZMnpzFuYzqxKsdGiRTGS677LIKFSoQUALlT2HozrRM1YJIvTGZO3cuuzRy5gJ29RGjeg2X07l0EG4p8whrSHZBsx7lNAuHr7_-mi6g_7Hapk0bhhEMO4zJAjjLJdtxIsvplWzyYX5l1HjiiScYKRhTYmJi8uXL98orrzDoaIATyDSeTUrt6lqMp1mzZiWgEYptlixZmjRpQpiUpGG4QSYYpHr16kUkEKMtCZ588kkOdenSxdxi3759-iNiZEXV8BUSbAz9Wb3EIAGyq7BGLk6kIsSXLVtW0zmDr_7yA_OEfILREC8hpn___jYgbt26VcXDoVu1asXRjz76yI4yMurrcLj99tuvvfbabdu2UWAGaH2eq5twSmiecMk-A5zqN9m2ztSn9pzINImD6q9ksLxkfRg6HmcJtD1Wg7QZXFDxoA6VLVu2Zs2a0TyY7Hm4qG327NkHDRrEKSoGgeuvv14GoBKyVXNau3YteTZt2pSWxq7QWSRQg0c9a9euTaXU6UJJ4iAlaSTZbIkJdmr6F5K9cOFCXYv2TzenN8kVSPnBBx9w9RdeeCH4yZYuCl999RUKTtl0OmWmvjoE3BZueIECBSg5kl2vXj2rBTmfvJHb0yFnhdm6ZCeTU32THU-UYf369awG6Qg0FTybmYKhVU-fCUivbB577DGGRNqhzlJr0asWpNCyqlq1qtyUxqY2OWfOnMyZMzMgk5XyBBXy5ptvphMxNirSWpF2QT8d0lrU2me8Nnb11VdTYAKcSLbqKSTmRPw7lORELfSHUKgdYWKoFL2e6UMTgeoIlFAXIttzzz2XmcVmCg5xaRWPe07J6UFcjlXuBRdcMHbsWG7sydt_YnBFl2zHiSyn_XMRTVHMjhMmTND3oGio_kgTGdpgV7ly5SpVqihMPCMjYwpjH-OpfUXKyMuS_Y477mAkshGHcZnxNH369OXLl7_kkkuqVauGudr4eOutt55__vmcxfr-iiuuIHzffffpECMIYkTMSb7Jptho_Z133snYDZYtQxjrBIbs3LlzoxcsD_RtKy7bs2dP-RM2f8011xDJxHPVVVexNfXhKJVCpDhK_hQbpaYkqBKHuGOcq99C27t378SJE4mx_1J5Sujmu2SfAU5JsqUCNCc9C-tZb7_9dvPmzQnQPOrWratf41ODoaesWbOGxoaC2IthQAgwV_zSeoQ-Rho_frx26Urk0KFDByLbtWs3bty4uXPnvv_--5SQQwcOHCBDDuG-ffr0wS8__fTTxx9_3P5SHstC7LxixYpaH_5tvWha5KC_PQKkVLJJkyYVLlwYh-jbt2-bNm3o45SfmKlTp3JUN4FqZsqU6f777-eKmMdnn33GbTTjp4-kTZv2wQcfRMcZiLgQfYQ2TAL6L2K9cuVKkg0bNoyUOkUdx96I_y1WC-6qwmxdspNJ0iVbDZ7mZ54N7LIlk0qVKuGUtKJRo0axOIz3FBjAc-bMqUHbpo-nn36aFrgn9NdC1FBLlixZrFgxJeByRG7bto00TBPI6NKlSwcMGMB4yFHSLFu2DM1lkKQXz5gxY_Lkyb179-bSKifn6q-L0PzYBRXbpgOgMTN_2TfZIA8mngkrR44cTz75JG24Tp06LAuZOOhiGzduVA4sJMicSRb_nj17NsWjKdIRmH0oGw2SsmHPuO_IkSPpI126dGnZsiUnck_o1-3btw9d8E_mEXo3AXqHDSmnhEu240Sc0yvZmsMYPbVqj4cMQ4cYO9atW0fAXAEYr6XjxogRIxgQCWj01LkMuEOHDn3ttddef_11REHf5GkcRMeXL1_OsPXhhx927tx5_vz5jFxUSnVB0HERRJZwYnz99dfBf88h4xGUjfEOZWEkpdgM3BSPOZ7M7S-BcPq7776Lx1AGzdwcNa1HF3ALtAY15z5TZr3J4Kap_MFJKAw51szkkn0GONXPRYTSC2sVeIYC0gVBnszKLBo__vjjYIvlrNtuu6179-7qCzzcadOmsZ60By2XxdpbtWqVJk0aVnos54oUKWLNgEP0GoSVmZ6jZcqUQQv0i1lAMrwWs1F62j8lYUsF6YPqhjTd6667zv4ANlfkKFCkfv36MfeTLSUfPXo0fSRfvnysiu0vhFCXtm3bEoNGoOC4UYMGDYi3ur_55puUlqOAw7Hipdta4YPDBV07uHsSKJsClF9hti7ZyeRU32QLRjxbNAaHOwkoz1S7ggQvvvgi-qs-okvQzGjA9evX37VrFzFA48FiIdiDgFZdq1Yt2jnQqDBprqI2zEOnkZcoUSJbtmwsCy-77DL8Va9LSMCykFUokxSNQZcI5ff_oeEhvqx1qUu8CYWiPvDAA-TJNPrCCy8wQTBW0BP1SkXVpM-SP5fOmDEjps4yg4mDeLIiwbx58xo1asTpuXPnpitRBeYLzRQqPGjX-gUEl-JJxCXbcSLOaX-THQ8yZDhgaNB7C9C4IEUAKXJCNJrIGIJokCI-OL6IhHlqzGVAtLEpiVBsIKDLgV6YcVHF2E__7aKk53KScm6d7p5dl4Bi7KWddikqZ6mc2mqaSTisJwWV2SX7DHCqko0Q6ImDzcpqS2RCMzC9QCysUdlPdYBmrO6guRAswyCcHoxXg1TTsusG5YYE8ToObVUTtvUyMiRSWQGV1RfkKo8uZ76ra4F1eU7U_dFalKzIVjHWOLkV-oNl5GldTDkoJap9Il3ocrqi4Cz1KatFQpQDcGmF2bpkJ5OkSza3lMWhvBB46Gokaj9btmzhuRCgCVkmwTc1agacTj4WSVsise0eOHDA2ptB_qQR7HIVXUgloQycQhpaGqfTSoM_D2HA5yxaGqVSe1P7Vw5AN1TDs8YMlMeatPUXOwW4tMUT0Mt4II3FKweKp4DuElj3YWtdQF3V7u0pwRVdsh0nspxeyWZ2VFY20dogongbL-jeSqNRUhMbMQpwaRuYiNG5ZK6jhlyBszQrawuMTTblWySQj4bduP0EcEiXoHhWVPJXYTik3GTYlFxXIdKsxUrIWXYhRVIppbfBNHiHGe65CqdYxS2QdHQhl-wzwClJNsmUQLOyWr6eL-famjA4Q4M1XdKrqegUdRllSFsioAyF4iUcxIPyVKtj14pKa2RXYUqoNhz0b6HTrTXa8pJzVX2hrFQ2wtpVg7fOKHRIJUzYyNXvLN66Idg3VKqL3VVQnolhychWYbYu2ckk7DfZCujJxnv_SjsPPvF4LQds8ATrd8FWRCSNwbJVxwHrWQQ4y3Y5V1e0lFzCmlPCdkUMHTNYDGBXi2T1WSu2ugOR9Bpre8oz2LvZKkPSK14ngk6x6qh72tWDxbPyJx3yccl2nMhypt9knw4orQ1YEG-8C2LJbEQLb8UfLcgPXLLPAOF9LpJCoLSC8geJO5zqoKYK2IDA1iU7mYQn2WcSiiRCrfv_E3f4rMcl23EiTtRLthWV4qGPLOUtJiEkSPgbUfYqLvWh-cMl-wwQ1ZItKHM84g6kOqxqLtkRJOVLtqBg8Yg7cNbjku04ESe6JZsiBafApJTQNCg2NpYxhZoy0epQ6kOVdck-A6QCyT57sKfjkh1BokWyncRwyXaciBPdkp3M-Y9qnuTbklSA7o9L9hnAJTuKsKfjkh1BXLKjHZdsx4k4qeGbbApG8fQ7H5Tcfm_sbzl27Njhw4c1cepNtuJTJaqmS_YZIBV8kx23cxZglXXJjiDR8k123I6TAJdsx4k4qeFNNtukf_Jhv_KIbUvHU_Gwq_vjkn0GiGrJpsBA4c8SBbFqumRHkJQv2WdbOz9VXLIdJ-JEt2RTzuAfLTp06NDJDZJasN20adPSpUvNtlPxFyPyA5fsM0BUSzadCOgISOfZoCBWQZfsCJLyJftsa-eniku240ScqP9cxJRx__7906ZNmz17dsK_7BuEqtWuXfucc84ZO3Ysu9Lu1Ir8wCX7DBDVkk2TYM1p_kH5U7eCWNVcsiNIypfss62dnyou2Y4TcaL-TbZtoVSpUpdddllw0KT8-icXoPLHxsbecMMNhQoVwsjZDRqnwgy-2j148CDDMYGjR4-S59_qOKOSBZQ4RSE_cMk-A0SFZNtPb-gFlFCF3LdvX-PGjdOkScPKM2_evOeff36zZs3s71rSWoIdXxVUX-AQKMY6Ar0gWPfjx4_boZSDldAlO4KkKMm2__9i4zkFq1ixYpEiRWjnJUqU6NmzJ5HB_25DY7YOAsFerO6gjmAZasDXKaQEmnq81qI05MzWZhAFLPOUA-V3yXacyJI6JZuhk3HN_lUYnq3_IK3BjooEx1aSaaDU6Ml4GvwfYzakwvz585mGhwwZotO5EKMSCVKgRgiN-C7ZZ4AofZONYd9___0FChTo378_DWPOnDl9-vRp164dFaHL2-8Q08KpFN2EeEXGxMToEDls3boVKyWBaQTYHUiBt8KKROdVmK1LdjJJUZJtBqzhjseaI0eOmjVr8nDXrVv3_PPPp0-fvlOnThw6cuRI8F8l0NRt_A_-qzK1fwLKmdopZ5qQ9Xq2nG5zJdOEAtYvOIuw0v9v78_fQuFdsh0nsqROydZoSOEZ5syANSayZVhUgnj_7pHRk6MMwStWrGCWpco6BQ4cOEBWzB9Fixbt2LEjMWSu0VYow5SGRnOX7DNAVEg2LTbeGhJjPuecc1588UXC-l_NFH7Xrl2hgycI9qCE6N_Cd-3alUzmzZunSP3kh4DcIgXeCiuSS3YESVGSHWy0POXGjRunS5eOlolSc4iO0LRp01y5cm3cuFFp4s0FFJ5x0jLZv39_cMowKdfbFtBRttbmdS69SWnY6hBwOkVSOEVBmV2yHSeypE7JVkxQJnbu3FmxYkVUIFu2bGwLFSqETDPUqlLS5XHjxl144YUczZIlC1uG4D59-hDP0PPxxx_XqVOnatWqxBcrVqxSpUrlypW79tpr33__fY1EKROX7DNGtLzJpqlrspcEYA806SeffJKwfplBzYMqYAxmHl999VXr1q0ffPDBVq1abd68mWqqc7EcnTlzZqNGjcikZ8-eCNbEiRMHDBiwZ88ejur0FDtugEt2BEk5kq1L20DH8u-CCy7Qe2vgKDDaZ8qUiYGdVor1vvHGG2PHjtVEAAsXLuzcuTO9AzmWJcPXX3_dsmXLG2-88bXXXluwYAExatvLli0j8fr162kquvSgQYO6det24py_oEe8--6799577wMPPPDZZ5-xoLXvGFMOLtmOE3FSp2RLIARDJGMlgeXLl8-dO5cB8dZbb02XLp0itYUdO3YUKFDg8ssvZ6wkhw0bNqAL-m4bNm7c2KVLl0cffTRr1qyMkh9--CEjEYa9aNEiJWBAD_7MMYUgP3DJPgNE4-cilJaZHmnImDHj66-_jiSp46DX9qaN1oJDZ8iQ4f7773_kkUcKFy583nnnLV26VEfvuuuuNGnSnH_--Ug2HsOWDnLJJZdMmTKFo7ob2qYo7Om4ZEeQlCPZeq9MN9R6EjmmZaK2hG1qYJVI5LXXXkuYETJXrlzPPPOMDlFyhJhOYXWhDTRp0oT0t912Gz2dajInzpkzR0f79OlDp5g-fTphaTrZ0insV_DpZbVr1y5atChdCc-mp1SvXl2HUhQu2Y4TcVLzLz7u2bNHYXs_oRG2Q4cO55577u7duwnbDMo4yBiKJxHWIY3UjMV4BpMx56LapGnfvj3Zshu0VZLZdVMOqp1L9hkgKiRbTRrUEdSjFy9efOmll9Kw6T6Ipi07adJUB4HAP9544w3CpF-wYAEL1KeffppWdPToUX2f_dJLL2XLlm327Nk6ka4kedXb7hSIPR2X7AiSoj4XMWiEffv2pXl_8cUXcVF_dYSSJUvWr1-fBNu2bSOBSTb07NmTGOpCI6cBDB48mN3Jkydr8Pzqq6_Y1WTB6e-99x67M2fOZFc9goVr-vTpSXzs2DHa2AMPPJA3b159T8VkpMwZkNlNUbhkO07ESbW_-KgYAgwcYHrBGPf8888zxm3evFkxHOUUqFGjRpYsWRo0aDBgwAD5AYlVa223bNnCiQzZjJsnzgzFA8lS5kysUrlknwGi60026kCzt8Xnrl27unfvXqhQocyZMxctWnTMmDGKh8qVK5coUULv5FS7Sy65BJcKHYxbvvbr1y9TpkyIKYJODHVXp9B9sKukHOzpuGRHkBQl2XqHLV588UVWhox-NEUN3cwLBw4cyJMnz9VXX02YkjOw6zcTNPK_-eabWbNmZf2pqeSKK64gQXDkrFChAh2BAAmGDBnC0alTp7JLm2fLJMKyU-GYmJg0adJcf_31hLk6ZVi1ahV9rUWLFsSkKBgTXLIdJ7Kk2jfZKi0jmgZN0PBKTJcuXRj1du_eremTkYXA4cOHUY1WrVrlyJEjX7586dOnx5n0UanGVvKZOXMm8R988IGy4kJEWhkUSFGogi7ZZ4BokWzrDgnBpDt27Ki_cTZlyhT6BZEZM2aks9x5551VqlSpX7_-7bffnjZt2ly5cum3JAHJwEg4Zfny5exSd_UOYYvbFIU9HYqqMFuX7GSSciSbRq6nhkmz1S_mfvnll6GDcVMD7TZLliw8ccJYL-38jTfesDnu1Vdfxcv17pmZgtNp_5UqVcKV69Spc-ONN6LgefPmVU8fNWoUCebMmaOWHxsbi2TnzJlTudGVOHrhhRfecsstNWvWvOuuu7goMXSlE1dKSbhkO07EiW7JFgxtKlu5cuUuvfRSRQZnd2qhV3EkgyeffJIhkhqZDcgnzBsYFhEmxsGbbrqJXU7X-4ylS5cSiWQTtu_tcFZdPQXKq2Yal-wzQLRItkoIrDZBYYNW_fXXX-fJkwerZoVJRVBq1pzdu3engr169XrttddefvllAnEnhNCqVWIqrEumTOzpuGRHkJQj2RribAqYNGkS4_bgwYMJ6w03LX_79u1E0mfZ3bhx43nnnUcLP5E6VPJu3bpxdMmSJYcPH8bU0XEmwWeffRYBpbV36NChc-fO-kvbdJmBAweSePLkyTqdq-PiF1xwgeaIcePG0TtoWp06dSIH-s6LL774yiuvjBw5UulTDi7ZjhNxUoNkA6PD8ePHCxUqVLNmTXbxA6sCQ61NpaJt27aMiTt37rQXHqDBF_QXtQ8dOlS3bl37sbje_y1fvjxdunSMv2YnnM6lGVUT-kpKQLVzyT4DRItkUzDZs3blASq2LTKR7AoVKiiMfBQrVkyLTBKoXpaSE_fv38-yM2_evLNnzybezIaUdAp6hzJPUdjTccmOICntm2x7h7Jp0ybaMOtGRnV2KSfbsWPHZsqUqX___oS3bt3KjIAE64tqesczzzxDzOLFi9mF_Pnz586dW-9i1B70jnzHjh1sP_roI-YFfS6iqad69eolS5ak_ZMhabJly3bfffdxFOgvVrCUhku240Sc6JZsimQDFiNalSpVatSowSi_PsSGDRuWLl2qkQIQBY2SekutPwZMBTmRwRf7_PTTT1euXKnIIUOGMAQ3btxYL7xV93379hUtWrR8-fI6F6XQ3wmGFPinRUDzgUv2GSAqJNu6MG0eKC1tm4DWkGoYtJACBQo8__zz6lldu3bFs3v06MFR1Q6stWtp2q9fPzoUJxImjSUDck6B7c2eDnVUmK1LdjJJUZId7zulxx9__Nxzz9Xv4ahh48GFCxfW77hj4TRg_aURRvVBgwblzJmTGOSbGGjVqhW7EyZM0MgfnAqp5oABAzj6xhtvsEtrb9GiBV2GGCVgcilXrtwFF1wgZVdzotOpGCkKl2zHiTjRLdkMVXrHBkePHtWvpzCc5c2blwBky5btmWee2blzp9IAs37r1q1Lliy5ZMkSBkSGFVV20qRJjLmcUqxYMYZIuOaaa_Rv7TQskpLA008_jYLkypUrT548OXLkuPfee_UyAyiAAikHldwl-wwQFZJNLzY_Vgm__vpr2nPz5s2ZWekCr732Wv78-UuXLo12cBRTwUIuvfTSzJkzN2rUqHv37l26dKH7sJpVAkn22rVrM2bMSD7dunXjPpCGZqYFLVgg5WBPxyU7gqQoydZobHPW_PnzmR1o259__vmoUaNq1arFUK-_0KrX21WrVmXWqFChAqM6MwhWnSVLFhqDVHjfvn3ly5fnlDp16vTp06d___6PPPJIoUKFOMRwygDLdMBRhtkLL7ywYsWKd911V-7cuTmq7sbVmXG4OvG9evXq3bv3Pffc06RJEw6lKFyyHSfiRP3nIpTwyF__F3fDhg3M_Vgvw_2WLVtwa7A53oycrf1pEWpqkyg-gXlPmDAB8yArDa8k1lkai8lt2bJlgwcPnjp16qJFi8iHO4OLsE2BbyZUNZfsM0C0fC6iXsxSUxbCtn379tWrVy9YsCDLy1KlSrVs2dJ-nnPihJA8ffTRR3Xr1q1WrRorT0ShX79--mKEfIAATatp06Y1atTAv0kwbNgw9RdIgf3Cno5LdgRJUZKtYZ_GadPW0qVLmzVrhgTj0OnSpUOjidTEQVtFo2vXrs3ysl27dgyYI0aMoD3v2bOHfDT-x8bGYp8NGzakj1DNxx9_nF5AvD64mjdv3tVXX125cuWOHTvu2rXrzTfffPTRR9XF9I-ZaFRcUZ2oXr16Tz_99Lhx44hPUbhkO07ESSXfZOuHgwmnQ2IYIjmqgTI47nOIQTDhTGAOqlMMqh_UBYZvrD1uJ8T_dlL5W3RDXLLPANH1uQg9AtSk1YwlJfae27rSgQMHTJchGNYHrKB-pE-n4v0cnG4Srx-lBOzpuGRHkJQj2Qxx1tRpkPp5C_C41TebN29-zjnnXH755V9--aW-GLHGDMERUr1Dv6gDlpX9OXm6DGnUSOhTihS2q4C6mEUGu0kKwSXbcSJOdEu2lVPjl42AFFsv2AxGNCKBMU6JDXYZJcnKcgOdrhGWBDqETBAmk2BK0jAoExm3n5JQqVyyzwDR8iYbEGVrA-oLFFtv3cCcmIZtYfUaKqWPo6yjKR-OxhscSEkPitcHUw72dFyyI0jKkWwasz01jc-0eT1rmq40d_z48Tly5ChQoMCyZcvYRbU12msZae9f1AVs8an31iBFJit1HOs-1rP0m5H6qjvYO5RtyhyE6eMu2Y4TWaL-m2y2jHQaUhVQWIOg3FoB-YQgUsOi1ZQEVJAMdSJodA7WOvi2A8jETieZLpSiUJFcss8AUSTZQs1bYZmEOTG7VgW2UmoTayWzX_kVVJzcSKPuE-wLKbC9BXu9VdMlO5mkqM9FjMSaH42c5rp06VLCTA0yb2HdQY1ZFSGB4i0G1DY0DemodRNFwv79-20S4ajmHX1DktJwyXaciJNKPhdx_hbNAS7ZZ4Cok-yzGXs6LtkRJGVKtpN0XLIdJ-K4ZKdmXLLPGC7ZUYQ9HZfsCOKSHe24ZDtOxHHJTs24ZJ8xXLKjCHs6LtkRxCU72nHJdpyI45KdmnHJPmO4ZEcR9nRcsiOIS3a045LtOBHHJTs145J9xnDJjiLs6bhkRxCX7GjHJdtxIo5LdmrGJfuM4ZIdRdjTccmOIC7Z0Y5LtuNEHJfs1IxL9hnDJTuKsKfjkh1BXLKjHZdsx4k4LtmpGZfsM4ZLdhRhT8clO4K4ZEc7LtmOE3H-XrJlCQcPHmSCmTFjRpEiRYikBwbnGx9DowIe06ZNmwoVKjRy5EgMe968eT5ong4eeeSR---_P27nr_9MkQqwiqjv__7777Qf_ecOYuw_bkCUyqhVELeoVavWtGnT0AtJdvD_9TgngUGGJrF9-3bGmZUrV8bFRj9MefECwfZgPULdIdgXohTWnMWKFevcufPs2bPnz5-_Z8-eVDOOOc7_ir-XbCGNnjlzZvHixX_56x9ZGcy1DD1Az4yLclIYR48e5TGtXbs2f_78w4YNwx7wbNZOcYedCMFNbt--_WOPPWb_N06zMvFRDVWwtXRiukkyRgAJh85K-aguGrisXp9__nm1atVmzJixdOnSNWvWKFLP0UkKsbGxl1xyyaRJk1LNjz3V-NmqGRCw1kI44ZwY7fAEL7_88q5du06dOnXOnDl79-5NHc_Rcf6H_L1kB735m2--qVChgn5yFA8GGiZX-iHpnRSIHtPy5csLFiw4YMCA70L4y4mIg1u_-OKLZcuWbdCgQd26da-__vratWvfcMMN10U5N9988y233HLVVVfVr1-f7a233nrllVfedNNNVO3aa6_l6O23306AyrK98cYb405L8VxxxRVUoU6dOjwpIEylWIjWrFlz4sSJCxcuXLJkietF0pGMbt68uVy5cjSVhx566M4777z33nsbRjn3339_o0aNCNx999333HPPXXfdpbDVjvbfpEmTxo0b33HHHWxPnBPNULVChQq9_vrr8-fPX7Ro0Y4dOxjZfL5wnORwsjfZrNTpYKNHj65evTrr2piYmA0bNqwPsWnTpm3btv3000_0w-3bt291UiQbN27csmXLV199Vb58-WHDhs2ePZslk7-cizisZ6ZPn96pU6e33nrrjTfeeO-99wi3b9--TZTzzDPPtG7d-rHHHnviiSeefvrp5s2bFy9enIVEy5YtEamnnnqKpcWzzz7LIVKyjTstxfP444-3a9fuySefJPz888-3atWqbdu2jz76KNtZs2Z9--23DHdHjhyJe7rOP6GfY3DHevTo0bFjx27dunFjaf80mKiGZs8WjX7kkUcefvhhxWDbF154IUtKugaH6AW0HJxbiaOaZs2atWjR4osvvvj---_pBUwfer6O44TN30s2bm0vcsaOHcuYUrFixQIFCpQtW7ZkyZJFihQpXLgwkReFKFGiBFOvkwLhSfHgatSoUbBgwc8--wwRnDFjhh6rE3GCPz5mftKv0EU1VIE2M2_ePJrNwoULUShWa1gFMdOmTZs6dSppCM-dO5cAKUMnRQEIxIIFC6gdy058gpITJkClli1bNnPmTCp7_PhxnmOUfmh-5rEbZV9MQdztjlpoFTTyiRMnsvSikbD0oqnTC0qXLo1200iIpAnRnEi2ZMmSuNOiFvoydaRSQC_Yt29f3IN0HCdc_vmb7EOHDjGILA3xww8_0PdGjRo1OMTQoUPZDhgwYKCTUvnwww_R63feeQd7YAAdN25cbGysnq8TKex3nqQa7K5ZswYxZW6Oauj4eMaKFStwCybgu---m5Xb5Zdfjo-iFBydPHkyc_P8-fPjTogSVB0CVAFJwq2xCrSb8U3rB6qsr614lBoGnZNz7Ngxfa_873__m16AahOg8UQ1aiF0ZBoMuzQPYu67775ixYrp830aP4MqkUyLixcv1lnRC0sFakr7J2yS7T_5dJzkcDLJZpphggn-0jThnTt3soKnN06aNIktaKJ1UiC4AjOBZAiHIMB8kNhvsDlhE28eOn78-LZt25YvX746ylkbgrps2LCBSbdChQpPPPFE6dKlR48evTkEQ8G6des2btxIZdevXx93WopHRWUhBApQTWpBgIqsXLnyp59-0o_ypIx6rM5J4EYxO7Bl1tAIg3ZzM6Ma2sOmTZt-_PFHGsyyZcu2b9_Okoxe0Lp16zJlyowcOZIBlkM0GFi1alXcaVHL0qVL6QWC1eaePXuCs7_jOGHw95Jt3yMyaNr7CcWwul2yZIl-osSIMz8E9uakQPDscePGscWt9WL1---_949NTwdakcq29RI0FaBeL8tkkVa2bNlFixZdccUV_fv3VyvSNxXBQLRg9hB0aAsH3177m-ykY9MEpIJeoCrQAAjoB4AsxkqWLElfuOSSS4YPH753714iVetU4KNUUz-CIKwOzq57tuMkh5O9yU7I0aNH6XuHDh1ixMG2WenGxMT8_PPPhJ2UzP79-w8cOMBTE3GP03H-CWZcZlk8o2fPnjfddBMxbdq0uffee_XnhpiVbc12-PBhBRwn1cBkx9YWD6-88sq1116Lenbr1q1WrVoSUG_5juMkxqlJdhDmXYYeZtk__viDsJMC-U8IheMem-MkGfsM5tdff23YsOGrr75Kc5o1a1bRokW3bNmiQ6Df-PTPkJzUh15mAy3_-PHjrDPbt2_P7nfffVe5cuUff_xRR2n8JuKO4zhG-JLtOE7qxrx55cqVpUuXXrRoET79---_X3rppcOHD8cq9FMR__dGTqpE7ya01GS7bNmyEiVKLFy4kN09e_Zcc8013bp1O5Hu__5NFcdxHOPUJJuBBljcA1MshF6V_kcxTgpHjwziHqfjJI1evXrVrFmTlkNnxzzatGlz7bXXsqt2pTRR91m245wcSbYtNT_88MOqVasqvH___q5du15--eWE_QM8x3ES49Qk2786cJyzB62o6fV3331369at7Vegpk6dil7s3r2bsH2QarbtOKkJe0vdvHnzFi1asM4kfPTo0W---eaKK67Ys2cPLZ8Fp38u5ThOQvxzEcdxTgYaUbJkSaz6qquuKl--vAIFCxbs37-_3l7rl8P83y87qQwatq0had40_jJlytD-L7744tq1a9esWTNfvnz9-vXjqL9-chznbznlN9kQ-kLkPyc-O_gLxTspFnteJ366728cnaShd3i7d-_u27fvJ5988sILL5QoUaJLly4ffPDB4MGDZ8-erbakV9qOk_pgzGQbGxv7008_vfnmm0OGDHnrrbfoBa-__vo777zz8ccfzwj9D106gn8u5ThOQsJ_kx1Ut7goJwWj56VHFhflOCdFDn3gwAG2NJsNGzZUqlRp8eLFtCVrRfqGxL4kcZxUA-3_j9BvPdLgFQPYdunSpekF6h20fP0VS4bW0HHHcZz_j38u4jhOophM4xCbN28uVqzYunXrFOM4qRt5s7qAefb27dsvvPDCJUuWaFeq7TiO87e4ZDuOkygu2c5Zi0u24zjJxCXbcZxEccl2zlpcsh3HSSYu2Y7jJIpLtnPW4pLtOE4yccl2HCdRXLKdsxaXbMdxkolLtuM4ieKS7Zy1uGQ7jpNMXLIdx0kUl2znrMUl23GcZOKS7ThOorhkO2ctLtmO4yQTl2zHcRLFJds5a3HJdhwnmbhkO46TKC7ZzlmLS7bjOMnEJdtxnERxyXbOWlyyHcdJJi7ZjuMkiku2c9biku04TjJxyXYcJ1Fcsp2zFpdsx3GSiUu24ziJ4pLtnLW4ZDuOk0xcsh3HSRSXbOesxSXbcZxk4pLtOE6iuGQ7Zy0u2Y7jJBOXbMdxEsUl2zlrccl2HCeZuGQ7jpMoLtnOWYtLtuM4ycQl23GcRHHJds5aXLIdx0kmLtmO4ySKS7Zz1uKS7ThOMnHJdhwnUVyynbMWl2zHcZKJS7bjOIniku2ctbhkO46TTFyyHcdJFJds56zFJdtxnGTiku04TqK4ZDtnLS7ZjuMkE5dsx4kAzMdMw3_88Ufc_p9_Hjt2LC4UzVCvX3_9lcDRo0eR7KJFi_744486FNXIn8AkySwKYmNjFQhGOonx22-_KaD2Lyu1e5iaoLXs3LmzRIkSy5cvJ_zLL78Qefz48WDHj2p4dvv377dmb0_WcZzwcMl2nIjx---_My2ZwBGIaqgCAqG6wM8__5wzZ84tW7bEHY5aqAtWhCSBAva28tChQzzB4Pv74B1w_ha7gdwr7l5MTIzidbejF6pAj6Z2NAztUsFt27ZddNFFWmpylK0Zts6KXqzZC-oVL8ZxnFPFJdtxkgtzLVNU3E7qQq-x8Qy227dvz5Yt2-rVq0NHoh4TCFmUwqB4IlVrl-ykQDuxe0hfCN7PqCZev6ZJsITImzfv999_Hxf1F6lmBDh27JiWDaqRv8x2nOTgku04keHw4cNsmYaxNLlpKuCXX35hrj169CiBDRs21KtXb_ny5XHHohZptL2AZI2kmF27dikG9IabgLm4848cOXJEgeDPc6Iae_qqDrv79u2rU6fO3LlzrYKsKGhCVveoxjqFQX3jQo7jnDou2Y6TXA4ePPjRRx81btz46aeffuCBBx588MG77767adOmhKMaanT__fc3atSI8L333nvbbbflz5-_QYMGOhq9UK9HH32UevGMmjdvToBq3n777e3atZNYG0iVaZaTGNLN2NjYp556qkmTJtxMGgk3Nu52Ry3Uhe1DIQg0a9aMmDvuuINecOutt9KK7rvvPuLp7PSOVNDf77nnHvrC7Nmzj4e-Mk8dywbH-d_iku04yYUJqUOHDrVq1ercufPzzz_fsWPHtm3bvvDCC4SjGirSpUuXF1988ZVXXmEXB-0UQkejl_bt23ft2pUAdaF2PCmoX79-vXr14p7oX7hhJwVs7Lffftu4ceNFF13EClN3-NVXXw3d7CiGtqHG__LLL7P70ksv0WDo2oTpGmxpNkRSWbq_-n5U8-yzz5YpU2bChAkMaCycUs2P4xznf4hLtuNEgGeeeaZJkyaxsbH6gwN6IcpEFdWEanYCqsOuvk7GO3U0etFnphJoVYrIwYMH33rrrYT1PTFp4r3Vdk7O3r17K1SooK-JuLfHjh3T3Y5q7ONy-47i999_Jxz8Bh1IqW1Uc_jw4WrVqk2ZMsWqxnN01Xac5OCS7TgR4Omnn3700UfjdlILTLFyUPtzhKnj7xLqj0LIJOxn4m---ea111579OhRfVuPZMvFU0eVTzcsSGJiYnLmzLlmzRrCmJnuXlSDd8aF_lo2g9ZmhtYScTvRT-HChSdNmkRAlUoFD9Fx_re4ZDtOBHjuuecefvhhzUxMw8G3XE5Kw54O5qQw23feeef666_fsGHDrl27tm_fTqQbxinx008_XXTRRfZnN7wLRB2sqMuUKfPxxx_T_rdt26b2773AcZKDS7bjRACX7CgiMcmuWbPmggULVq5cuWrVqj_--APn8OeYdFyyox0GrlKlSr311lvzQvz8889E-nN0nOTgku04EcAlO4qwpxNPsqtWrTpjxow5c-YsXLgQydYXAv4ok4hLdiqAJ9i5c-fJIbZs2RIX6zhOuLhkO04EcMmOIuzpxJPsyy-_fObMmbNnz160aJESOEnHJTsVcPHFF3fv3p0uAME_G-84Tni4ZDtOBHDJjiISk-yrr756bogffvhBCYCnGRdyTopLdrRDU0eye_TosTDEnj17iPTn6DjJwSXbcSKAS3YUYU8nnmTXrl179uzZ-lxECUB_X8X5R1yyox26Q8mSJbt160Yv-O6773igRGpMcxwnPFyyHScCuGRHEYlJdo0aNWbNmiXJ5lHqadofSHZOjkt2tEN3KFGixOuvv04vAP2NHX-OjpMcXLIdJwK4ZEcR9nTiSfZll1327bffoolLlixRAifpuGRHO3QHnuBbb701P0RMTAyRGtMcxwkPl2zHiQBnQLLtleovv_xy8n_DRkoltgkyst88UDvqSID8mZj131sULwgfPXpUkcG_s6ujnMXpukt_S1zq04ZdIp5kX3nlld988813332nb7J19-weOifntEq22jNb-99A_9ikKYBaGk9Z7U2Z6BDNkhjthgE5qw8SsPYv9u_fH_y3r1EE9-fiiy9Gsllqgv6EX3LukuM4LtmOEwFOq2QrN-Zyk0I4-X8iVDLphdQkgv9UQv8xkZxNdLgQzmFF0rU4evDgQcUISgXcJdBd-lviUp827BJ2P9m6ZCeT0yfZkuO9e_eaJav9KHwSKEOQuNgA5HPyfpQY5KYCEFALoVP8bRdLSjlTCC7ZjhNxXLIdJwKcVsnGX4NT3aFDh8jfhCMxIluGIMqZUqm-wXeKeoGtBArbK20gHjhLaDchcalPG3YJl-wIcmY-F8GJtcY7CYldmnjaKg1Sr7GT82R1brBX0pbiQiFbtcz_sbQpB5dsx4k4LtmOEwFOq2TbPL1jx44jR44QOLkfBA0AKdG7ughOlqqdtioPxMTEbNq0af78-Xv37qWcxCT8jCSJ6KzTh13CJTuCnD7Jxon37dtHAEWOjY1V5EmeC4f-8ep0h19--SXsQkqp45WB1a8CrD-1BtZ3I9GCS7bjRByXbMeJAKdVssmWSf3zzz_PmDHj_fffr8iTvMm2YrDVRyah6Ihh8y4OoRfVY8eOrVWr1jnnnJMtWza2efPm1QzNpXU3TolQ3qcRu4RLdgQ5A2-yyZMFJ03u5JknsQOSxlryqWK9L96Fdu7cuWXLFhaZ9gOcCH6mdbpxyXaciOOS7TgR4HT_4iNuMXDgQPy1QYMG5G_vj0-C3FrbeN9GJxMZxvHjx_WOfN26dcWLFy9SpMj8-fMPHDiwadOmGTNmhBLGXZfbIrgtwTuj3YTEHT5t2CVcsiPI6ZNseR7LRZr9TTfdxFJz0aJFJ3ku9lgNcrAfB1m7FeFJMPnrEmxVPNy6bdu2ZcqUoZNCunTpGBOS87L8zOOS7TgRxyXbcSLA6ZZssW3bNn0Are3J0ZfcuAXb11577ZVXXok7kGzwEuzBXuZNnjw5TZo0n3zyCWFNydwH0E1QASwmeGe0m5C4w6cNu4RLdgQ5rW-ytVakLZUqVQqFXbx4seL_lngdkF36y9GjR4NLU0sQ9pvmYB-kkfTs2ROxfvXVV5cuXRoTEzNnzhzWnBwyuU_5uGQ7TsRxyXacCHBaJZvpnAxtUo-NjWX35PJHGcwemObRx8KFC2s3IkgdKAaFGTt2bNq0aYcOHapDwb9oJq2hMECBSQ86BNpNSNzh04ZdwiU7gpzWb7K1ojt27Nju3btZ4O3bt48WpaMJ4VDw6rRVDPvgwYNt27bl4SqSJajShC3BwXZO8W6--eYiRYrs3LkzLirw6wrRgku240Qcl2zHiQCnJNlKRhp0Qa_owDQiOOuTslevXkWLFi1VqlT58uULFSrUpUuXuGMhyISjr7zyysqVK6-44opzzjknV65cffv25RD54CIPPvhgo0aNcuTIwbkE7r777hYtWjzxxBMk0A_NMZh33303e_bsOXPm5FxcwQ6pbPXr17_rrrt27NhBVqGfhJ9TtWpVCrZ379433nijWbNm119_PZG1atUif2C3X79-nMiqgJJUr149TZo06dKl4xJ33HEHcsMhfbFKmADqU7JkSTT93HPPRVMee-wxMt-_fz8JmOa7detGwdKnT3_eeedx6MCBAzqRsulbFO6A5cZWS5GT33876pIdQU5VsukmNNGEt5dOQaTanv2aY9BodYj-QkrFKBlSm9AI1So4fdKkSRkyZPjyyy-JCb6EBvJRMvVBsF9hBCpiuqx-EeyhnKvEFStWzJMnDwEVj0uoMORJdaxGKrOari4qKCEJlDNdkvSKJx8KQDxbq13wvlGkYHXsnoQBRXXJdpzI4pLtOBHgVN9k668lWDJmSsLPPvvs888_zwTMtF2vXr0ZM2ZgD2vXrh04cOBnn33WqVMnHJQtKbkQWzR3586defPmxWuR1AYNGnTo0CFz5sz6aJUE2OeTTz7ZtGlTJLhgwYKPP_74Qw891Lp1a-ZRvIGpmmn1tddew27fe--9yZMnv_7661mzZq1du7ZJBvN3zZo1S5QoweyLf2PVL7zwQoECBXSU3QceeECSjUDj7o8--mirVq1efPFF-Ur79u2feeaZBQsWjBkzBl0mmfyeOnKXKEPp0qVR8Hbt2mG3-NmQIUM6duwYyvuEM7F4QM0__fRTrJeKU6977rlHsz4lZFGhF5NkzuKBAKWVpuj2JobddrRGYbYu2cnklCTb_FLPCyxmz549CsgdsU8O0R2KFy_Ogu3CCy-kQW7btk1pgIf4ySefsE7DTV999dVs2bLRTm677Ta6AEd5fKNHj37qqaduueUWmh-PmCZKV6UvTJ06lQS6Lo2NBCznSENT51xs1eSV3bJly44dO3bOnDm5c-fOlClT_vz56ZUc2rp169NPP01uFIDTae0sO8mfTidJZblIHyRPcr7gggso_EcffUS8nFvdBPWn81JB0tDgacwjRowgXt1wxYoVrF3pJsD6dsKECXZvOZ2wxFphArt376ZSqtcpQQ4u2Y4TWVyyHScCnKpka3IlGWqimJdffpkpdvny5YRRgVq1apl_kIwpGfk7__zz8U7TPs3Tmrw__vhjRfbq1StDhgz2Y3F0lmT4KHaimOCsuWzZMoyhSZMmcft__omCkCGl0ts7yoBh58mTp3PnzjIbSohP682iLGTcuHHnnXeeXp-TuakJgaChcgqCcvXVV8ft__ln165duZY-5gbzY7nFxIkTqQg3NnTwBKgMawCWFugUxWO1ULdu3blz5xJToUKF--67jzQsV3bt2kXA7l5C7OlwZxRm65KdTJIu2bQEniBNhV7AOlANhvtMW92-fTuyu3nzZtoAa6dLL71Up9Cq33zzzQ8--AALzJcvn94oawu4NS3w_vvvz5EjR5s2bapUqYJqt23blkPkTwNr0aLFVVddRXOiI9BPH3zwQRaHkyZNIgEyipXSMlmszpw5k1aHB9MpCFMw9YIBAwbQBbBnckCjaepZsmRhXcoh6tu8efN7772XlslZDRs2ZJeVJKK8bt06MqeLsQqle9Jx2OLiCHpMTIx1E_1CM_bMEnfWrFkjR47kQhoHsOdVq1Zx6csuu2z69OnTpk2j-5B4y5YtFIz-SA_q0aMHKcmNqqlG6pth4JLtOBHHJdtxIsApSTYzIglQCqk22z59-jBJM8USf_nll-O1zHB6F6UPJGDlypXMr927dw9Oe6hk-vTpr732Wu1SgMGDB5MMQWGutWJUrly5UKFCwYKRObvYA4mZv3_88ccNGzYwqet98_jx40mj4jHBozWhk05gZkNiVIkAWsApo0aNCvooBSN_FIdIRGH16tVTp04tVqxYvXr10GgioXbt2lgRu2RllZIc4z3YUvbs2RcuXEiY4pHJs88-y4WY_jmXNGxxGpRl48aNCAeFfOqpp5LyAs9ugkt2BDnVz0UMGokaEj2Clo9ixsbGLl26lB4xevRoOsv-_fvVPHi4jRo1woat7dFaaOe9e_emYRQvXpwHSqPldBoD2hpsDDSbNKFfzzW7FVy9ZcuWLFO3bt1KmWmN-Cu5Pfnkk0pAJgg3MXj8pk2bOEphGjduPGLECAK6BIVBf8uVK8elLSZ0dtxKWJGU9v3330-bNq35PevDwoULU9QdO3aou2mJCDQ8Ym6__fbMmTPLd0k_b948Vtp4vNKsWLEiV65c2DmHBg0axB3T_afLWIdKOlzOJdtxIotLtuNEgFN9ky2wB07p378_U3iPHj2Yv--44w7mcvvjCWgHW3IDLJNkuCATKjM3oBpA5PPPP68fsjNN4iXEjBs3TieeyOXPP0uWLFmlShUKpimTyZ5DJH7ssccwj0yZMnFKlixZ0qVLRwDsvTgFqFatWunSpQkzcytDTf-h4yeYMmUKOSD38ont27crnjSIe_Xq1XPnzo1eo7DkXKdOHR0FZvRSpUoRoBaKsQC3Ap0ifcaMGUMlOvFjdLYYRlBQqAhqVaZMGYo0f_58EiBMpimJYbeFAivM1iU7mSRdsnnKLNWw27j9EOvWrbvkkktobIT1Q4xXX32VMC3WhJXH_eijj9Ik9LL20KFDMubWrVvz6HnuNJtQwj8xV1oX59IIOYuYL774gjQTJkwgrAzZqgw5c-ZkZcs6jUZFDJ7NirRixYo0eJ07fPhwLvrBBx8QJg1bqkDjURjoJqTXWpSy6SwirY4IK8117ty5VAppHjt2rJq6Vs7Bv_xDmclB_Ys0HK1ZsyZh_ciLbk4M5m23d8GCBcToffZrr71GmHUpYXXGU4KLumQ7TmRxyXacCHCqkq0vIjRJb968-bLLLitbtiyzvt6ZdejQgfh4r9zWrl2bNm3a3r17Sx2I0VVIf9NNN4WSnHDToUOHkmzUqFHMspogCWAAmKjScJbN_Q899BCnjxkzhjJs3LiRKZ9ZXO_O0SAJir6CVXpDBSBnjGTEiBFItj4XEfgEV6HAWPsNN9zAWiI2NpaLVqhQQR8AYA_cKww7V65cWkgAd8N0Cu677z7KNnXqVORpy5Yt5IZnALfF5Ia7gY29--67VBzzyJ8___r164mn8CeRY3s6lF9hti7ZyYRHk_Q32bQrJaCx0Uo5l3aSNWvWrVu3YqIo8t13383TsbYBehBqscHnS1uiARC5Zs0a_ZgFSUXW7VMTLkT8-PHjSTNo0KBgwQiTmHhaEVvBspMtbYkE9FMSfPXVV8RMmzZN7VMOTQEoIQH1pnr16mmFALRPc1OSvffee9wZcmCtW6lSJQJ0cw5RKnqr3q_Tj4ixhg1chTZPYq2BtdUyuHLlyiTQLwcDS2Iiu3XrRlFvueUWbiMnSuJPCZdsx4k4LtmOEwFOSbKDKqmZEonEg-vXr0940qRJWHLPnj1Dx-OmcHLGgNOnTx_vr4sgoOedd94999xDePfu3WzHjh3LjDty5MjQ8RPXYuqtXbt2sWLF5ASKVIBkEnftCmZ3zazaVq1aFUVACKiUSQ9p5Nkwbtw4DGDIkCGEbUpGF9Du7NmzY8lWBQyDahKWpjRu3JgEkydPPnHCX-IukBsypCJffvklgk6MLq2FB2Hum350rnd4zz__PIn1JatS2kvNhNjTccmOIKck2bRAPW576Dhinjx5BgwYQBOqU6cOqy89zWBLgwYNGmClcTt_Pes333yTFqjfGaDh8ciuvfZaVpW0_FCqE82Sx5olS5aBAwcqN-sLtBNaTq1atTZs2MAVV61axYKTMF1S3YRzp0-fjoVPmDBBKgx0B7NYmTGLZBzaLJlsKTm7tEzMePjw4eoavXr1ovxkqJYsP9Y7crDVrzLfvn073fPee--dM2fOsmXLKN6KFSsQ6B07dlgXZkHLGhi_p_tLyps1a8bpVpKkw51xyXacyOKS7TgR4FTfZJvemcPpy4oWLVoQRluRjIULF-qFN5Mfc-qSJUuYcdu0aUMMlyAHzX9Mq4888gj5KM_Ro0czqbMlhl3JBGpCstWrV8swiMdcZbqYAddiFte0jbXExMT8-OOPhAFNYf7OmzcvYaVHDpQJs7iqMGbMGDIfNGiQvIGtFIoY4jt06MAuUsLkzS6erdMpHlchBhlCl4mhOlxi0aJFUhnsIWPGjMz6zPcyBupC2TZt2kSY8mPYnTp1IvzZZ5_hZ_prErpjKlhi2FF7CmxdspNJ0iVbDclWQTJLnv5LL71UoECB-fPn8-hZgF111VUmteTGWaShqbPU1LpLcHrbtm3PPffcrVu3skvr4pFddtlltBx27fGhyDS2YcOGaRfU3miu5cqVUwvnXBVbrUh9B1iL0qdoIYRpzEEV5hRV55prrilYsCAB-yUKdU_MnsKQFV2A3VGjRpGVvuYiku5Gp6bh6Sho2QDkTO-jYVM8xQDJ1Bds4dqwYcNChQpx86k-XenBBx8MQ68FV3TJdpzI4pLtOBEgvG-y47Fr166lS5dqzl6-fPnmzZsJ2Nu4NWvWZMqU6bXXXpMNa1bmlPz58wf_PMiXX36JTHz--eeErRiTJk264IIL0qRJg-PiLsWLF5eqwooVK5hZOYXpHJ_GckqUKNGzZ08ZM_NulSpViJd2aP5WCUEzPZJNwYYPH06Y9KEjJ6DA-uQjc-bMqMaNN954zz33sEtuW7ZsUZohQ4YULlyYSC5aq1YtwhkyZODSmtonTpxYunRpjubLl4-zLrzwQrLSK3NcZMqUKRSAe45ecB8QL92Zf8Rui0t2BDmlN9mJQfOmHfJA8ddbQsQd-Iubb745a9as8X5MwUKORqJfS1ATpSS0HFqRGiQtduPGjaTp2LGjfnZkDZVDvXv3Jk_aqvoaJSdA6zXJ_vrrrzlXLZw81WyCDYOGhwoju4TJP-jZdM9s2bLt2LGDVr1gwQKaMVnNmjVL16IX63cPOnfubM2eItkvNrRv356-o9901FHqTtkIUIAPPviAfq1fx2SJbreL8oTRbl2yHSfiuGQ7TgSIiGQz48plgTnYXm6B3pkNHDhQMx-wq_kPx5UUSotJMHfuXJ3LXGuisHLlyv79-_fp02fw4MGfffaZIgE3Jc306dM59O6773IJ_F5VUP4IAfmzK7dmG3xVxrnIDWVQwXQ5k11ketq0aajAjBkzrLRcnVPIR6KDHyPTRL7__vt4zNq1a7mWFZuVxsyZM7_44ovu3btTNtVU2E2mslxR-QtOV2n_FjuRZAqzdclOJsmXbE7hOdJC1DDWr1-_KPTn3vVk1fAaNmyIPcunFbl37156H4tDWrhOpLOwMrziiiuUhj4lKb_uuuty5szJOvPyyy9nnYlNEskpZPvQQw-xuuNozZo1L7vsMsw1V65cHKVPcS0aZ8GCBVm4WkmsfQp66-23384q0boGxaYYBDgXgy9WrBj5U6pWrVohsixKX3jhBXUTin3DDTfg2Tg6LbBGjRp58-Z96aWXqBdH2T755JM5cuRgeXnppZfWq1ePQKlSpfQuf-HChfQXNXW6MGECQhJ_SnArXLIdJ7K4ZDtOBIiIZJub2ulmePZz88QgpQxDpyABNt8HhQBjMHdHILiQzjJkBiAvsSmWbOMZhnZJZoU0uIRdBeLdDbtisGCkoTzSBSBPCwNHUSW7P_YrX_Hc2pA5xe0kwMpDARRm65KdTJIv2Wpy1gKBVmS7ppJffvmlYkBtadWqVcOGDVNKNarx48frr9AEQUwR5TfffLNXr17vvfeeiqr0lHbJkiWsBjkKJFMDVpFiYmK--uorKkgZgr0s2Py43MiRI-1LEuAQ0A7XrFnDChbb1l8NYt3YrVu3BQsWELaPQzjEErdr164dOnQYO3asDFtXobVPnjyZJShlfu211wir_au-lIdS2d1mV_6tkp8SnOuS7TiRxSXbcSJARCRb8zdTpqZPMiGgPDkkxWTu1PSvyc-mUhNQpIFDbGUPFhNPFg__9YfGOMpVzIlJppy1RRHwhqDgGuYHevuOIgcNgwLbFZUVEEOlrGDkSQyX0Dt40H1TAg5RKvKhnJYDReVyyplDwCl2oSRiT4cLKczWJTuZRORzEZ6IGoNarNaWRBK2NiCCiygSqDEDKdV9hH25QXOltShPS2ANT5CJtXNlGG-pRg4KqHbkE69fEK9WrV1lQie1K9Kk1WcVo_qqGROOV0cInshR62KcYpcmXgUjwBXDu_NAJi7ZjhNZXLIdJwJERLL_FqZeIKA51WZW5mZN4RzlcqDdIEzMELfz14RNMk6J99NkYpj7OUThTREMZl9FmtOza5cjrLkfI6EY7J4o8V8mHQ-OkoZAcPIm_-B1LYE5kF3LsrXTScM9UckV848ofyA3hdm6ZCeTiEi2YQ7K1h4B7UQtIV7rUiO3ZLRGrk6rYKuU5srWSMhHYspZHLVzOcvCnA4EzHR1OnlaAQiQHpW3s4jRWYaKp_5FIJ64B2EBqUvQPXUJymPpFaDBWzfkuorU1W1wOMklToJLtuNEHJdsx4kAkZLs4ASvgE3nNoOCLqFDNqFqCjcPCMXFYZYMTPkW1inaClIGE1sxFGMXlVVzYsKakj9F4hA2wFFyIxJ7wBuQg6D0C3IGy8cC5EB6dkF1N-cGxehcoZRCMUqZEBIoQF0UZuuSnUySL9nWNnj0wbACQANQc1Lm8Rq5sOdldkhitRYC9uMX81RrVFyIdkv-1tHMreMR9E4uR7b6YY62KhvxKolVJDY21q5u3zvRj3QWKCsC6tHUzi5ESVRxy42s7K02KEwOqo7yOVW4hEu240QWl2zHiQCRkmyb0myKVZ7Mf-SpiZb4oHAzrco2SEBiTcPBBKATgTSCsDzYTIVsg1ahNJyorEimGKXXXM61zIHsipahYBeNsKOkJ6wLmd8A8Xb1eIUH2Y9uhS0qIOgZgkKSTMRFJUAVAasUW5fsZJJ8yY7XcoTuP05JYws2Y2s8tBaahJq9ciCZ-o4FgpChnavWKM21xhBsYEAmpGeJGK8lqLnGi9RusO5kToZ_27btUxYuERMTY2EL2I-bKKdyZmumDrZUsFuXsO8kHa7oku04kcUl23EiQEQk24RVp7PV3MlWr74Uz1zIhbgKWxMCpt7g_CqNIEPN2cqZfJRG2SqSiZxMglMpR3W65MOqQ0olM7VVDsz0BDikbK0YurS2wl7amT1wSvDSIFuianiJyRDoEgqwVVa6DycOnwr2dLi63WqX7GQSKcmm_agJKQc9X2vnpCHMIR3l6Sigc81lDVqLcmNLVuo7OhQPa0jxstLpVgDLISi7nKsEZr3KTW1VYWVru-pEFJ6-oEsADV5tXr0AyEGZcF0gYIlB_UgxZGuXoGxWkqRD_i7ZjhNZXLIdJwJERLI1R9q5zHmaazXLaksaRWrL_KqpFzgUnBFVGCKZiTk3YZGUQKcrWSg6Dpuk5TQElN4KgyXEm4CVwMxYAdIonkxkA5ZA8Wwpg7bKkJRmMAm1SdilzX6Sjt0Kaq0wW5fsZBLZb7KTA13DTJTHpxZCeaxItMCEzYaU8dqzmu7_sCJnGDqgS7bjRBaXbMeJABGRbJ1u55KPjDY2NtamOh2N9xf9UAqUF2UkTEo7qtMNzNUyJzGn6Iqm19iJLiS1VWIiLWe2YJZMAqVheiZzeT_s379fEkP-hw4dsmSCZHqNp2yFSY_9DJ0YuxAV0atr8iEctKgwsMK4ZEeQlCPZoKZFI6EVaRmp1kupbNmm5mrPlwAEi004HkoTdzjJ6Ny4nRAJY1ICLtmOE3Fcsh0nAkTqm2zQBAxx-3-BmOrtMoewT23jabRBvITA5FVKwVnE4Bk6kQTSEekmEM_2xAl_YbsWCMpxPDCtVatWEWDCxt3t6pxCmBwUw67-mq9gVyYEFEBlM9hNTKkTJk4KwYoozNYlO5mktDfZ8QpAr1Qbs9arRsUuh3jKlp4AuyaXtqtWag016ZCDMjEUE3c4xUDVXLIdJ7K4ZDtOBIisZJOPzW2EmfyQv6effrpx48bNmjV7__339-3bZ_5qkBJ71r-xCL78FuYWQVROybp9oaHvv7XLIcmxqgYmtQSIBNKALtepU6fcuXPj2ZyuV4YLFix4_fXXH3nkkZYtW_br10__FF3GL8shzOkE4FDob2Cbf-ta9upRJeFuKJ5AwpuQFOzpuGRHkBT1JhvUNugptBb95IRmxtPU6-1QkjjidQ1KTrLEnnvY9eJELmRNLgXiku04Eccl23EiQKQkWzlwOhOeYo4cOcK0lylTpksvvbRNmza33357wYIFr7vuOtxUV2GLlZqnkt4-F7F3dQgQAWzDhFUQA3E7f30HQnqKwZYwmRO26hCQH3PUXocLrkVk796906ZNu2TJEkVOnTq1UKFCuNcDDzxw__3358-fP2fOnNu2bdNRwVk4EJe2q-jSXFcTvHSfa-nmGCQLFiDpBC-kMFuX7GSS0iRbYi0mTZrEY508efKsWbO2b99uv4Arj4xXVGvwbOMdSt24ZDtOxHHJdpwIECnJll-C6eOOHTvOOeectm3bKoaJcO_evWvXrtVR3FQmDUHp1NR4-PDh4FcZII3-NYTtLlu2DIMfO3asvcxWRdCUeBXRtZQ5W_K3xQAZEu7Zs2eGDBkWLlxIDIWpWbNmtWrVgp66adMmtvruhatbgW1hoAwPHDigwMyZM-vVqzdixAgVVVsgTyw_vPtsZ7lkR5CUI9lcmsZjjZm2xLo0W7ZsefPmpStBmjRpOnTooCerjmDQJGjk1ioUmUxo5PFaEbvW8lMO3DSXbMeJLC7ZjhMBIiLZnGVTrwJktXLlyvTp048ePToYD_qoA-mUl7M7b948fQ9NMeLpMp5BVkyimzdvxto3bNgg-VY5Mct06dL17dv3xAl_fbNBwGqxa9eu9evXU5LVq1ezi90Gp14y37Zt25YtWwh_-OGHSMz48eMJU4YLLrjgiSeeCKU6MYXbEiLIsWPHKNK6devwb3vFKEg_bNgw3OjTTz9VjP3NE8pgdTxVrF4u2REkpb3JDv7QJleuXCwj9SgXLVr02GOPZcqUqUGDBsE0QOeiBYIWeAZ1UffBv7XOPCW4LqfT2MgBCLCbAtsVZXPJdpzI4pLtOBEgIpLNifZejQmPLTP6ggUL0Na6detqztMl9EJXabZv3_7UU09ly5aNZBkyZCDQv39_4kG5MWsWLlx46tSpr776qpLly5dP74bff_995AM3yp49e548eQhce-215cqVGzp0qISYy02ZMoWrI_qciDR36NCBePtZPGZfp04dDgEz9PPPP3_--efPmTNHJSxdujSnLFu2TGqi20KYgAq_du1arsi5FADvuemmm3Buio3u9OrVq3LlyhSJozVr1iTzKlWqcK3BgwcHJ_4wpMeejkt2BEk5kh1sEmoqrCHvvPNOW6FBjRo10qRJs3HjRsLWbUkQExOzZ88e-4GJoJ0Qc_jwYdaT9iOXU4K7wZpwZwgC_8ObcxJcsh0n4rhkO04EiJRkxwsA4SeffBIhKFCgwOTJk_UCG8wDbr75ZjS0d-_eiO_WrVvr16-fNm3aUaNGcUhWMXDgQOQbgyxfvjyGigbh04MGDSLnRYsW4bLt27cnh6ZNm_bp06dv377vvfeePqo-FPpf6FyaPNetW4cfUE1s--WXX-aoLLxIkSL58-efOXMmV__000_JJ3fu3NOnT-cQfP7558QA8m2LBG4O2RKmCmhZpUqVZGZoLikfeughVW3u3LkUplmzZlTnnnvuIQyUkMS6z7rJwU9vk4g9HZfsCJKiPhcJPjV2Weldc801cmViWMV9-eWXOXLkePvtt5UGaNX6noTeQateunSp1qh6292lSxcaNn2BZSpLU5T98ccfpwfBmDFj6BT0zVA2J7jllltKliwZ1HH6XcWKFcmcHCjMV1999T-8P4nhku04Eccl23EiQKQ-F1HAFCE0if8bsUaFCxYsyCR92WWXMUPrKDAXItDM95x74MABTmSLB9StW9fm-A8__BBPveKKKyTov_32W6dOnXAIHYVly5ade-65CAfXYvdY6K9ly6FvvfVWHBp3JwbnIJJi4BDbt29nF-vlWmPHjiWeGZptjx49uNbChQvZldDMmzcP92KFkDlzZmoR_MZDVo2R_x6CDGvUqFGqVClVH8UnMG7cOE4kW2Koo72ktFsUBnafKbDCbF2yk0nKl-zgemz58uW0vSZNmhCmrb755puFChXq2LEjZjlnzhwaYb58-ez3Gbp3754uXbpXXnmFHkRzrVKlCuc2atSI9sM69pNPPsmUKdOCBQvsTTlrwuzZs9u3KKNHj8bC6aTr16_fuHHj9ddfz-mbN2_W0ZSDS7bjRByXbMeJABGRbDA_kNQGf_CNnup1GjM01yKGSR3hRoLfe-89fWVBJDMlqooi7NixI3TenxzllBEjRhBWwTDa0JE4g1yxYgUJ9FYvKCgEcuTIwbyL6WKfkydPnjp1aq5cuchcCRo2bMiJ-l3Gw4cPU4YBAwYQs3jxYiUAlWrgwIHlypXj0CWXXLJy5UodqlmzZpo0aciT9FOmTEHW69evTxq95wYyHDlyJB4_ZswYqX9y7q1hObhkR5CUL9mEWfixCiXAlpZGP0KFaW8ZM2asU6dOKPmfe_fu_eKLLzg6bdo0eTYLy-LFi5tDs_wj5s4771T37N-_P4lpxjQnoMHfddddNGwlhrJly2LtpuwzZ84kfc-ePbWbcnDJdpyI45LtOBEgUpKN_lomCIHCzOVSVbLFUO---24m6aFDhxLzzDPPEJ44cSJhUPqbb745Xbp0u3fvZspn9-OPPyaN2Q-uwFWY8vWmGZYuXZohQ4YPPviACzHREsOWK0KWLFnSp0-vH6MTJhl6gTGQhsLgJeiLvSAk5z59-uDECxculCirAJQKSNa6dWvyYav8yYfdQoUKsT3vvPMyZcpUpEgRdGf__v0yEs5iFcHRUaNGqWBclGLr9qLdQOBUsadD8RRm65KdTKJFstnSubZv304foSvRBoYPH07DbtmyJR1h0aJFs2bNevfddzNnzty5c2eObtiwgRb4-uuvc6JeP9N9iLntttsIA4nZnTFjBmGaPafceuut559_PmWgR6xdu5aj99xzD51iyZIlCxYsYMmaPXv26667TqenHFyyHSfiuGQ7TgSI1OciJr7xREHvcQngwTt27EibNm2LFi2YzjFjXGHkyJEcsvS3334787rc95dffhk2bBj--sUXX-hTDZXNSki2kyZNIj1ZsXvo__59Dy506aWXErB4LioDpqhVqlRJkyYNczNXIZ7I7t27k5U-6ZYB79mzBymxV_IlS5ZE2RUuX758gQIF5CWKsXfYdh_mzJmTNWtWrSK4CmpOVlZ4O_GUCJ5ud8MlO5mkfMmm8bBLG8N9V69eTcdp3rw5Mf369aPR5siRgy1unStXLgLQpUsXjrLAI0zzYNXKLjnT4FlJ6s_mkGePHj1Yf86ePZvmpE53_fXXs1yk2bM7evRoTqcAbMmcq7CMJEz_JWWKwiXbcSKOS7bjRICISDanywMUVgCjxVZNUmHr1q1M0m3atCG8adMmwk8--SRhGeeuXbty5sxZq1atE0lDp3_22WfM7tiqMjExpZB6PYxwkEmnTp0Uz6VJgyKgI_fee2_69Om5ContRAyYMLz66qvou_5gH2fBHXfcQVYTJkxQSvssVfJBnkh26dKlCXCXOnToQOIpU6ZwSGUjffDl9IEDB8aMGZM9e_aPP_44LioEF1LJIXhnkog9HaqgMFuX7GQSFb_4yK7Wb2---aY11L59-xLu06cPYZoT60l1Q1kmzZujnTt3JixopQg6Jq1d_b4vC11rkzSk8847T7sLFizAql955RUcncxZc9LyWe6G0W5PNy7ZjhNxXLIdJwJE6nMReQBoDiYrhK9379779u1DeWNiYlCERx55hEl98-bN-rq0fv36pqHENGvWjKMDBgw4kUuIDz74gJjZs2cTNg8IcuTIkaJFi9asWXPJkiVcF8NQzrBw4ULOLVeuHK7ALq68fPlyZU6ySZMmZc2atUSJEnPnzl26dOnVV19NPhRG18IknnrqqVmzZmEtmqp79eqVK1euN954QxKzdu3a4sWLY2aTJ0-mXuj1zp07R40atXfvXrNzinTuueded911HGJ3__79lJYAOSiTMLCn45IdQVK-ZNuPR-hNBQoUKFasGC2N3UWLFhUsWJD1IVVgV-da-VmCpk2bltUmYfXK6dOn2_cnJP7oo4_oI_phC2d9_fXX-s1ItU8uQbhu3bp0XnZZXrIFLTtTFC7ZjhNxXLIdJwJESrIF-UglmYnHjRuXIUMG5unSpUujAueff36WLFnsG2VgLrz55pvTp0-fOXNmfDRb6E-MUQbN4njkwIEDc-TIIQmwbE04UGFK2759e3LOmDEj0pwuXbpbbrmFQ5zLVShAyZIlKQCXoAAEcG7pCHTs2JFTiKSQTZo0-eyzzwhIsrEKhJtDCA2nEObQY489pmlbywn8Rr_KWaRIEVSGAhQqVEiKb5-OtGjRgnhOz5cvH4Vs3bq1FBxfCc-z7em4ZEeQlC_Z-p9HLBErVqxIi1q8eLE6EX3h1ltvpVv17Nlz-_bt6hqs7vRX-egstWrVypQpU__-_Xfv3s2Kl55Ia7S_TIKP0oCvvfbaOXPmINysG1FV8ueouhudi8zZrl-_nvR79uxhhWy_R5FyoGwu2Y4TWVyyHScCRFay44Gtoq2ffvrpJ598MnPmTCY_zXxMiroQ202bNs2YMYNpftu2baGTTkSSTCZ67Ngxezf8tyAWGzduxC-nTp26cOFCPIBI01zOXb58ufK3vw0C5E8arrhs2bJ58-YRg5Fw7qFDh1QwJAOz6du3L4XHKpAMfQ3CUdMgird27dpJkyaRgEBCb-bqP_74I7M-ZUPKd-3aZRM_mQQ_L0kiKhu4ZEeQlCPZYE0XaFEs8_BgVnFsWYvefffdPGgdlWfT-B944AGOYsPFihVjiyV37dpVwk3iEiVKcBTw9VWrVpGA_i6H3rdvX_PmzXU0TZo0dNKbbrqJpaOVgUxatmzJIZap-fPnZxnMSvLGG2_U0ZSDS7bjRByXbMeJAKdVsoEMcU1N-YmB4NoPo4FTKI_eRv8WIu5A4lByLoG26jUzV7SKEGOZm5saXMLsmQsFJVjfiiA6wbKRA8mC1VEh43ZCJQnmA-QAKliQMCQ4WCmF2bpkJ5MUJdlA66JRqcGwbmSxBwixmjeP1Z6srdPWrFnDSnL06NGs9-wPU-onQrGxsVOmTJk8eTJnkQnGjJSHTjoBiTnKQpEVILv79-9HxHUI1IwPHDhA5gMHDpwwYcLmzZuT0h_PMC7ZjhNxXLIdJwKcVsk2GxDkbzFM1cFXufFSUgwgUsTFJgD9taMEmGvBJlcCFsZOMF3SJL2CwXzinUVuXDp4dbD0VI1rKRwP0siT4vZPESsGmSjM1iU7maQcydZf0ZEcq7nqIWLMNOwTKUJYS7Mf8qjMxMuAtUv_Yjfeq_FzzjlHX2mTxlqpvvDW1YECcFZwJfmP6-T_Ldwcl2zHiSwu2Y4TAU6rZDPNM_-RJzkzo8d7B4akKkCCk4jpP6L8E8orMTbRBpWCMIe4okGMDoFyA7snnCh3B6URROqlI6eQmIDigymJp5rkAFxI-QQvd0rYiS7ZESSlvcnWH500r7W2FFzU0QD09yiBSHatN0EwHFzKxsTEFCxYkP5OHUE_8LH8FQ6eC8EYEtCGFU5R0K1csh0nsrhkO04EON2fiyTkJPJ3qlc31wxCzD_mQxmCxQg6K0qBSRCjQySz3Ii0-L-FEzmdNHYKpxOTsDzEhCEBwZIozNYlO5mkNMlWwwg2j8SaCgJtTxk1t2UeaGUYtxNqDMqkR48eI0eOTJih_Vkefa5NehqzCTrtTQtm7aY0XLIdJ-K4ZDtOBDgD32QHbY_Z-mgI5kUdYi6HYJqkg79CcO6nCnq7HLf_13cpbJM46VISK4xeP9s94Voq6i-__KJLcEiRyjx47unASuKSHUFSjmTTdPUaG_T41NLiFclaMs0ASBls21iyPXr9XoHC-hqEJq0Y2i1hpQyeDsEvTICrkzhu5_--Jk8hcItcsh0nsrhkO04EOAOSzawMNvHHI7ErEg-cldiJBsVGNeJ2QjDp_u1ZRCpbwYmkTLo0qCJxOyHIkBziXT0hdi10nBzCnv7JRwGuqDBbl-xkknIkm0urgamdEAg-RI6yK2hCQCDuWKhJ2GIPEGWO0uQIo9dKiVWHDp5ArZGAtV6O6qL6D5EJwfh1SkqDurhkO05kccl2nAhwWiU7OM-Rc8L8g5YQLzGHiMEATAISI5gtAfMAcrD8CciGLUawq_w5EcOAYILjx4_bmz-2UhDgFOUWrI4uES9GaJdDQRR5SthZdmm2LtnJJKV9LqKmpTAP8ciRI8RoF9T24nZCpQ1-dW2NX43WWizYoeDpwOlkgkAT1nt0tRz7PUhd8X9-W04CxXPJdpzI4pLtOMmFObhjx46NGzcmrKmXmQmYZaMaKqKtKbLQ0eglrhqhesmK4KOPPqpRo8b06dNnz569YsUKlChoXc5JUPNYu3ZthQoVFi9eTPjw4cPYZNztdqIE1gZVqlRBsidPnkwv0P9YTZkv3R0nWnDJdpzkgpC1a9dOko1wKDIVgC1pimUVYS_hmIxDB1MJVp133nmnTp06uMW33367cOFCOWIwgZMYahg7duwoXbq0_j40DSa4KnOiApp6mTJlunbtylJzwYIF-ouEjuMkB5dsx0kuCOgzzzzTvHnzuP0U8LPyiBCshYWDPzqPUkygBbvHjh3r3r37lVde-d133-mLkbhjTpKJiYnJmTPnnDlz4vadaIN10YUXXvjaa6_xEBcvXoxk__p__7iK4ziniku240SANm3aNGnS5Jdffjl69OhvIdA4Jq2oRp-0akvViKFSVFBHo5rjx4_rAVE1Vap___516tSZP3_-999_r38RD_qaXGEnMfTbgbT5iy--mBtIjJYxutVOtMD6uVq1aj179pwyZcr48eN_-umnVLCidpz_LS7ZjpNc8ImWLVted911X3zxxYgRI8aNG_f5558PGDBgeJRDdUaNGjV48OCRI0eypV5Uim3c4aiFSg0aNIjaDRky5Mu_aNWqVY0aNSZNmoQmLl68WE8WcVTA-UdiY2OLFCnSoUOHzz77jNsbd6-d6OHTTz-tWLHihx9-OHv27OnTpx86dCj4syzHccLAJdtxIkCXLl2qVq2KpV100UWXXnppmTJlSpcuXSHKqVSpUvny5anLJZdcQu1q166dKVOmunXrxh2OWqjOxRdfTI30jBALHlyBAgUaNmw4duxYDGP58uV6rP6z8qSzcuVKbmbNmjWrh-CWhm62EzXQL_LmzfvKK698_fXXU6dO1d9I8ZfZjpMcXLIdJwL88ssvhw8f_vdfn1isXr16xowZ-ktY0cs333yDdE6aNGn69OlUZ9q0aQ0aNBg5cmTc4agFjaYuP_zww6xZs2bOnEl44cKFxH_--eeLFi2aP3_-qlWr9IdHDhw44C-z_xH9d0PQp0SsTNjGxsbqbjvRAi1_woQJ8-bNW7BgAf1i165dPFMNaI7jhIdLtuMkF_tTuL___jueQWDt2rXMVXFzV9SChiKgVAQrxUfR60KFCnXr1i3ucNQisV6xYsWcOXNYSIwfP54A1fw-BIuKJUuWuFsnHXmY_uKhJJsAS5S42-1ECfQCoGvQCxYvXrxnzx6eo_8wx3GSg0u240QY9OLHH39k0kLmohrEeuHChRMmTGAL7dq1y5EjR9OmTZmJ0W70FDGdP3--ZuXvvvsu7rSohfrOmDGDqq1evfrAgQNxj9MJl7jb6kQJ9GUaPwHGLhbYW7duZSiLe5aO44SFS7bjRIB_h_6kNNu4_b_-u3JUQxWOHz_-r9C_ZSFw_fXXX3XVVUWLFt2zZ49i_vOf_zANU3ESaxvV_Pe__6XK-vswcU_x__4dQ-eUiLutTpTAI2MEI6A_qhMczRzHCQ-XbMeJDJgZM1PcTmpBr7Ko2u7du4sXLz5ixIhy5crNmjVLRyH1_VvEPwL_jhvhOHz4sMKOc7bBKto_F3Gc5OCS7TiR4d8hFGZyws9wtaiGikgxqcuHH3548cUXHzly5KGHHnriiSdCtTxBcF0Rd1rUQhVkFcF3eMGwc0rE3VYnSjh69CjdmS4Q9_xC-E9yHCc5uGQ7TnLRlxLMUjYhSbIVjmpsxr3jjjueeeYZAgMGDChTpoyrp-OkYhjKjLgox3FOHZdsx0kumKjJaGrCTPrXX38tVarUzJkzmXE3bNhQqFChb7_9lkgtJPQFcyr4sbLe5wEVBz1WiDvsOGcBNHj6tV4c0Atcsh0nObhkO45zMphrR48ejWT__PPPx44dO3To0H333ffss88SD0qDmKYCyXalcBzHcSKIS7bjJBf8Mihnev0JofehUQzq_Ntvvx0_frxjx4633XabakdNP_zww8svv5wAaagmkaTRKVGNKiioHVVz504OcbfViRISNnj1grgdx3FOHZdsx3H-nmMhEOgrrrjiscce69Gjx_Dhw_v169e1a9dy5cqNHz-eNPpWxGdix3Ecx4mHS7bjOCdjwYIFNULUqlUrffr0N9100zXXXFOqVKn-_fsfOnTI_8KX4ziO4_wtLtmO4_wD_wr94ZQdO3ZUr1593rx5v__--_79-_Wn7jhEAv-swnEcx3Hi4ZLtOE6iYM9Hjx4l8J___GfLli2FChViq0OAZ9uvPPoXI47jOI4TxCXbcZxEOXLkSFzozz83b9584YUXLlu2LN5763-HfmUw9f23S8dxHMdJDi7ZjuMkin6vUX88ZPXq1VWrVl26dCkx7NohOJHUcRzHcZwALtmO4_w98ewZyS5Tpszy5cv_-9__6lNsQ_-6Im7HcRzHcRyXbMdxEkPvqg8ePKhdJLtgwYKbN28-duyYYuxjEotxHMdxHEe4ZDuOkyj63hr-85__oNfFihVbt26dYhzHcRzHOQku2Y7jJIpLtuM4juOEh0u24ziJ4pLtOI7jOOHhku04TqK4ZDuO4zhOeLhkO46TKC7ZjuM4jhMeLtmO4ySKS7bjOI7jhIdLtuM4ieKS7TiO4zjh4ZLtOE6iuGQ7juM4Tni4ZDuOkygu2Y7jOI4THi7ZjuMkiku24ziO44SHS7bjOIniku04juM44eGS7ThOorhkO47jOE54uGQ7jpMoLtmO4ziOEx4u2Y7jJIpLtuM4juOEh0u24ziJ4pLtOI7jOOHhku04TqK4ZDuO4zhOeLhkO46TKC7ZjuM4jhMeLtmO4ySKS7bjOI7jhIdLtuM4ieKS7TiO4zjh4ZLtOE6iuGQ7juM4Tni4ZDuOkygu2Y7jOI4THi7ZjuMkiku24ziO44SHS7bjOIniku04juM44eGS7ThOorhkO47jOE54uGQ7TnL57bff4kIhjh07xtb0NHr517_-9csvv8Tt_Pnnli1bMmXKtG3btrj9aOaPP_5QgDoePHiQ3V9__dUigV228Z6s4ziO4yQdl2zHiQC7du1avXr17t27jxw5QvjAgQM7d-4kENVgn_v374-JiaFeGzZsmDFjRvXq1adMmRJ3OGrZs2cPC4bY2NiffvqJ2hFz9OhR6kiYR_n777__5z__-e9__6snawHHcRzHOSVcsh0nArz88svFihW76KKLcuXKlSFDhuLFi5cqVerCKKdAgQJFixYtXLhw6dKlqRrb8847r2rVqnGHoxbqkj9_frY8srIhKleunC1btttvvx3hllXj2Zj3v__9b5dsx3EcJzxcsh0nuaBibdq0ueuuu2bPnr1q1aqFCxf--OOPK1eu_CHKWbFixdIQ80IsWrRow4YN33__fdzhaIYntWTJEgJr1qyhgnPmzOnUqdONN96oB_qvf_2LLZ7N1r8YcRzHccLDJdtxIsAzzzzz6KOP6jtsfc6bCsAy9X35oUOHFAOp481uvFocOXLk_fffr1GjBuE__vhD9fV32I7jOE5ycMl2nOSClrVs2bJFixbaPX78uD7qxbmjGlUHLMz6QYeiGiryr3_96_fff2cJwbPjSbHt3bt3rVq1VE1BAvdsx3EcJ2xcsh0nArzwwgvNmzdH3UCfGQCKFtXor20QUHUMHY1eVAse02-__cbz0u67775bt27dlStXTp06ddasWayUFO84juM44eGS7TjJ5dixY-3bt3_44YdNryH4x--iFH33oopQR3lnKvgYRi-zAeG2cNeuXWvWrDl__vy5c-euWLFCj_Lo0aNaaTiO4zjOqeKS7TgR4LnnnjPJxtvsdamTArGn869__Uthtu-8886VV175zTfffPfddz_88AOReprBhZPjOI7jJB2XbMeJAC7ZUYRLtuM4jnMGcMl2nAjgkh1FuGQ7juM4ZwCXbMeJAC7ZUYRLtuM4jnMGcMl2nAjgkh1FuGQ7juM4ZwCXbMeJAC7ZUYRLtuM4jnMGcMl2nAjgkh1FuGQ7juM4ZwCXbMeJAC7ZUYRLtuM4jnMGcMl2nAgQnmQfOXLE_mcNZ7FVDsgfENB_fiG333___aeffurUqdOECROUQPFsyYSz_vjjj9jYWHaDHDp0iK3-iYxOEfv372f722-_KQEojZWHQ2zJ9ujRowRUNuCKpLRdKx7bzz__vFmzZtyEJk2aUE67A1ZBApTBzqXAugoxilQtCBw7dkyl3bNnD1uhOwMUgHDwXIWFKqIKJoaVjasozNYl23Ecx4ksLtmOEwFOSbJxU8mrIVuVINohM2DAUPv06ZMlS5Y777zz4MGDxJAs4VXwbCLNC3_--WcFTENNtQ8cOBDvdAxbARyXrcnx3r172Zq2Uju2OooTkwnbu---O2PGjHXr1n366afvuuuuG264YcOGDTJmOHz4sAKGZW51tKurdlZg7oyVOSjT8di1axdby-Tk99-OumQ7juM4pw-XbMeJAMn5XITEQaP9_fffiTGHtte6s2fPfuqpp959991QwjhP1bte5HLfvn2h6P-v0XLlHTt2oK2EEW5JfExMjF4GEyag9LJ8Sq402uUsea3ekcu2QR4MSsylzznnHMpGnkqvkuPxbFUMXYUyKAEXsnhVljCn6xK6OmGlIZ57ogIrT22VLIjuid2KxFDxQFdXjEu24ziOE1lcsh0nApzqm2wF7M2rYZ98KAclkKFiokikvFNbkOZKLu3NccKrFy9e_JJLLtFLaEEOtkv-uG-wMKbRJLNrgS4HFkkM9o9kI6nsxruESk55pMVADKdwo5QVt-Jvi22irGR6F45qazfeK22O2ut_3UC9YldMQuyQS7bjOI5z-nDJdpwIcEqSbYZqSkp6vFBqa5FYL_q4ZcuWSZMmDR8-_NNPPx03btxPP_3Eod27dyOIeo09ceJEpBABHT169Kuvvvr222_v2LGDeLyWNKtWrdq7d2_p0qWLFSu2devWDRs2bNy4cfXq1SSQ3VIYzPXDDz9s167d---_v3LlSiKBIslcv_jii8mTJ5P_ihUrunXr1rFjxyFDhhCPzpI5mRCJZA8YMIDyk_OuXbsomLQYG54yZcqbb77JWT169Jg7dy6RXE6X1rciMTExo0aN4uqPP_74sGHDFi5cGFxarF-_vnv37i-__PK7776rr1_k3-RPkQiYBJtnQ8LVSxB7Oi7ZjuM4zunDJdtxIkDYn4vgefa5M9aIYhKDQSLWeuGNoRYoUKBUqVLFixfHZblQ8G0xRkskCnvnnXfmzJmTcJo0aapVq4ZlIrLknClTJiKzZ8_OFtKHKFOmjDQXli5deuGFF-bKleuGG24oWLAgafr06UO8roIQV61atW7duvg3h4oUKZI7d-6MGTOGTv3z6quvJjJdunRsiWSbI0cOtjfddJPObdiwYeHCha-66qobb7yREzmET-tc8dlnn50f4tZbb8VxL7744ipVqsQd-_NPbkLZsmU58aGHHlL-I0aMIJ7bSwVZVBDG7Ddv3jx__vzQGSegala7v8Ul23EcxzkDuGQ7TgQ4VcnGp_XNg-ngypUrCxUqRD6EBw0aVK5cubFjx-oQkCf-jWg---yz0l8ucfToUfJBPYsVK3bNNddMmzZt586dDRo0IGb27Nk6cevWrYcOHUKUSUNg1apV20JwiNN37NhRp04dJFsfQ3N65cqVkfXQqScKyfayyy7LkydPyZIlP_30U3YHDBhAOfVVxs8__7xp06a-ffsi8d27d8fpkf4tW7boKPo7d-5cLqo391yagt177716zcy9opBIOSVfvny57gZXxJgJaBe9vvbaa7dv3757927qyz1heaDM9-3bR6meeeYZwlT83HPPZbVA2P4giX3mnhB7Oi7ZjuM4zunDJdtxIsApSbYdJSCRXbt27eWXX45uksP06dMLFiz4yiuvEC-fBoQVicyQIUPv3r3ZNfPD0dOlS5cvXz77WGLgwIHZsmX76quvfg38DZO8efNWqFDBrFHZsuVaiO9nn33Grj4y6dOnDyo_ceJEyoaDQqVKlUijz0goxoEDB2bNmkVYL9pJ8O2335JgzJgx7OoSVEqX0CfUIPctX778ddddZ39R5M4778yaNatyI2e2Sq8tNk-2lISwaNWqFWWTAQPyfd5553Xo0IFrvf322_j6lClTiD_5tyJg95_CK8zWJdtxHMeJLC7ZjhMBTkmykUgl0IfLW7duLVmy5NVXX038tGnTkGa9oD127FjQ8ObPn490Ipra5So44t69exHNBx988JdffsF6sdvRo0eTbNSoUdJ3IJ8aNWrkypWLsFwWZLovvPACie-5557HHnvs6aef7tSpU-XKlc8__3wEl8wlu1WrVr344ouVm_3-Iuj9NNuxY8dSZv3ZEwqseJkumUyaNImbc-2116LXLAbKlSunl_cUmFoXKVKEMNibbE6katTl8ccfp2zNmzd_5JFHHnjgAbYsQojBg0mpO4PZs_DAsDmdBLlz50aRiVfJE8Ml23EcxzkDuGQ7TgQI43MRySgMHjwYr23fvj3hBg0aZMmSZdGiRYT1G35Ip7Jds2ZN5syZ33rrLcIgVSWTbNmyNW7cGCtFGYnRy2m9AEZkJcdXXHEFRmufpujSiCnyiqMjr2j6zTff_NBDDxFz33336WsTElCRS0OEzotDF6Ka2s6cOTNHjhxffvll6OAJlD9LiLvvvrto0aJNmjTRb21yrRtvvJFstbooUaIEpVLi4Ncdyh_1pyKNGjVq2LAhAk0AU3_iiScWL16sl-hkws256KKLWEJs376d_HPmzEmCUB7-uYjjOI7zP8Yl23EiwKlKtqkbxokHd-nSJXfu3AMGDCAG1StevPjGjRsJB3VQ3zR369aNXQku7N-_n0h8VLuAsmfKlGno0KGEZatQpkyZKlWq4KbSU20PHDjw7rvvpkmThlNCqU683j5-_LgM2M4tVqwYKmxfnlAkuzolhwkTJlCG4cOHk63qJZtHu88991wKbO-VWUtcdtll2uVEakoM9dJRbNu-JDl48CCVKl269PLly0lJjOWsb7L132dq1qyJWGPYmzZtyp8_PysEIlX-kzyC4F1VmK1LtuM4jhNZXLIdJwKckmSTTCIIu3fvVswrr7ySJ08e_ZWMW2655brrrgsdj1NG_BXtxmV79uzJri7BIUQZy3z00UcVCWPHjs2ePfugQYPwURWDwPXXX1-hQgXC8V4b46bk2bRp0-B3IHi_AnJxRBb7xHT1XjwonVyO7ZgxY8hEf_fDzoXXXnsNg1-4cKF2t2zZkitXLkoiSyarfv36ceLzzz9vdwNUZq7y1VdfZc6cuVmzZroKtbBCkoayPfjgg4ULF96zZw-SXa9ePWqhd_-UQSVPDHs6LtmO4zjO6cMl23EiwKl-k83WXFASCW-__Xbz5s0J7Nix4-qrr9av8emNMolXrlyJknbs2HH__v2W_88__4xkN27cWO-AMVHclGTjx49XAuKJ7NChA5GtW7f--uuvp0-f3r9_fy4NWGmXLl04dPPNN_fq1YtDH3_8ccuWLfWH9igYRS1btmy5cuVUZnu9bQGqPHDgQHL48MMPFYM9q3iTJ09Gglk59OnTh0tXrVo1U6ZMxYoVmzZtGmch1myrVauWJUuWBg0aDB06FMF9__33cWX9LRFyuPXWW9OlS4dMkwNnffHFF4Tnzp27a9cuSn7VVVetWbOGZMOGDWNZcuLaod-GZBtcMyTE7p5LtuM4jnP6cMl2nAhwqp-LiGAy_acV2LlzpwLIsQJiy5Ytd9xxx2effRY0SFzzrrvu6tmzp76p4NKzZs264oor2MrgJcdYe6tWrVDh3Llzo63ly5fXS1-IiYnp169f3bp1OZo9e_YqVao0atRo4sSJeidNGajX_fffr8KYcQbfWCOmd95556RJk7TLFakXHDt2DPNGo3FrJHjs2LGrVq0qUqTIpZdeaq-3ceLXX3-9YsWK-fLly5EjBwrO1Yk3ie_du_eFF16IqVNyAhzVn-oTeikuWHvoPf0_YrfdJdtxHMc5fbhkO04EOFXJRqnN3vTn7ThFIkvg0KFDpo9Hjx6VLoM-RBZE6jvpn376SZeTZ8dDf6wjbuf_YpeI97WGvBz0dpwY_akQ8lcJ2ca7FgsAtnJc-bFlYrpsV-Fc6g76VAbwYwXsLNIokmspB05XMYCArUlIGawgN1PrB__FR8dxHOd_i0u240SA8N5kSwf1VljaSg72y384q70wJkN7TYteK7HkMvj6Vj6qo0IlsTyDh4QZKufaUSIVtj_5R4xSIq8KUFRKEhR082nQ6SbNOkWJzZVVNtXRXJZMrNZEaiFhdQyW3xzd3rLbbU9YzSCWzCXbcRzHOX24ZDtOBAhPsk8rFAOpNQE9uXeeBE4kE3JDSQmcRDp1SGId_JDjVCEfbuDpu4eWs0u24ziOc_pwyXacCJCiJNvcURDWi-RT5ciRI8Fvr_8RVV8ftygcnmpzrqDkIu5AhLAMXbIdx3Gc04dLtuNEgJT2Jvv48eO__7_2zjQ2q6prw0wtUKDMKPNgEwoKAsYwiIAVoYABsYy1kCJQxopIqgSZigwdEKIGIsg8aoUqUgGhCgHLIBCpzIRCGWSyUigoqPF934uuZn9PHL5AedqUcF8_TvZZZ--119n9c52T_Zxmb31Gec16cwEZ0FCTXW6KU4vkXP4X6JPTyi1MB8xrMLWRc_m-Ibk1JNlCCCHyDkm2EF6goEm26aNhkVzv3_g9m5yTbB-9Y77_sqPDGbZzcc9N27nAZrEZc0L3jStbki2EECLvkGQL4QUK4J5sA4-kHgq7nxfMlsTaCDdtywmed-r6ZGVlef4cs6AhyRZCCJEPSLKF8AIFVrLh6tWr7oMe94T7NgiNn376yZ3ipqbdf5Fs9w0T9_ba8xV4wUGSLYQQIh-QZAvhBQqUZNsnom_fvu3-bU3uXmO7Xz2aT1v7xo0b2ftH7ny-2jNueO7_pmfuDJV5KZgp_p7fK0iyhRBC5AOSbCG8QAF8k71mzZqBAwcuX77cvYHOHe5ecPfExMTBgwebAf9dsnH6IUOG9OvXLywsLCgoKCIiwv7Pzr2SlZWFoDMdys5cXl9Pl02SLYQQIu-QZAvhBf5_yXaiRvyXX35BQHv27Mkpkmevft9___3evXtnd7nTB4WlYcfMzEwi8BdX9nxnbG-s3X9KN0aNGlWqVKnhw4czi0VIaH5Mm4Qc7Z03EfufLwaX3JtvNxaYMTo6ulChQmfPniVueawM24GdlpY2YcKE0NBQ9LpBgwb0dCVZhe7Nus0OrIznVpb9-_c__fTTvr6-jC1dunSVKlXeffddzxfqHFkHm85ODbdBxU1h5cFfdoffWUpJthBCiLxHki2EF7gnyUYiS5YsuXHjRiKmzpMnTw4ICLAOFsEsMVQzxYsXL3K0IMfLly-b2ppl0nYqbJ8QsdNdu3Yhjps2bWJ215MjPuqp1J4OilvTx3knRwZSg9tsPWXKFCrfvXs3bVeVYVPTkyHkR-6LFCmCjhO0sp312g3Sx6oCU2T8uG7duu3btyf_uXPnkF2ePaZNm2Z9DJK4taXhKei0udNTp07t3LnTItyae1oArtpSuAySbCGEEHmHJFsIL3BPkl0om6CgIOed8fHxlSpVouHGOm92ONO1BubqOYvzZmeu4AQar7W5Tp8-bRF742v6ayZKZ8-xmZmZni5uZvzWW29R-aVLlzzVk0t__8kjC4Jk48q0XVq6WQer3KTf7pS5tmzZgsGvW7eOU6CPlWcw0OXhErdDDebc7pGD9ssvv1y5cuULFy5Yz4yMDI62Vm5JaVtDki2EECLvkGQL4QXuSbKrVav2_PPPY6tr164leOXKlXnz5tWoUYO2aeW2bdumTZvWtWvXzp07Dxs2LDk5mYG2v3nGjBmxsbE0PDl16tQ777xz5swZuq1YsWLixInYMBkIcimnU3Zh9uo3MTExPDy8V69eCxYsOHr0KIp_6NAh018KoBhup3fv3pGRkTExMcePHydukh0dHe3j47Nnz57vvvuub9--LVq0YDriYBKPK9MgSVRUVNmyZW07ClV5fqU7KSmJ2Xv27Dlu3DhqZnHM8jdu3MiaUBJti9ik9OFo4PeLFy8OCwtDpmfNmmUSz3Tc14YNG1JSUtq0aYPc0169evWXX36ZkJBAB8tmawvuryPJFkIIkXdIsoXwAvck2RUqVMCV69evj9XhkShgXFxc1apVrc-1a9cCAwNbtWo1cuTIsWPHVs5m-_btXCIPQXT8yJEjnNqrWY7jx48nW2ZmJtK5ZMmS4ODgTp06NWrUCGddtGjRnaTZoL_UNnfu3OLFiyOjQ4cObdCgQbt27YoWLfrJJ5_QgUpmz55dt27doKCgN998MyQkxM_PD9FnXjNU25P90UcflSlT5oUXXmjWrBmnQ4YMMcOmG_lpcBw8eDCXqMciQAZuNiIigvo7dOjA7I8--mjNmjVTU1N5fmAsSViE0qVLU4zZOXBT1mBZyNC8efN69eqZZNOzcePGdpVL3G-xYsVIzryscPXq1QsXLtykSRMeM6w8vckWQgiRn0iyhfAC9yTZOO7q1avRXxNW4shrQEAApmg7NA4fPszx6tWrWOm3335Lt8mTJ9vwjIwMHx-fqKgoe8trvyz09fUdPXo0DXBbRD7__HM01F6WE8zKyiL_hQsXyNajRw-rkHi_fv2Q0RUrVtimCzAltWPLli0xVyqx_uPGjWM45moaynBkl9nT0tJITsSBedPTXpwjyug7GbZs2UJw_vz5lvzEiROcvv7667SZneD69etr1apFEPW3yg3z4wEDBlSsWDElJYUVpnNiYiI9Y2JiyO-knIcTTB0jN4G-cuUKQVt_SbYQQoj8RJIthBe4J8nGfRMSErDS1q1bN2_e_Pz58_Hx8Y8__rj1wbPdLgvc9OTJkxUqVBg-fDhJbEdH06ZN8UjTayzWdlnQzTZFAP7NWHPQZcuWoZKuACYiiEqa5sKqVauIfPzxx7QJ_kW1w8LCuOpeJ8fGxpYsWXL__v20mRpIWKJEicWLF1sHsDoHDhzIQO7FloKbJWHbtm39_Pysm_2ss0WLFv7-_laePWBcvHhx_PjxBEn71FNPHThwILv7HVOvXr1648aN7ekC0tPTce5evXrZKTBXt27dWBxza-B2eEJw9TPRzz__bCWBJFsIIUTeIckWwgvck2SjjwsXLuR05cqVxYoVmzdv3qxZsypVqmQ_RsRc8cLJkyd36dIlICCgdu3a2GpkZCSXsFIUEwv08fH54IMPzLmx8_DwcBq2McNtrV63bh0DP_30U1cMYwcMGODr63vq1ClmIYLN4-jlypXDxTlFOvHRlJSU_v37M3XNmjUfeeQRkmRkZJjBT506lVNzUGPt2rV485QpU2g7_YVRo0bRk5vl3t0r5KJFi1arVq1Ro0ZBQUGdOnVq1aoVU1epUoUOFE8xzGJyf_ToUctQp06d06dPk_n48eOc1qhRA6vmyaRjx47PPfcckeDgYGZhoK0eV3mGsUWwe3S4StyCSLKFEELkHZJsIbzAP0q2kzmgTRwXvHXrFoqcmJjIKe6I2OGyr732WmBgoPU_ePCgv79_69atEd_k5OTU1NQiRYqYZBuo4ZNPPolb46ObNm0i265du-ySGSpcu3bNXHzFihX2Hte2c-CgiKn9lpFqCSYlJRFZv349EXpGR0dj4YMGDUK1jx07FhoaytUzZ86YwSPTKPXZs2fNnol88cUXdJg9ezZtg3u8cePGmDFjiKenp1sQ3yUD-luvXr2YmBhmGTt27MSJE2fOnBkbG0sqy-a5YtwCjyIkmT59OqfcI-2WLVvGx8e_8cYbc-bMIQOPIrbpnFU1xR8xYgTLxX0ZRCwz0EGSLYQQIt-QZAvhBe5esjG_EiVKrFy50vZ7bNiwoXDhwg0bNixfvjxXiYwePbpOnTpum8Tp06dx04iIiOvZWE7kEuPctm1bSEhI-_bt3e4IBz3dPhBs1RWGnuKgO3fuxErt83bvvfdesWLFcGUE_cSJE1WrVkWsaVMMAymmbNmy7pPYeG3RokXxb9r0gbi4OKQcN6UzOYng38ir7cm-fPkybSL0p_L69etXqFDh0qVL2cn-7xN-QMPqIYM1YM-ePSSJiopiLKLPOnTt2tUu4fE2CmxeGtTQtm3b4sWL07anAltz94dgHejpTslgbY6SbCGEEN5Fki2EF_g3ybaGYYaH81WpUmXt2rVuo3CbNm1QyVq1atGmf7NmzbDegwcPckp_tI-r2G1235yvbWDVZcqU6dy5M8a8dOlSs3Pb04xx4vHkSUhIYODWrVsJWhkUwCnJO3bsiI8Swa0phm7Lly_n9OTJk7R79OhhQ-jfrl07IvY8ALGxsZwuW7bM7hT5JtVjjz2WlpbGqbNeCA8Pp6fnBpKbN29OmjSJ2RctWuS-Yw2UbUKMW9Pf7gW4izlz5lSrVs0-6getWrVCoLds2WKnwECrxJYlKytr5MiRtWvXtl-Ogvt0oNVmnd0fRZIthBAi75BkC-EF_lGyOXU-B7SxOrwZ0bQ90MaOHTt8fX3r1atnu4rXrFmDntaoUWPQoEHdunWjc8OGDWvWrBkXF2fOSn4a9o08hBJhNb1mOrNVE8rExEQfHx-M1rMGdPmVV15hIGZcsmRJf3__cePGlSpVyj53nZ6e3qFDB6527dqV2UuXLo1kU9uwYcNSUlLIM3HiRD8_v_Lly5ME4Q4KCqIzKmzJ3Sc-gOHlypW7fPky90vcdm5g9jxC8HjA8b1sQkNDg4ODr1-_jh9PmDAhICBg6NCh8-bNW7ly5ZgxYypXrty6dWtLS59jx46xSgRffPHFuXPnxsTEsD7du3fPnvAO3Pj8-fMp6YknnojPZubMmefOnUPcbW0phqNbEEm2EEKIvEOSLYQXuBvJBiKIXUREBCbHKepp8jdp0qTx48dzyXZWfPbZZ6gnzjd27NiMjIyNGzeGhIQMGTLE7aO4devW3r17BwwYsHTpUosYJpHGkSNHENbk5GR7N0wl7uqHH34YHh6OgO7evXvz5s1YaVJSkl3KzMxkFFO_9NJL69evR8qZF6nFwvHghQsXotc0RowYgcj269fPvitimc2krb169erIyEiyWZDZbXEYu2DBAiSex4amTZuSfOrUqdbn0KFDOHfLli2rVq1asWLFZ599dsaMGbZTxe3tpmCeClq0aMFYjtg_Os4Nkp-jPWMkJCR06dIlMDCwSZMmVM5C2VigHvc5QpBkCyGEyDsk2UJ4gbuUbE5NBE18b2R_4e569qcwbIMyp5if5y4Ly4C5WtBtjwbyE7cONrXlp21vf21PCJDT8tP_xx9_tCDQs0-fPpUqVTp__jxlMIX5rr0aN2zHhZVtIMoc7fHAwRTWsKtktj0hDLQnB7Ah1oE4Qzha_YYJOtj6MNDGko3O7k05QXTZ7shu3GAUt-wqAdtGAnZfhpuRntbmKMkWQgjhXSTZQniBu5RscNLmhNJzgzKYc4OJprNAc0rAF51uksRtO_bEjNzG0t85Pcdp06YtWbLk6NGjly5dWrVqlb-_f9--fV1y9xtKGwKMMi0GUpn1AjUwu_muU3CC9HenNMjjlN1m8VR_a5Cfbp5r5ZyYoFsxk3JrG-4Sw93iW8RgRip0QbLRdhNJsoUQQuQdkmwhvMDdSzYRM0izVfNO3JTOnqLpvJZuJqMYrb0JNoH2lFeLcEqQhM4pSevsGWzekJCQypUrFypUqEiRIn5-foMHD_bsAxcvXnRmyezkpMHRhlud7nW1TW1HcKmsg3sYAKfU4PKTyt7N2yMHN8gK2CK4RkZGhq0V0J-7c6dnzpyxBjCjK4N5XdutBh2sbWlBki2EECLvkGQL4QX-UbILINSGfaKb169fR8ppm0M_VEiyhRBC5AOSbCG8wIMi2YBZ3sr-1y23b9-m_RBKpCRbCCFEPiDJFsILPECSDdRJkQ-tPkqyhRBC5AOSbCG8wIMl2VDwK8w7JNlCCCHyAUm2EF7gwZJsyqPUAl5k3uFuXJIthBAi75BkC-EFHgjJpiqDOh2c5lx-aHC3LMkWQgiRd0iyhfACD4pk57QebiTZQggh8gFJthBe4IHbk_0wI8kWQgiRD0iyhfACQ4cODQsLyznJ_qeGCFzOiSjAuP9rExcX17Zt2-TkZCR77969RG57_HtLIYQQ4l6RZAtxv_z666-jR48eNGjQX_7L4H9EgcTU2f7HpLUJLl--_Jlnntm6deu-ffsOHDhgQT0pCSGEyDWSbCHuF3RtwoQJjRs37tOnT3BwcPfu3Tt16hQSEvKSKJB06dKlb9--3bp1650Nf7XQ0NDAwEAke8OGDXv27Nm7d68puBBCCJFrJNlC3C9__PHH5s2b33777enTp0dHR8fHx0dFRUVGRg4QBZLw8HD-Oq---uqwYcNGjRoVERExfPjw_v37c0xOTt6xY4eTbL3MFkIIkWsk2UJ4h6ysLPcjuR9--CEpKQldEwWQrVu37tq1y7Zf79y586uvvqJNY926deg1wdTUVPs7otp6pS2EECJ3SLKFuF_-_rIzPT0djUPXRAFk-_btqPbXX3_9zTffbNu2bdOmTXg2kr1v376UlBROv__--99--42_o15jCyGEyDWSbCHul5s3b_7H45t9t27dOnfu3MGDB38QBZJjx47x1zmUjTUOHz584sSJ48ePp6amYthpaWnuN6xCCCFE7pBkC-EFTLJ___33P__8E8m2oCiw8DfiLwWe76rdB86JW0QIIYTIJf_97_8AVMf8AmKStyoAAAAASUVORK5CYII"
                }
              },
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 2",
              "stepic_id": 0,
              "task_files": {
                "src/IteratorDemo.java": {
                  "name": "src/IteratorDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.ListIterator;\n\nclass IteratorDemo {\n  public static void main(String[] args) {\n    Collection\u003cString\u003e members \u003d new ArrayList\u003cString\u003e();\n\n    members.add(\"ALA\");\n    members.add(\"BEATA\");\n    members.add(\"KAROLINA\");\n    members.add(\"MONIKA\");\n    //pobranie iteratora\n    ListIterator\u003cString\u003e iterator \u003d ((ArrayList\u003cString\u003e) members).listIterator();\n    //przeglądanie kolekcji\n    while(iterator.hasNext()){\n      String currentMember \u003d iterator.next();\n      //usuwamy element\n      if (currentMember.length() \u003d\u003d 3) {\n        iterator.remove();\n        continue;\n      }\n      //wstawiamy nowy element za bieżącym\n      if (currentMember.length() \u003c 7) {\n        iterator.add(\"KAROL\");\n        continue;\n      }\n    }\n    iterator \u003d ((ArrayList\u003cString\u003e) members).listIterator();\n    while(iterator.hasNext()){\n      System.out.println(iterator.next());\n    }\n\n  }\n\n\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eIteratory\u003c/h1\u003e\n\u003cp\u003e\n    Rolą iteratora jest przechodzenie przez wszystkie elementy kolekcji, bez względu na ich typ lub\n    rodzaj implementacji kolekcji. Iterator można traktować jak wskaźnik, kursor, który porusza się\n    przez kolejne elementy kolekcji. W danej chwili wskazuje na bieżący element i daje możliwość\n    pobrania lub usunięcia go, sprawdzenia, czy istnieje kolejny lub przejście do następnego elementu. Iteratory implementują interfejs generyczny \u003csamp\u003eIterator\u003c/samp\u003e lub\n    \u003csamp\u003eListIterator\u003c/samp\u003e:\n    \u003cul\u003e\n    \u003cli\u003e\n          \u003ccode\u003einterface Iterator\u0026lt;E\u0026gt;\u003c/code\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003einterface ListIterator\u0026lt;E\u0026gt;\u003c/code\u003e\n    \u003c/li\u003e\n    \u003c/ul\u003e\n    gdzie E to typ elementu kolekcji\n\u003c/p\u003e\n\u003cp\u003e\n    Najważniejsze trzy metody obu interfejsów to:\n    \u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003eboolean hasNext()\u003c/code\u003e - testuje, czy w kolekcji jest następny element\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eE next()\u003c/code\u003e - zwraca następny element i zgłasza wyjątek \u003csamp\u003eIllegalElementException\u003c/samp\u003e, gdy brak elementu\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003evoid remove()\u003c/code\u003e - usuwa bieżący element\n    \u003c/li\u003e\n    \u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Przykład ilustrujący wykorzystania iteratora do pobierania elementów kolekcji:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\npublic static void main(String[] args) {\n    //utworzenie kolekcji\n    Collection\u0026lt;String\u0026gt; members \u003d new ArrayList\u0026lt;String\u0026gt;();\n    //dodanie elementów\n    members.add(\"ALA\");\n    members.add(\"OLA\");\n    members.add(\"ELA\");\n    //pobranie iteratora\n    Iterator\u0026lt;String\u0026gt; iterator \u003d members.iterator();\n    //przeglądanie kolekcji\n    while(iterator.hasNext()){\n      //jeśli wielokrotnie chcemy odwoływać się do bieżącego elementu to należy go zapamietać w zmiennej\n      String currentMember \u003d iterator.next();\n      //usunięcie kolekcji\n      iterator.remove();\n      System.out.println(\"Uczestnik \"+currentMember);\n      System.out.println(\"Liczba uczestników \"+members.size());\n    }\n  }\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Przykład ilustruje typowe wykrzystanie iteratora do przeglądania kolekcji.\n    Pobrany z kolekcji iterator ustawiony jest \u003cb\u003eprzed\u003c/b\u003e pierwszym elementem, a wiec nie wskazuje pierwszego elementu.\n\u003c/p\u003e\n\u003cp\u003e\n    Znacznie większe możliwości posiada \u003csamp\u003eListIterator\u003c/samp\u003e, który posiada następujące metody:\n    \u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003evoid add(\u0026lt;E\u0026gt; obj)\u003c/code\u003e - wstawia nowy element za bieżącym\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eboolean hasNext()\u003c/code\u003e - testuje, czy w kolekcji jest następny element\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eboolean hasPrevious()\u003c/code\u003e - testuje czy istnieje poprzedni element\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eint nextIndex()\u003c/code\u003e - zwraca indeks następnego elementu\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eint previousIndex()\u003c/code\u003e - zwraca indeks poprzedniego elementu\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eE next()\u003c/code\u003e - przesuwa iterator do następnego elementu jednocześnie\n        zwracając go\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eE previous()\u003c/code\u003e - przesuwa iterator do poprzedniego elementu\n        jednocześnie zwracając go\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003evoid remove()\u003c/code\u003e - usuwa bieżący element\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003evoid set(E obj)\u003c/code\u003e - w miejsce bieżącego elementu wstawia obj\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\n\u003cp\u003e\n    Iterator listy ma o wiele większe możliwości, dając możliwość\n    przesuwania się w obu kierunkach, dodawania lub podmieniania elementów w\n    kolekcji.\n\u003c/p\u003e\n\u003cp\u003e\n    Przykład poniżej ilustruje możliwości iteratora listy:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\npublic static void main(String[] args) {\n    Collection\u0026lt;String\u0026gt; members \u003d new ArrayList\u0026lt;String\u0026gt;();\n\n    members.add(\"ALA\");\n    members.add(\"BEATA\");\n    members.add(\"KAROLINA\");\n    members.add(\"MONIKA\");\n    //pobranie iteratora\n    ListIterator\u0026lt;String\u0026gt; iterator \u003d ((ArrayList\u0026lt;String\u0026gt;) members).listIterator();\n    //przeglądanie kolekcji\n    while(iterator.hasNext()){\n      String currentMember \u003d iterator.next();\n      //usuwamy element\n      if (currentMember.length() \u003d\u003d 3) {\n        iterator.remove();\n        continue;\n      }\n      //wstawiamy nowy element za bieżącym\n      if (currentMember.length() \u003c 7) {\n        iterator.add(\"KAROL\");\n        continue;\n      }\n    }\n    iterator \u003d ((ArrayList\u0026lt;String\u0026gt;) members).listIterator();\n    while(iterator.hasNext()){\n      System.out.println(iterator.next());\n    }\n\n  }\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Bardzo ważną zaletą tego iteratora jest możliwość manipulowania\n    zawartością kolekcji podczas jej iterowania.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 3",
              "stepic_id": 0,
              "task_files": {
                "src/ArrayListDemo.java": {
                  "name": "src/ArrayListDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nclass ArrayListDemo {\n  public static void main(String[] args) {\n    List\u003cPerson\u003e arrayTeam \u003d new ArrayList\u003c\u003e();\n    arrayTeam.add(new Person(\"ADAM\",\"CAŁA\", LocalDate.parse(\"1997-10-14\")));\n    arrayTeam.add(new Person(\"BEATA\",\"CAŁA\", LocalDate.parse(\"1998-11-24\")));\n    arrayTeam.add(new Person(\"KAROL\",\"NOWAK\", LocalDate.parse(\"1987-01-04\")));\n    //dodajemy dwa różne obiekty, które mają te same dane\n    arrayTeam.add(new Person(\"PAWEŁ\",\"NOWAK\", LocalDate.parse(\"1993-10-22\")));\n    arrayTeam.add(new Person(\"PAWEŁ\",\"NOWAK\", LocalDate.parse(\"1993-10-22\")));\n\n    Person a \u003d new Person(\"KONRAD\", \"BAS\",LocalDate.parse(\"1986-08-13\"));\n    //dodajemy dwa razy ten sam obiekt a\n    arrayTeam.add(a);\n    arrayTeam.add(a);\n    Iterator\u003cPerson\u003e i \u003d arrayTeam.iterator();\n    while(i.hasNext()){\n      System.out.println(i.next());\n    }\n    //usunięcie\n    arrayTeam.remove(4);\n    arrayTeam.remove(a);\n    i \u003d arrayTeam.iterator();\n\n    while(i.hasNext()){\n      System.out.println(i.next());\n    }\n  }\n}"
                },
                "src/LinkedListDemo.java": {
                  "name": "src/LinkedListDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class LinkedListDemo {\n  public static void main(String[] args) {\n    List\u003cPerson\u003e arrayTeam \u003d new LinkedList\u003c\u003e();\n    arrayTeam.add(new Person(\"ADAM\",\"CAŁA\", LocalDate.parse(\"1997-10-14\")));\n    arrayTeam.add(new Person(\"BEATA\",\"CAŁA\", LocalDate.parse(\"1998-11-24\")));\n    arrayTeam.add(new Person(\"KAROL\",\"NOWAK\", LocalDate.parse(\"1987-01-04\")));\n    //dodajemy dwa różne obiekty, które mają te same dane\n    arrayTeam.add(new Person(\"PAWEŁ\",\"NOWAK\", LocalDate.parse(\"1993-10-22\")));\n    arrayTeam.add(new Person(\"PAWEŁ\",\"NOWAK\", LocalDate.parse(\"1993-10-22\")));\n\n    Person a \u003d new Person(\"KONRAD\", \"BAS\",LocalDate.parse(\"1986-08-13\"));\n    //dodajemy dwa razy ten sam obiekt a\n    arrayTeam.add(a);\n    arrayTeam.add(a);\n    Iterator\u003cPerson\u003e i \u003d arrayTeam.iterator();\n    while(i.hasNext()){\n      System.out.println(i.next());\n    }\n  }\n}\n"
                },
                "src/Person.java": {
                  "name": "src/Person.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\n\nclass Person{\n  private String firstName;\n  private String lastName;\n  public LocalDate birthDate;\n\n  public Person(String firstName, String lastName, LocalDate birthDate) {\n    this.firstName \u003d firstName;\n    this.lastName \u003d lastName;\n    this.birthDate \u003d birthDate;\n  }\n\n  @Override\n  public String toString() {\n    return firstName+\" \"+lastName+\" \"+birthDate;\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eListy\u003c/h1\u003e\n\u003cp\u003e\nInterfejs\u003csamp\u003eList\u003c/samp\u003e służy do implementacji list, czyli sekwencji elementów, które są dostępne poprzez indeks, podobnie jak elementy tablicy.\n\u003c/p\u003e\n\u003cp\u003e\n    Interfejs \u003csamp\u003eList\u003c/samp\u003e wzbogaca metody z interfeksu \u003csamp\u003eCollection\u003c/samp\u003e\n    o dodatkowe metody:\n    \u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003e void add(int index, E obj)\u003c/code\u003e - wstawia element obj na pozycji index\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003e void addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)\u003c/code\u003e - wstawia elementy kolekcji c począwszy do pozycji index\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003e E get(int index)\u003c/code\u003e - zwraca element przechowywany pod wskazanymm indeksem\n    \u003c/li\u003e\n    \u003cli\u003e\n    \u003ccode\u003eE remove(int index)\u003c/code\u003e - usuwa element przechowywany pod wskazanym\n        indeksem\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eE set(int index, E obj)\u003c/code\u003e - zamienia element o podanym indeksie na nowy \u003csamp\u003eobj\u003c/samp\u003e zwracając poprzedni element\u003c/li\u003e\n    \u003cli\u003e\n    \u003ccode\u003eList\u0026lt;E\u0026gt;subList(int start, int end)\u003c/code\u003e - zwraca podlistę\n        elementów w zakresie indeksów od \u003csamp\u003estart\u003c/samp\u003e do \u003csamp\u003eend\u003c/samp\u003e.\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Klasy implementujące interfejs \u003csamp\u003eList\u003c/samp\u003e to \u003csamp\u003eArrayList\u003c/samp\u003e i \u003csamp\u003eLinkedList\u003c/samp\u003e, obie są\n    klasami parametrycznymi, a parametrem jest typ elementu przechowywanego w liście.\n\u003c/p\u003e\n\u003ch2\u003eArrayList\u003c/h2\u003e\n\u003cp\u003e\n    Klasa ta realizuje kolekcję przechowywaną w wewnętrznej, tradycyjnej tablicy. Różnicą\n    w stosunku do zwykłej tablicy jest zmiana rozmiaru kolekcji trakcie dodawania lub usuwania elementów. Kolekcja na początku tworzy niewielką tablicę, po jej wypełnieniu, tworzona jest nowa, większa i do niej przenoszone są elementy. To czyni \u003csamp\u003eArrayList\u003c/samp\u003e rodzajem dynamicznej tablicy, która łaczy szybki dostęp do elementów jak w w tablicy tradycyjnej, z elastyczną zmianą rozmiaru w zależności od potrzeb. Ujemnym aspektem jest narzut czasowy w chwili znacznej zmiany rozmiaru wewnętrznej tablicy w trakcie dodawaniau lub usuwania elementów.\n\u003c/p\u003e\n\u003cp\u003e\n    Tworzenie obiektów klasy \u003csamp\u003eArrayList\u003c/samp\u003e odbywa się trzema konstruktorami:\n    \u003cul\u003e\n    \u003cli\u003e\u003ccode\u003eArrayList()\u003c/code\u003e - tworzy listę z pustą tablicą wewnętrtzną\u003c/li\u003e\n    \u003cli\u003e\u003ccode\u003eArrayList(Collection\u0026lt;? extends E\u0026gt; c)\u003c/code\u003e - tworzy listę zazwierjącą elementy z koleckji c\u003c/li\u003e\n    \u003cli\u003e\u003ccode\u003eArrayList(int capacity)\u003c/code\u003e - tworzy pustą listę z ustawioną\n    pojemnością tablicy wewnętrznej\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Można jawnie wpływać na pojemność wewnętrznej tablicy listy, gdy jesteśmy pewni, że\n    będzie taka potrzebna:\n    \u003cul\u003e\n    \u003cli\u003e\n    \u003ccode\u003evoid ensureCapacity(int cap)\u003c/code\u003e - zwiększa pojemność do listy \u003csamp\u003ecap\u003c/samp\u003e.\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003evoid trimToSize(int cap)\u003c/code\u003e - zmniejsza pojemność, jeśli liczba elementów\n        jest od niej mniejsza.\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\n\u003ch2\u003eLinkedList\u003c/h2\u003e\n\u003cp\u003e\n    Jest to typowa struktura dowiązaniowa, każde wstawienie elementu powoduje utworzenie węzła, który jest dodawany do listy. Zaletą struktury jest automatyczne dostosowanie rozmiaru kolekcji w miarę dodawania\n    lub usuwania elementów. Minusem jest czas dostępu do dowolnego elementu, który zależy od\n    zajmowanego miejsca w liście, im dalej element znajduje się od początku listy, tym więcej czasu\n    potrzeba na dostanie się do niego. Kolekcja najlepiej się sprawdza w sytuacjach, gdy elementy\n    są przeglądane sekwencyjnie i nie ma potrzeby dostępu losowego.\n\u003c/p\u003e\n\u003cp\u003e\n    Klasa \u003csamp\u003eLinkedList\u003c/samp\u003e implementuje także interfejs \u003csamp\u003eDeque\u003c/samp\u003e, który zawiera metody obsługi\n    listy dwukierunkowej.\n\u003c/p\u003e\n\u003cp\u003e\n    Klasa posiada dwa konstruktory:\n    \u003cul\u003e\n    \u003cli\u003e\u003ccode\u003eLinkedList()\u003c/code\u003e - tworzy listę z \u003c/li\u003e\n    \u003cli\u003e\u003ccode\u003eLinkedList(Collection\u0026lt;? extends E\u0026gt; c)\u003c/code\u003e - tworzy listę zawierjącą elementy z kolekcji c\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 4",
              "stepic_id": 0,
              "task_files": {
                "src/HashSetDemo.java": {
                  "name": "src/HashSetDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\nclass HashSetDemo {\n  public static void main(String[] args) {\n    Set\u003cPerson\u003e team \u003d new HashSet\u003c\u003e(10);\n    team.add(new Person(\"ADAM\",\"CAŁA\", LocalDate.parse(\"1997-10-14\")));\n    team.add(new Person(\"BEATA\",\"CAŁA\", LocalDate.parse(\"1998-11-24\")));\n    team.add(new Person(\"KAROL\",\"NOWAK\", LocalDate.parse(\"1987-01-04\")));\n    //dodajemy dwa różne obiekty, które mają te same dane\n    team.add(new Person(\"PAWEŁ\",\"NOWAK\", LocalDate.parse(\"1993-10-22\")));\n    team.add(new Person(\"PAWEŁ\",\"NOWAK\", LocalDate.parse(\"1993-10-22\")));\n\n    Person a \u003d new Person(\"KONRAD\", \"BAS\",LocalDate.parse(\"1986-08-13\"));\n    //dodajemy dwa razy ten sam obiekt a\n    //obiekt a zostanie dodany tylko raz\n    team.add(a);\n    team.add(a);\n    //elememnty są wyświetlone w innej, przypadkowej kolejności niż podczas wstawiania\n    Iterator\u003cPerson\u003e i \u003d team.iterator();\n    while(i.hasNext()){\n      System.out.println(i.next());\n    }\n  }\n}"
                },
                "src/LinkedHashSetDemo.java": {
                  "name": "src/LinkedHashSetDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\npublic class LinkedHashSetDemo {\n  public static void main(String[] args) {\n    Set\u003cPerson\u003e sortedTeam \u003d new LinkedHashSet\u003c\u003e();\n    sortedTeam.add(new Person(\"ADAM\",\"CAŁA\", LocalDate.parse(\"1997-10-14\")));\n    sortedTeam.add(new Person(\"BEATA\",\"CAŁA\", LocalDate.parse(\"1998-11-24\")));\n    sortedTeam.add(new Person(\"KAROL\",\"NOWAK\", LocalDate.parse(\"1987-01-04\")));\n    //dodajemy dwa różne obiekty, które mają te same dane\n    sortedTeam.add(new Person(\"PAWEŁ\",\"NOWAK\", LocalDate.parse(\"1993-10-22\")));\n    sortedTeam.add(new Person(\"PAWEŁ\",\"NOWAK\", LocalDate.parse(\"1993-10-22\")));\n\n    Person a \u003d new Person(\"KONRAD\", \"BAS\",LocalDate.parse(\"1986-08-13\"));\n    //dodajemy dwa razy ten sam obiekt a\n    //obiekt a zostanie dodany tylko raz\n    sortedTeam.add(a);\n    sortedTeam.add(a);\n    //elementy zbioru są wyświetlone w tej samej kolejności jak podczas wstawiania\n    Iterator\u003cPerson\u003e i \u003d sortedTeam.iterator();\n    while(i.hasNext()){\n      System.out.println(i.next());\n    }\n  }\n}\n"
                },
                "src/Person.java": {
                  "name": "src/Person.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\nimport java.util.Comparator;\n\nclass Person implements Comparator\u003cPerson\u003e{\n  private String firstName;\n  private String lastName;\n  public LocalDate birthDate;\n\n  public Person(){\n  }\n\n  public Person(String firstName, String lastName, LocalDate birthDate) {\n    this.firstName \u003d firstName;\n    this.lastName \u003d lastName;\n    this.birthDate \u003d birthDate;\n  }\n\n  @Override\n  public String toString() {\n    return firstName+\" \"+lastName+\" \"+birthDate;\n  }\n\n  @Override\n  public int compare(Person o1, Person o2) {\n    //jeśli nazwiska nie są identyczne to zwracamy wynik porównania nazwisk\n    if (o1.lastName.compareTo(o2.lastName) !\u003d 0){\n      return o1.lastName.compareTo(o2.lastName);\n    }\n    //gdy identyczne nazwiska i rózne imiona to zwracamy wynik porównania imion\n    if (o1.firstName.compareTo(o2.firstName) !\u003d 0){\n      return o1.firstName.compareTo(o2.firstName);\n    }\n    //gdy nazwiska i imiona identyczne zwracamy wynik porównania dat urodzenia\n    return o1.birthDate.compareTo(o2.birthDate);\n  }\n}"
                },
                "src/TreeSetDemo.java": {
                  "name": "src/TreeSetDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\nimport java.util.*;\n\npublic class TreeSetDemo {\n  public static void main(String[] args) {\n    //\n    Set\u003cPerson\u003e treeTeam \u003d new TreeSet\u003c\u003e(new Person());\n    treeTeam.add(new Person(\"ADAM\",\"CAŁA\", LocalDate.parse(\"1997-10-14\")));\n    treeTeam.add(new Person(\"BEATA\",\"CAŁA\", LocalDate.parse(\"1998-11-24\")));\n    treeTeam.add(new Person(\"KAROL\",\"NOWAK\", LocalDate.parse(\"1987-01-04\")));\n    //dodajemy dwa różne obiekty, które mają te same dane\n    treeTeam.add(new Person(\"PAWEŁ\",\"NOWAK\", LocalDate.parse(\"1993-10-22\")));\n    treeTeam.add(new Person(\"PAWEŁ\",\"NOWAK\", LocalDate.parse(\"1993-10-22\")));\n\n    Person a \u003d new Person(\"KONRAD\", \"BAS\",LocalDate.parse(\"1986-08-13\"));\n    //dodajemy dwa razy ten sam obiekt a\n    //obiekt a zostanie dodany tylko raz\n    treeTeam.add(a);\n    treeTeam.add(a);\n    //elementy zbioru są wyświetlone w kolejności rosnącej\n    Iterator\u003cPerson\u003e i \u003d treeTeam.iterator();\n    while(i.hasNext()){\n      System.out.println(i.next());\n    }\n  }\n}\n"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eZbiory - Set\u003c/h1\u003e\n\u003cp\u003e\n    Elementy przechowywane w zbiorach są unikalne, dodanie wartości, która już występuje w zbiorze, nie powoduje zmian w kolekcji.\n\u003c/p\u003e\n\u003ch1\u003eInterfejs Set\u003c/h1\u003e\n\u003cp\u003e\n    Parametryczny interfejs \u003csamp\u003eSet\u003c/samp\u003e rozszerza interfejs \u003csamp\u003eCollection\u003c/samp\u003e, ale nie definiuje żanych własnych metod. Metoda \u003csamp\u003eadd()\u003c/samp\u003e zwróci \u003csamp\u003efalse\u003c/samp\u003e jeśli dodawany element występuje już w zbiorze.\n\u003c/p\u003e\n\u003cp\u003e\n    Klasami implementującymi interfejs \u003csamp\u003eSet\u003c/samp\u003e są klasy parametryczne \u003csamp\u003eHashSet\u003c/samp\u003e, \u003csamp\u003eLinkedHashSet\u003c/samp\u003e oraz \u003csamp\u003eTreeSet\u003c/samp\u003e.\n\u003c/p\u003e\n\u003ch1\u003eInterfejs SortedSet\u003c/h1\u003e\n\u003cp\u003e\n    Rozszerza interfejs \u003csamp\u003eSet\u003c/samp\u003e poprzez dodanie metod odpowiedzialnych za zachowanie zbioru elementów\n    posortowanych rosnącą. Jest to także interfejs parametryczny.\n\u003c/p\u003e\n\u003cp\u003e\n    Metody zbioru posortowanego:\n\u003cul\u003e\n    \u003cli\u003e\n    \u003ccode\u003eE first()\u003c/code\u003e - zwraca pierwszy element zbioru\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eE last()\u003c/code\u003e - zwraca ostatni element zbioru\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eSortedSet\u0026lt;E\u0026gt; headSet(E end)\u003c/code\u003e - zwraca posortowany podzbiór od początku zawierający elementy nie większe od argumentu \u003csamp\u003eend\u003c/samp\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eSortedSet\u0026lt;E\u0026gt; tailSet(E start)\u003c/code\u003e - zwraca posortowany podzbiór od końca zawierający elementy nie mniejsze od argumentu \u003csamp\u003estart\u003c/samp\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eSortedSet\u0026lt;E\u0026gt; headSet(E end)\u003c/code\u003e - zwraca posortowany podzbiór od początku zawierający elementy nie większe od argumentu \u003csamp\u003eend\u003c/samp\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eSortedSet\u0026lt;E\u0026gt; subSet(E start, E end)\u003c/code\u003e - zwraca posortowany podzbiór zawierający elementy nie mniejsze \u003csamp\u003estart\u003c/samp\u003e i nie większe od \u003csamp\u003eend\u003c/samp\u003e.\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Klasą implementujacą ten interfejs jest \u003csamp\u003eTreeSet\u003c/samp\u003e\n\u003c/p\u003e\n\n\u003ch2\u003eKlasa HashSet\u003c/h2\u003e\n\u003cp\u003e\n    Klasa \u003csamp\u003eHashSet\u003c/samp\u003e zawiera wewnętrzną tablicę mieszającą, której rolą jest szybki dostęp\n    do elementów zbioru na podstawie tzw. skrótu. Wartość elementu, który ma trafić do zbioru, służy\n    do utworzenia specjalnej wartości skrótu, który staje się rodzajem indeksu. Posługując się\n    tym indeksem można w czasie liniowym (podobnym jak czas odczytu komórki tablicy) wstawić lub usunąć element, a także go odczytać a nawet sprawdzić czy taki istnieje. Klasa nie gwarantuje\n    zachowania kolejności elementów zgodnie z kolejnościa wstawiania do zbioru.\n\u003c/p\u003e\n\u003cp\u003e\n    Deklaracja klasy: \u003ccode\u003e class HashSet\u0026lt;E\u0026gt;\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n    Konstruktory klasy \u003csamp\u003eHashSet\u003c/samp\u003e:\n    \u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003eHashSet()\u003c/code\u003e - utworznie zbioru mieszającego,\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eHashSet(Collection \u0026lt; extends E\u0026gt; c)\u003c/code\u003e - utworzenie i wypełnienie zbioru elementami kolekcji \u003csamp\u003ec\u003c/samp\u003e.\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eHashSet(int capacity)\u003c/code\u003e - utworzenie zbioru o poczatkowej pojemności \u003csamp\u003ecapacity\u003c/samp\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eHashSet(int capacity, float fillRatio)\u003c/code\u003e - utworzenie zbioru o początkowej pojemności capacity i podanym wpsółczynniku wypełnienia (zakres od 0 do 1).\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Współczynnik wypełnienia określa moment, kiedy następuje rozszerzenie wewnętrznej tablicy. Gdy liczba elementów zbioru jest staje się większa od pojemności pomnożonej przez współczynnik wypełnienia to następuje utworznie, nowej i większej tablicy. Domyślna wartość wpsółczynnika wypełnienia wynosi 0,75.\n\u003c/p\u003e\n\u003ch2\u003eKlasa LinkedHashSet\u003c/h2\u003e\n\u003cp\u003e\nKlasa \u003csamp\u003eLinkedHashSet\u003c/samp\u003e jest wyprowadzona z klasy \u003csamp\u003eHashSet\u003c/samp\u003e, ale nie dodaje żadnych nowych metod. Różnica między obiema klasami polega na sposobie przechowywwania elementów. W klasie \u003csamp\u003eLinkedHashSet\u003c/samp\u003e wykorzystywana jest lista dowiązaniowa, co powoduje, że zachowana jest kolejność wstawianych elementów.\n\u003c/p\u003e\n\u003ch2\u003eKlasa TreeSet\u003c/h2\u003e\n\u003cp\u003e\nW tej klasie elementy przechowywane są w strukturze dowiązaniowej zorganizowanej w drzewo. Elementy w zbiorze są posortowane rosnąco. Dostęp do elementów jest bardzo szybki.\n\u003c/p\u003e\n\u003cp\u003e\nSygnatury klasy: \u003ccode\u003eclass TreeSet\u0026lt;E\u0026gt;\u003e\u003c/code\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Konstruktory:\n    \u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003eTreeSet()\u003c/code\u003e - tworzy nowy, pusty zbiór\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eTreeSet(Collection\u0026lt;? extends E\u0026gt; c)\u003c/code\u003e - tworzy nowy zbiór wypełniony elementami kolekcji c\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eTreeSet(Comparator\u0026lt;? super E\u0026gt; comp)\u003c/code\u003e - tworzy nowy zbiór, który będzie sortował elementy zgodnie z funkcją komparatora \u003csamp\u003ecomp\u003c/samp\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eTreeSet(SortedSet\u0026lt;E\u0026gt; ss)\u003c/code\u003e - tworzy nowy zbiór wypełniony elementami zbioru\n        \u003csamp\u003ess\u003c/samp\u003e.\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 5",
              "stepic_id": 0,
              "task_files": {
                "src/HashMapDemo.java": {
                  "name": "src/HashMapDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass HashMapDemo {\n  public static void main(String[] args) {\n    Map\u003cString, Person\u003e mapTeam \u003d new HashMap\u003c\u003e();\n    //wstawianie elementów do mapy\n    mapTeam.put(\"szef\", new Person(\"LUDWIK\",\"KOZAK\", LocalDate.parse(\"1976-07-03\")));\n    mapTeam.put(\"sekretarka\", new Person(\"ANNA\",\"KRUK\", LocalDate.parse(\"1998-05-13\")));\n    mapTeam.put(\"portier\", new Person(\"KAZIMIERZ\",\"KOWALSKI\", LocalDate.parse(\"1964-12-23\")));\n    //wyświetlenie kluczy mapy\n    for(String key: mapTeam.keySet()){\n      System.out.println(key);\n    }\n    //wyświetlenie wartości\n    for(Person value: mapTeam.values()){\n      System.out.println(value);\n    }\n    //wyświetlenie wartości na podstawie klucza\n    System.out.println(\"SZEF \"+ mapTeam.get(\"szef\"));\n    //usunięcie wartości o podanym kluczu\n    mapTeam.remove(\"portier\");\n    //\n    mapTeam.containsKey(\"portier\");\n  }\n\n}"
                },
                "src/Person.java": {
                  "name": "src/Person.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\nimport java.util.Comparator;\n\nclass Person{\n  private String firstName;\n  private String lastName;\n  public LocalDate birthDate;\n\n  public Person(String firstName, String lastName, LocalDate birthDate) {\n    this.firstName \u003d firstName;\n    this.lastName \u003d lastName;\n    this.birthDate \u003d birthDate;\n  }\n\n  @Override\n  public String toString() {\n    return firstName+\" \"+lastName+\" \"+birthDate;\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eMapy - Map\u003c/h1\u003e\n\u003cp\u003eMapy to wyspecjalizowany rodzaj kolekcji, której elementy dostępne przez inną wartość zwaną kluczem. Kluczem\nmoże być liczba, łańcuch, data itd., czyli wartość dowolnego typu. Kolejność elementów w mapie nie ma znaczenia. Każdy klucz w mapie jest unikatowy, ale wartości mogą się powtarzać. Nie można iterować mapy, ale można uzyskać widoki mapy w postaci kolekcji, które już dają możliwośc uzyskania iteratora.\n\u003c/p\u003e\n\u003cp\u003e\nCzas dostęp do elementów jest podobny jak w tablicach, a więc liniowy, i nie zależy od rozmiaru mapy.\u003c/p\u003e\n\u003cp\u003e\n    Istnieje kilka interfejsów map, które zawierają zbiory metod do przetwarzania danej wersji mapy.\n\u003c/p\u003e\n\u003ch2\u003eInterfejs Map\u003c/h2\u003e\n\u003cp\u003e\n    Interfejs Map posiada dwa parametry: \u003ccode\u003einterface Map\u0026lt;K,V\u0026gt;\u003c/code\u003e, gdzie \u003csamp\u003eK\u003c/samp\u003e jest typem klucza a \u003csamp\u003eV\u003c/samp\u003e to typ wartości przechowywanej w mapie.\n\u003c/p\u003e\n\u003cp\u003e\n    Dwie podstawowe operacje na mapach to:\n    \u003cul\u003e\n        \u003cli\u003e\n            \u003ccode\u003eV get(K key)\u003c/code\u003e - pobranie elementu o podanym kluczy\n        \u003c/li\u003e\n        \u003cli\u003e\n            \u003ccode\u003eV put(K key, V value)\u003c/code\u003e - wstawienie elementu \u003csamp\u003evalue\u003c/samp\u003e z kluczem \u003csamp\u003ekey\u003c/samp\u003e, jeśli w\n            mapie istniał już element o takim kluczo, to zostanie nadpisany, a poprzednia jego wartość zostanie zwrócona\n            przez metodę\n        \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eV remove(Object k)\u003c/code\u003e - usunięcie elementu o kluczu k, funkcja zwraca usuwany element\n    \u003c/li\u003e\n    \u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Oprócz tego interfejs dostarcza kilku metod zwracających kolekcje:\n    \u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003eSet\u0026lt;K\u0026gt; keySet()\u003c/code\u003e - zwraca zbiór kluczy mapy w postaci widoku\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eCollection\u0026lt;V\u0026gt; values()\u003c/code\u003e - zwraca kolekcję wartości mapy w postaci widoku\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eCollection\u0026lt;V\u0026gt; values()\u003c/code\u003e - zwraca kolekcję wartości mapy w postaci widoku\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003ch2\u003eInterfejs SortedMap\u003c/h2\u003e\n\u003cp\u003e\n    Jest to rozszerzenie interfejsu \u003csamp\u003eMap\u003c/samp\u003e do tworzenia map, które przechowują elementy w porządku rosnącym\n    kluczy. Deklaracja interfejsu: \u003ccode\u003einterface SortedMap\u0026lt;K, V\u0026gt;\u003c/code\u003e, gdzie znaczenie parametrów jest takie samo jak w interfejsie \u003csamp\u003eMap\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n    Metody charakterystyczne dla tego interfejsu to:\n    \u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003eK firstKey()\u003c/code\u003e - zwraca pierwszy klucz  mapy\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eK lastKey()\u003c/code\u003e - zwraca ostatni klucz  mapy\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eSortedMap\u0026lt;K, V\u0026gt; headMap(K end)\u003c/code\u003e - zwraca posortowaną mapę, której klucze są mniejsze od end\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eSortedMap\u0026lt;K, V\u0026gt; tailMap(K start)\u003c/code\u003e - zwraca posortowaną mapę, której klucze są większe od start\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eSortedMap\u0026lt;K, V\u0026gt; headMap(K, start, K end)\u003c/code\u003e - zwraca posortowaną mapę, której klucze są nie mniejsze od \u003csamp\u003estart\u003c/samp\u003e i nie większe od \u003csamp\u003eend\u003c/samp\u003e.\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003ch2\u003eInterfejs NavigableMap\u003c/h2\u003e\n\u003cp\u003e\n    Interfejs rozszerzający \u003csamp\u003eSortedMap\u003c/samp\u003e służy do tworzenia klas obsługujących wyszukiwanie wpisów według najbliższego dopasowania do podanego klucza lub kluczy. Jeśli chcesz dowiedzieć się więcej o tym interfejsie zajrzyj do dokumentacji.\n\u003c/p\u003e\n\u003ch1\u003eKlasy map\u003c/h1\u003e\n\u003cp\u003e\n    Aby utworzyć mapę trzeba zadeklarować obiekt klasy implementujęj, któryś z interfejsów map. Klas\n    map jest stosunkowo dużo:\n    \u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003eAbstractMap\u003c/code\u003e - klasa abtrakcyjna implementująca większość metod interfejsu Map i służaca do jako klasa bazowa dla prawie wszystkich konkretnych klas map (oprócz \u003csamp\u003eLinkedHashMap\u003c/samp\u003e)\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eEnumMap\u003c/code\u003e - klasa wykorzystująca stałe wyliczeniowe jako klucze\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eHashMap\u003c/code\u003e - klasa wykorzystująca tablicę mieszającą do przechowywania elementów\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eTreeMap\u003c/code\u003e - klasa wykorzystująca strukturę drzewa\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eWeakHashMap\u003c/code\u003e - klasa wykorzystująca tablicę mieszającą ale ze słabymi kluczami (elementy są automatycznie usuwane przez GC z mapy, gdy znika referencja do klucza)\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eLinkedHashMap\u003c/code\u003e - klasa zapewnia iterację w kolejności wstawiania elementów\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eIdentityHashMap\u003c/code\u003e - do porównania kluczy używa wartości referencji\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003eW dalszej części omówimy tylko dwie klasy map: \u003csamp\u003eHashMap\u003c/samp\u003e i \u003csamp\u003eTreeMap\u003c/samp\u003e\u003c/p\u003e\n\u003ch2\u003eKlasa HashMap\u003c/h2\u003e\n\u003cp\u003e\n  Klasa przechowuje elementy mapy w tablicy mieszającej zapewniając, stały czas wykonywania operacji wstawiania i pobierania elementów. Sygnatura klasy: \u003ccode\u003eclass HashMap\u0026lt;K, V\u0026gt;\u003c/code\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n    Konstruktory klasy:\n    \u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003eHashMap()\u003c/code\u003e - tworzy pustą mapę,\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eHashMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m)\u003c/code\u003e - tworzy mapę zawierającą elementy z mapy \u003csamp\u003em\u003c/samp\u003e,\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eHashMap(int capacity)\u003c/code\u003e - tworzy mapę o wstępnej pojemności \u003csamp\u003ecapacityy\u003c/samp\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eHashMap(int capacity, float fillRatio)\u003c/code\u003e - tworzy mapę o podanje wstępnej pojemności i współczynniku wypełnienia (znaczenie takie samo jak w klasie HashSet).\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003eTworzenie mapy z użyciem tej klasy:\n\u003c/p\u003e\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\n     Map\u0026lt;String, Person\u0026gt; team \u003d new HashMap\u003c\u003e();\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Klasa implementuje tylko interfejs \u003csamp\u003eMap\u003c/samp\u003e i nie dodaje żadnych własnych metod.\n\u003c/p\u003e\n\u003ch2\u003eKlasa TreeMap\u003c/h2\u003e\n\u003cp\u003e\n    Klasa \u003csamp\u003eTreeMap\u003c/samp\u003e implementuje interfejs \u003csamp\u003eNavigableMap\u003c/samp\u003e i używa struktury drzewiastej do przechowywania elementów, co zapewnia szybkie odczytywanie wartości. Zapewnia także sortowanie elementów według kluczy w porządku rosnącym.\n\u003c/p\u003e\n\u003cp\u003e\n    Deklaracja klasy: \u003ccode\u003eclass TreeMap\u0026lt;K, V\u0026gt;\u003c/code\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Konstruktory klasy:\n    \u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003eTreeMap()\u003c/code\u003e - tworzy pustą mapę\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eTreeMap(Comparator\u0026lt;? super K\u0026gt; comp)\u003c/code\u003e - tworzy pustą mapę z komparatorem określającym porządek sortowania\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eTreeMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m)\u003c/code\u003e - tworzy mapę zawierającą elementy\n        z mapy m\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eTreeMap(SortedMap\u0026lt;K, ? extends V\u0026gt; sm)\u003c/code\u003e - tworzy mapę zawierającą elementy z posortowanej mapy sm i z tym samym sposobem sortowania co sm.\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Klasa \u003csamp\u003eTreeMap\u003c/samp\u003e nie definiuje swoich metod, implementuje tylko metody z interfejsu \u003csamp\u003eNavigableMap\u003c/samp\u003e.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 6",
              "stepic_id": 0,
              "task_files": {
                "src/ComparatorDemo.java": {
                  "name": "src/ComparatorDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nclass Task {\n  public static void main(String[] args) {\n    //Zbiór osób sortowanych wg imion\n    Set\u003cPerson\u003e treeTeam \u003d new TreeSet\u003c\u003e(new Comparator\u003cPerson\u003e() {\n      @Override\n      public int compare(Person o1, Person o2) {\n        return Person.compareFirstName(o1, o2);\n      }\n    });\n\n    treeTeam.add(new Person(\"ADAM\",\"KOWALSKI\", LocalDate.parse(\"1998-04-23\")));\n    treeTeam.add(new Person(\"KAROL\",\"NOWAK\", LocalDate.parse(\"1994-08-13\")));\n    treeTeam.add(new Person(\"EWA\" +\n            \"\",\"ADAMSKI\", LocalDate.parse(\"1991-12-09\")));\n\n    Iterator\u003cPerson\u003e iterator \u003d treeTeam.iterator();\n    while(iterator.hasNext()){\n      System.out.println(iterator.next());\n    }\n    //Zbiór osób sortowanych wg nazwisk\n    Set\u003cPerson\u003e treeStaff \u003d new TreeSet\u003c\u003e(new Comparator\u003cPerson\u003e() {\n      @Override\n      public int compare(Person o1, Person o2) {\n        return Person.compareBirthDateAsc(o1, o2);\n      }\n    });\n\n    treeStaff.add(new Person(\"ADAM\",\"KOWALSKI\", LocalDate.parse(\"1998-04-23\")));\n    treeStaff.add(new Person(\"KAROL\",\"NOWAK\", LocalDate.parse(\"1994-08-13\")));\n    treeStaff.add(new Person(\"EWA\" +\n            \"\",\"ADAMSKI\", LocalDate.parse(\"1991-12-09\")));\n    iterator \u003d treeStaff.iterator();\n    while(iterator.hasNext()){\n      System.out.println(iterator.next());\n    }\n  }\n}"
                },
                "src/Person.java": {
                  "name": "src/Person.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.time.LocalDate;\nimport java.util.Comparator;\n\nclass Person{\n  private String firstName;\n  private String lastName;\n  public LocalDate birthDate;\n\n  public Person(){\n  }\n\n  public Person(String firstName, String lastName, LocalDate birthDate) {\n    this.firstName \u003d firstName;\n    this.lastName \u003d lastName;\n    this.birthDate \u003d birthDate;\n  }\n\n  @Override\n  public String toString() {\n    return firstName+\" \"+lastName+\" \"+birthDate;\n  }\n\n\n  static public int compareLstName(Person o1, Person o2) {\n    //jeśli nazwiska nie są identyczne to zwracamy wynik porównania nazwisk\n    if (o1.lastName.compareTo(o2.lastName) !\u003d 0){\n      return o1.lastName.compareTo(o2.lastName);\n    }\n    //gdy identyczne nazwiska i rózne imiona to zwracamy wynik porównania imion\n    if (o1.firstName.compareTo(o2.firstName) !\u003d 0){\n      return o1.firstName.compareTo(o2.firstName);\n    }\n    //gdy nazwiska i imiona identyczne zwracamy wynik porównania dat urodzenia\n    return o1.birthDate.compareTo(o2.birthDate);\n  }\n\n  static public int compareFirstName(Person o1, Person o2) {\n    //jeśli imiona nie są identyczne to zwracamy wynik porównania imion\n    if (o1.firstName.compareTo(o2.firstName) !\u003d 0){\n      return o1.firstName.compareTo(o2.firstName);\n    }\n    //gdy identyczne nazwiska i rózne imiona to zwracamy wynik porównania imion\n    if (o1.lastName.compareTo(o2.lastName) !\u003d 0){\n      return o1.lastName.compareTo(o2.lastName);\n    }\n    //gdy nazwiska i imiona identyczne zwracamy wynik porównania dat urodzenia\n    return o1.birthDate.compareTo(o2.birthDate);\n  }\n\n  static public int compareBirthDateAsc(Person o1, Person o2) {\n    return o1.birthDate.compareTo(o2.birthDate);\n  }\n\n  static public int compareBirthDateDesc(Person o1, Person o2) {\n    return o2.birthDate.compareTo(o1.birthDate);\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eKomparatory\u003c/h1\u003e\n\u003cp\u003e\n  Klasy \u003csamp\u003eTreeSet\u003c/samp\u003e i \u003csamp\u003eTreeMap\u003c/samp\u003e przechowują elementy posortowane, więc wymagają określenia sposobu sortowania. Domyślnie obie klasy wykorzystują naturalny porządek czyli dla liczb i znaków porządek rosnący (1, 2, 3, 4 itd, A, B, C, D itd.).\n\u003c/p\u003e\n\u003cp\u003e\n    Gdy chcemy przechowywać elementy w innym porzadku należy wskazać klasom obiekt zwany komparatorem. Obiekt taki można utworzyć na podstawie dowolnej klasy implementującej interfejs generyczny \u003csamp\u003eComparator\u0026lt;T\u0026gt;\u003c/samp\u003e, w którym parametr T jest klasą porównywanych obiektów.\n\u003c/p\u003e\n\u003cp\u003eInterfejs zawiera deklaracje dwóch metod:\n\u003cul\u003e\n    \u003cli\u003e\n      \u003ccode\u003eint compare(T obj1, T obj2)\u003c/code\u003e - metoda zwraca trzy wartości całkowite w zależności od porównania obu argumentów:\n        \u003cul\u003e\n            \u003cli\u003e\n                obj1 \u003e obj2 - zwraca 1 (lub większą od 0)\n            \u003c/li\u003e\n            \u003cli\u003e\n                obj1 \u003c obj2 - zwraca -1 (lub mniejszą od 0)\n            \u003c/li\u003e\n            \u003cli\u003e\n                obj1 \u003d\u003d obj2 - zwraca 0\n            \u003c/li\u003e\n        \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n       \u003ccode\u003eboolean equals(Object obj)\u003c/code\u003e  - zwraca \u003csamp\u003etrue\u003c/samp\u003e jeśli obj jest równy z obiektem wywołującym metodę.\n    \u003c/li\u003e\n\u003c/ul\u003e\u003c/p\u003e\n\u003cp\u003e\n    Ilustracją wykorzystania interfejsu \u003csamp\u003eComparator\u003c/samp\u003e będzie klasa Person, dla której zdefiniujemy komparator porządkujący wg poniższego schematu:\n    \u003cul\u003e\n    \u003cli\u003e\n        jeśli imiona są różne, porządkujemy rosnącą według imion,\n    \u003cli\u003e\n        jeśłi imiona są równe porządkujemy według nazwisk\n    \u003c/li\u003e\n    \u003cli\u003e\n        jeśli nazwiska są równe porządkujemy według daty urodzenia\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Metodę komparatora możemy dołączyć do klasy Person poprzez dodanie do niej interfejsu \u003csamp\u003eComparator\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass Person implements Comparator\u0026lt;Person\u0026gt;{\n  private String firstName;\n  private String lastName;\n  public LocalDate birthDate;\n\n  public Person(){\n  }\n  ...\n\n  @Override\n  public int compare(Person o1, Person o2) {\n    //jeśli nazwiska nie są identyczne to zwracamy wynik porównania nazwisk\n    if (o1.lastName.compareTo(o2.lastName) !\u003d 0){\n      return o1.lastName.compareTo(o2.lastName);\n    }\n    //gdy identyczne nazwiska i rózne imiona to zwracamy wynik porównania imion\n    if (o1.firstName.compareTo(o2.firstName) !\u003d 0){\n      return o1.firstName.compareTo(o2.firstName);\n    }\n    //gdy nazwiska i imiona identyczne zwracamy wynik porównania dat urodzenia\n    return o1.birthDate.compareTo(o2.birthDate);\n  }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    W metodzie wykorzystaliśmy metodę \u003csamp\u003ecompareTo(o)\u003c/samp\u003e, która stosuje dokładnie ten sam kontrakt co metoda \u003csamp\u003ecompare(o1, o2)\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cp\u003e\n   Tworząc teraz mapę klasą \u003csamp\u003eTreeMap\u003c/samp\u003e można wykorzystać pusty obiekt klasy \u003csamp\u003ePerson\u003c/samp\u003e, gdyż klasa \u003csamp\u003eTreeSet\u003c/samp\u003e wykorzysta tylko metodę \u003csamp\u003ecompare()\u003c/samp\u003e\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nSet\u0026lt;Person\u0026gt; treeTeam \u003d new TreeSet\u003c\u003e(new Person());\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Druga metodą przekazania komparatora jest utworzenie klasy anonimowej, w której wykorzystamy\n    metodę \u003csamp\u003ecompare(o1, o2)\u003c/samp\u003e\u003e z klasy \u003csamp\u003ePerson\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nSet\u0026lt;Person\u0026gt; treeTeam \u003d new TreeSet\u003c\u003e(new Comparator\u0026lt;Person\u0026gt;() {\n      @Override\n      public int compare(Person o1, Person o2) {\n        return o1.compare(o1, o2);\n      }\n    });\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    W tym przypadku nie jest wymagane, aby klasa \u003csamp\u003ePerson\u003c/samp\u003e implementowała \u003csamp\u003eComparator\u003c/samp\u003e, po prostu wykorzystaliśmy zdefiniowaną metodę. Przedstawione rozwiązanie ma tą zaletę, że można zdefiniować w klasie kilka różnych metod porównujących i wykorzystywać je w zależności od potrzeb:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass Person implements Comparator\u0026lt;Person\u0026gt;{\n  private String firstName;\n  private String lastName;\n  public LocalDate birthDate;\n\n  public Person(){\n  }\n  ...\n\n  static public int compare1(Person p1, Person p2){\n    ...\n  }\n\n  static public int compare2(Person p1, Person p2){\n    ...\n  }\n}\n\n ...\n Set\u0026lt;Person\u0026gt; treeTeam \u003d new TreeSet\u003c\u003e(new Comparator\u0026lt;Person\u0026gt;() {\n      @Override\n      public int compare(Person o1, Person o2) {\n        return Person.compare1(o1, o2);\n      }\n});\n\nSet\u0026lt;Person\u0026gt; treeStaff \u003d new TreeSet\u003c\u003e(new Comparator\u0026lt;Person\u0026gt;() {\n      @Override\n      public int compare(Person o1, Person o2) {\n        return Person.compare2(o1, o2);\n      }\n});\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Refleksja",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/ReflectionDemo.java": {
                  "name": "src/ReflectionDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\nclass User{\n  private String name;\n  private String email;\n  private String password;\n  private int id;\n\n  public User(){\n    this.password \u003d\"\";\n    this.name \u003d \"\";\n    this.name \u003d \"no name\";\n  }\n\n  public User(String name, String email, String password, Integer id) {\n    this.name \u003d name;\n    this.email \u003d email;\n    this.password \u003d password;\n    this.id \u003d id;\n  }\n\n  @Override\n  public String toString() {\n    return name+\" \"+email+\" \"+password+\" \"+id;\n  }\n}\n\nclass Message{\n  public String send(){\n    return \"New message\";\n  }\n}\n\nclass Task {\n  public static void main(String[] args) throws IllegalAccessException, NoSuchFieldException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n    User member \u003d new User(\"amin\",\"admin@jps.pl\",\"123456\",3);\n    //wyświetlenie pól obiektu wraz z wartościami\n    System.out.println(\"Lista pól\");\n    for(Field f: member.getClass().getDeclaredFields()){\n      //udostępniamy pola do odczytu\n      f.setAccessible(true);\n      System.out.println(f.getName() + \" \"+f.get(member).toString());\n    }\n    System.out.println();\n    //wyświetlenie metod\n    System.out.println(\"Lista metod\");\n    for(Method m: member.getClass().getMethods()){\n      System.out.println(m.getName());\n    }\n    System.out.println();\n    //zmieniamy wartość wybranego pola\n    System.out.println(\"Zmiana wartości pola password\");\n    System.out.println(\"Obiekt przed zmianą\");\n    System.out.println(member);\n    Field f \u003d member.getClass().getDeclaredField(\"password\");\n    f.setAccessible(true);\n    f.set(member, \"abcd\");\n    System.out.println(\"Obiekt po zmianie zmianą\");\n    System.out.println(member);\n\n    Message m \u003d Message.class.newInstance();\n    System.out.println(m.send());\n    User u \u003d User.class.newInstance();\n    System.out.println(u);\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eRefleksja\u003c/h1\u003e\n\u003cp\u003e\n  Refleksja, jak nazwa wskazuje, jest mechanizmem, który pozwala na uzyskanie w działającym programie własnego \"odbicia\". Mechanizm ten jest realizowany przez bibliotekę \u003csamp\u003ejava.lang.reflect\u003c/samp\u003e, która dostarcza klasy, które pozwalają analizować w trakcie działania programu strukturę kodu. Można uzyskać informację jakiej klasy jest dany obiekt, jak jest lista pól, metod, jakie są typy poszczególnnych pól, jakie parametry metod itd.\n\u003c/p\u003e\n\u003cp\u003e\n  Głównym przeznaczeniem refleksji jest ułatwienie tworzenia narzędzi programistych, które pozwalają na automatyczne generowanie kodu i jego analize w trakcie działania programu.\n\u003c/p\u003e\n\u003cp\u003e\n  Temat refleksji jest dość szeroki, a bilioteka obszerna. Poniżej zapoznamy się z prostym przykładem, który w trakcie działania pozwala na wyświetlenie wszystkich pól i metod klasy wybranego obiektu:\n\u003c/p\u003e\n\n\u003cpre\u003e\n  \u003ccode\u003e\n    User object \u003d new User(\"amin\",\"admin@jps.pl\",\"123456\",3);\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Kod wyświetlający listę pól z ich wartościami to pętla pobierająca pola z tablicy:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  for(Field f: object.getClass().getDeclaredFields()){\n    f.setAccessible(true);\n    System.out.println(f.getName() + \" \"+f.get(member).toString());\n  }\n  \u003c/code\u003e\n\u003c/pre\u003e\n  \u003cp\u003e\n    Klasa \u003csamp\u003eField\u003c/samp\u003e służy do przechowywania informacji o polu klasy, a wywołanie metody \u003csamp\u003esetAccessible(true)\u003c/samp\u003e\n    daje możliwość odczytu pola, które może być prywatne.\n  \u003c/p\u003e\n\u003cp\u003e\n  Wyświetlenie listy metod jest dość podobne, należy pobrać listę metod i w pętli wyswietlić:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n    for(Method m: member.getClass().getMethods()){\n      System.out.println(m.getName());\n    }\n  \u003c/code\u003e\n\u003c/pre\u003e\n  \u003cp\u003e\n    Wyświetlone zostały metody zdefiniowane w klasie jak i odziedziczone. Metoda \u003csamp\u003egetDeclaredMethods\u003c/samp\u003e zwraca lsitę metod deklarowanych tylko w klasie.\n  \u003c/p\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Refleksja daje możliwość manipulowania obiektami w sytuacjach, gdy w programie \"tradycyjną\" metodą nie są dostępne. Klasa \u003csamp\u003eUser\u003c/samp\u003e posiada wszystkie pola prywatne, bez odpowienich setterów co uniemożliwia zmienę wartości dowolnego pola. Korzystając z refleksji możemy zmienić wartość każdego póla, nawet prywatnych:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  Field f \u003d member.getClass().getDeclaredField(\"password\");\n  f.setAccessible(true);\n  f.set(member, \"abcd\");\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Przykład pokazuje dość ciekawe możliwości \"włamania\" się do kodu programu. Refleksja daje również możliwość tworzenia obiektów bez operatora \u003csamp\u003enew\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n  class Message{\n    public String send(){\n      return \"New Object created\";\n    }\n  }\n  ..\n\n  Message m \u003d Message.class.newInstance();\n  System.out.println(m.send());\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Przedstawiony przykład działa dla wszystkich klas posiadających konstruktor bezargumentowy. Tworzenie z użyciem konstruktorów parametrycznych jest też możliwe drogą refleksji, jednak wymaga więcej dodatkowych operacji\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Adnotacje",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/AnnotationDemo.java": {
                  "name": "src/AnnotationDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Car{\n  String name;\n\n  public Car(String name){\n    this.name \u003d name;\n  }\n\n  @Override\n  public String toString(){\n    return name;\n  }\n}\n\nclass AnnotationDemo{\n  public static void main(String[] args) {\n    System.out.println(new Car(\"Porsche\"));\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eAdnotacje\u003c/h1\u003e\n\u003cp\u003e\nW wielu sytuacjach pojawia się konieczność przekazywania dodatkowych informacji na temat kodu. Ich funkcją nie jest komentowanie kodu ale sterowanie jego generacją przed kompilacją. Są to metadane, a więc dane opisujące sposób traktowania kodu. Nie wpływają na działanie programu, ale dają dodatkowe możliwości na generowanie kodu i są bardzo użyteczne w narzędziach programistycznych\n\u003c/p\u003e\n\u003cp\u003e\n    Ilustracją działania adnotacji jest poznana wcześniej adnotacja \u003csamp\u003e@Override\u003c/samp\u003e:\u003c/p\u003e\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass Car{\n  String name;\n  public Car(String name){\n    this.name \u003d name;\n  }\n  @Override\n  public String toString(){\n    return name;\n  }\n}\n\nclass AdnotationDemo {\n  public static void main(String[] args) {\n    System.out.println(new Car(\"Porsche\"));\n  }\n}\n--\nPorsche\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Jej działanie polega na sprawdzeniu sygnatury metody znajdujące się pod nią czy jest identyczna z jakąkolwiek metodą odziedziczoną z klasy bazowej. Zobaczmy cos się stanie, gdy pomylimy sygnaturę tej funkcji przy pozostawieniu adnotacji:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass Car{\n  String name;\n  public Car(String name){\n    this.name \u003d name;\n  }\n  @Override\n  public String toString(int a){\n    return name;\n  }\n}\n\nclass AdnotationDemo {\n  public static void main(String[] args) {\n    System.out.println(new Car(\"Porsche\"));\n  }\n}\n        \u003c/code\u003e\n    \u003c/pre\u003e\n\u003cp\u003eW większości środowisk IDE adnotacja zostanie zaznaczona z informacją, że funkcja nie nadpisuje żadnej metody z superklasy. Próba kompilacji programu\nspowoduje sygnalizację błędu:\u003c/p\u003e\n\u003cpre\u003e\n    Error:(6, 3) java: method does not override or implement a method from a supertype\n\u003c/pre\u003e\n\u003cp\u003eGdy usuniemy adnotację program się skompiluje i uruchomi, ale działanie będzie odmienne niż w pierwszym przykładzie, bo zostanie wywołana odzoedziczona z klasy \u003csamp\u003eObject\u003c/samp \u003e metoda \u003csamp\u003etoString()\u003c/samp\u003e, która wyświetli wartość referencji obiektu:\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass Car{\n  String name;\n  public Car(String name){\n    this.name \u003d name;\n  }\n\n  public String toString(int a){\n    return name;\n  }\n}\n\nclass AdnotationDemo {\n  public static void main(String[] args) {\n    System.out.println(new Car(\"Porsche\"));\n  }\n}\n--\nCar@1540e19d\n        \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Z przykładów wynika, że adnotacje mogą kontrolować intencje programisty na poziomie generowania samego kodu źródłowego, ale informacje mogą zostać wykorzystane w czasie działania programu.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 2",
              "stepic_id": 0,
              "task_files": {
                "src/CustomAnnotationDemo.java": {
                  "name": "src/CustomAnnotationDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.lang.annotation.*;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collection;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\n@interface Default{\n  int value();\n}\n\n\nclass Person{\n  @Default(value \u003d 3)\n  int id;\n\n  private String name;\n\n  Person(String name, int id) {\n    this.name \u003d name;\n    this.id \u003d id;\n  }\n\n  @Override\n  public String toString(){\n    return name+\" \"+id;\n  }\n}\n\nclass MyFrameworkManager{\n  static final MyFrameworkManager MANAGER \u003d new MyFrameworkManager();\n  private Collection collection \u003d new ArrayList\u003c\u003e();\n\n  private MyFrameworkManager() {\n    System.out.println(\"MANAGER STARTS\");\n  }\n\n  public void addObject(Object o) throws IllegalAccessException {\n    processAnnotation(o);\n    collection.add(o);\n  }\n  private void processAnnotation(Object o) throws IllegalAccessException {\n    if (o \u003d\u003d null){\n      return;\n    }\n    if (o instanceof Person){\n        Person p \u003d (Person) o;\n        for (Field f: p.getClass().getDeclaredFields()){\n          if (f.getAnnotation(Default.class) instanceof Default \u0026\u0026 f.getType().getName().equals(\"int\") \u0026\u0026 f.getInt(p) \u003d\u003d 0){\n            f.setInt(p, f.getAnnotation(Default.class).value());\n          }\n        }\n    }\n  }\n\n  public void print(){\n    for (Object o:collection){\n      System.out.println(o);\n    }\n  }\n}\n\nclass Task {\n  public static void main(String[] args) throws IllegalAccessException {\n    Person adam \u003d new Person(\"ADAM\", 0);\n    MyFrameworkManager.MANAGER.addObject(adam);\n    MyFrameworkManager.MANAGER.print();\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n  \u003ch1\u003eTworzenie adnotacji\u003c/h1\u003e\n\u003cp\u003e\n  Adnotacje moga dotyczyć różnych elementów kodu źródłowego: pól, metod, klas. Po dodaniu mogą być przechowywane do określonego etapu cyklu opracowywania programu. Mogą być też dostępne w trakcie działania programu i odczytywane poprzez refleksję. Refleksja to metoda analizy wynikowego kodu programu i wydobywania informacji o klasach, metodach, polach a takze dołączonych do nich adnotacji.\u003c/p\u003e\n\u003cp\u003e\n  Mechanizm tworzenia i działania własnych adnotacji prześledzimy na przykładzie domyślnego inicjalizowania pól pod adnotacją. Jeśli pole nie zostanie jawnie zainicjalizowane przez programistę to zostanie jej nadana wartość z adnotacji. Adnotacja będzie działać dla klasy \u003csamp\u003ePerson\u003c/samp\u003e, dla pól typu \u003csamp\u003eint\u003c/samp\u003e.\n\u003c/p\u003e\n  \u003cp\u003e\n  Adnotacje w Java to interfejs poprzedzony znakiem @:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\n@interface Default{\n  int value();\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Interfejs adnotacji posiada metody, których nazwa jest identyczna z nazwą arguemntu adnotacji. Przed deklaracja znajdująs się adnotacje określające:\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003csamp\u003eRetenction\u003c/samp\u003e - która określa jak długo jest przechowywana adnotacja w kodzie. Argumentami mogą być trzy stałe:\n      \u003cuL\u003e\n        \u003cli\u003e\n          \u003csamp\u003eRetentionPolicy.SOURCE \u003c/samp\u003e- adnotacja przechowywana jest w kodzie źródłowym.\n        \u003c/li\u003e\n        \u003cli\u003e\n          \u003csamp\u003eRetencionPolicy.CLASS\u003c/samp\u003e - adnotacja jest przechowywana w pliku klasie w trakcie kompilacji, ale nie jest dostępna w trakcie wykonywania programu.\n        \u003c/li\u003e\n        \u003cli\u003e\n          \u003csamp\u003eRetentionPolicy.RUNTIME\u003c/samp\u003e - adnotacja jest zachowywana i dostępna w trakcie wykonywania kodu maszynowego.\n        \u003c/li\u003e\n      \u003c/uL\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003csamp\u003eTarget\u003c/samp\u003e - która określa dla jakiego elementu kodu żródłowego jest przeznaczona:\n      \u003cul\u003e\n        \u003cli\u003e\n          \u003csamp\u003eElementType.FIELD\u003c/samp\u003e\n        \u003c/li\u003e\n        \u003cli\u003e\n          \u003csamp\u003eElementType.METHOD\u003c/samp\u003e\n        \u003c/li\u003e\n        \u003cli\u003e\n          \u003csamp\u003eElementType.TYPE\u003c/samp\u003e\n        \u003c/li\u003e\n        \u003cli\u003e\n          \u003csamp\u003eElementType.CONSTRUCTOR\u003c/samp\u003e\n        \u003c/li\u003e\n\n      \u003c/ul\u003e\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\n\u003c/p\u003e\n  \u003cp\u003e\n    Aby skorzystać z adnotacji konieczne jest podanie jej nazwy argumentu i wartości:\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass Person{\n  @Default(value \u003d 3)\n  int id;\n\n  private String name;\n\n  Person(){\n  }\n\n  Person(String name, int id) {\n    this.name \u003d name;\n    this.id \u003d id;\n  }\n\n  @Override\n  public String toString(){\n    return name+\" \"+id;\n  }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003eJeśli nowy obiekt klasy zainicjujemy wartościa 0, to adnotacja powinna automatycznie przypisać wartość podaną w parametrze \u003csamp\u003evalue\u003c/samp\u003e. Jeśli wartość pola będzie inna to adnotacja nie powinna nic zmienić:\u003c/p\u003e\n\u003cp\u003e\n  Nie mamy możliwości aby, nasza adnotacja działała dla każdej dowolnej klasy, musimy samodzielnie określić moment jej zadziałania. W naszym przykładzie zdefiniujemy klasę udającą framework, który będzie przechowywał obiekty. W chwili dodania obiektu typu Person nasz adnotacja powinna zadziałać\n\u003c/p\u003e\n\u003cp\u003e\n  \u003cpre\u003e\n  \u003ccode\u003e\n\nclass MyFrameworkManager{\n  static final MyFrameworkManager MANAGER \u003d new MyFrameworkManager();\n  private Collection collection \u003d new ArrayList\u003c\u003e();\n\n  private MyFrameworkManager() {\n    System.out.println(\"MANAGER STARTS\");\n  }\n\n  public void addObject(Object o) throws IllegalAccessException {\n    processAnnotation(o);\n    collection.add(o);\n  }\n\n  private void processAnnotation(Object o) throws IllegalAccessException {\n    if (o \u003d\u003d null){\n      return;\n    }\n    if (o instanceof Person){\n      Person p \u003d (Person) o;\n      //przeglądamy pola obiektu\n      for (Field f: p.getClass().getDeclaredFields()){\n        //testujemy pole czy ma adnotacje Default, jest typu int i ma wartość równą 0\n        if (f.getAnnotation(Default.class) instanceof Default \u0026\u0026 f.getType().getName().equals(\"int\") \u0026\u0026 f.getInt(p) \u003d\u003d 0){\n          //przypisujemy polu wartość z adnotacji\n          f.setInt(p, f.getAnnotation(Default.class).value());\n        }\n      }\n    }\n  }\n\n  public void print(){\n    for (Object o:collection){\n      System.out.println(o);\n    }\n  }\n}\n    \u003c/code\u003e\n  \u003c/pre\u003e\n\u003c/p\u003e\n\u003cp\u003e\n  Najistotniejszą jest metoda \u003csamp\u003eprocessAnnotation\u003c/samp\u003e, w której przeglądamy przez refleksję pola obiektu klasy \u003csamp\u003ePerson\u003c/samp\u003e poszukując takiego, które posiada adnotację typu \u003csamp\u003eDefault\u003c/samp\u003e. Po przetestowaniu czy jest typu całkowitego i jego wartość jest równa 0 nadajemy temu polu wartość argumentu adnotacji\n\u003c/p\u003e\n\u003cp\u003e\n  Na koniec przykład działania naszej adnotacji\n\u003c/p\u003e\n\u003cpre\u003e\n  \u003ccode\u003e\nclass Task {\n  public static void main(String[] args) throws IllegalAccessException {\n    Person adam \u003d new Person(\"ADAM\", 0);\n    MyFrameworkManager.MANAGER.addObject(adam);\n    MyFrameworkManager.MANAGER.print();\n  }\n}\n  \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Efektem programu jest wygenerowany napis:\n\u003c/p\u003e\n\u003cpre\u003e\n  MANAGER STARTS\n  ADAM 3\n\u003c/pre\u003e\n\u003cp\u003e\n  Obiekt choć został utworzony z polem id równym zero, to andotacja zadziałała zmieniając je na wartość domyślną.\n\u003c/p\u003e\n\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 3",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eWbudowane adnotacje\u003c/h1\u003e\n\u003cp\u003e\n    Język Java posiada zbiór wbudowanych adnotacji. Oprócz poznanych adotacji służących do definiowania własnych, znajduję sią też kilka innych:\n\u003c/p\u003e\n\u003cul\u003e\n    \u003cli\u003e\n       \u003ccode\u003e@Override\u003c/code\u003e - adnotacja do sygnalizacji, że metoda pod nią jest przykrywana\n        z klasy bazowej\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003e@Deprecated\u003c/code\u003e - adnotacja do sygnalizacji, że deklaracja jest przestarzała\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003e@SupressWarnings\u003c/code\u003e - adnotacja wstrzymująca generowanie podanych ostrzeżeń kompilatora\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003e@SafeVarargs\u003c/code\u003e - adnotacja metod, które korzystaja w sposób bezpieczny z prametru typu \u003csamp\u003evararg\u003c/samp\u003e\n    \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\nW praktyce korzystania z framworków, szczególnie do tworzenia aplikacji back-endu, korzystanie z andotacji jest nieodłacznym elementem pracy. Są to adnotacje specyficzne dla danego narzędzia i ich poznanie jest konieczne, aby móc korzystać z tego typu narzędzi.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "I-O i NEW I-O",
          "task_list": [
            {
              "name": "Cześć 1",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\nWrite your task text here.\n\u003cbr\u003e\n\u003cbr\u003e\n\u003cdiv class\u003d\"hint\"\u003e\n  You can add hints anywhere in task text. Copy all hint div block and change its content.\n\u003c/div\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 2",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  //put your task here\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\nWrite your task text here.\n\u003cbr\u003e\n\u003cbr\u003e\n\u003cdiv class\u003d\"hint\"\u003e\n  You can add hints anywhere in task text. Copy all hint div block and change its content.\n\u003c/div\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Elementy współbieżności",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.awt.*;\nimport java.util.concurrent.ArrayBlockingQueue;\n\nclass MagicBox{\n  private ArrayBlockingQueue\u003cInteger\u003e monitor \u003d new ArrayBlockingQueue\u003c\u003e(1);\n  private Rectangle border;\n\n  public MagicBox(Rectangle rect){\n    this.border \u003d rect;\n  }\n\n  public void enter(int n) throws InterruptedException {\n    monitor.put(1);\n    System.out.println(\"Kulka nr \"+n + \" wchodzi do środka\");\n  }\n\n  public void exit(int n) throws InterruptedException {\n    monitor.take();\n    System.out.println(\"Kulka nr \" + n + \" wychodzi ze środka\");\n  }\n\n  public boolean isInside(int x, int y){\n    return border.contains(x, y);\n  }\n}\n\nclass Ball implements Runnable{\n  private int x, y;\n  private boolean isRunning \u003d true;\n  private MagicBox box;\n  private boolean isInside \u003d false;\n  private int number;\n\n  public Ball(MagicBox box, int number){\n    this.box \u003d box;\n    this.number \u003d number;\n  }\n  @Override\n  public void run() {\n    while (isRunning){\n      x \u003d (int)(11*Math.random());\n      y \u003d (int)(11*Math.random());\n      try {\n        if (box.isInside(x, y) \u0026\u0026 !isInside) {\n          System.out.println(\"Kulka nr \" + number +\" chce wejść do środka\");\n          box.enter(number);\n          isInside \u003d true;\n        }\n        if (!box.isInside(x, y) \u0026\u0026 isInside) {\n          box.exit(number);\n          isInside \u003d false;\n        }\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n      }\n      System.out.println(\"Kulka nr \" + number +\" \"+x+\" \"+y);\n    }\n  }\n\n  public void stop(){\n    isRunning \u003d false;\n  }\n}\n\npublic class Task {\n\n  public static void main(String[] args) {\n    MagicBox box \u003d new MagicBox(new Rectangle(10,10));\n    Thread[] balls \u003d new Thread[10];\n    for (int i \u003d 0; i \u003c balls.length; i++){\n      balls[i] \u003d new Thread(new Ball(box, i+1));\n      balls[i].start();\n    }\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003cH1\u003eWstęp\u003c/H1\u003e\n\u003cp\u003eWspółbieżność oznacza wykonywanie co najmniej dwóch ciągów instrukcji w tym samym czasie. Jeśli\nciągi instrukcji wykonywane są w tym samym programie, to każdy z ciągów jest wątkiem. Jeśli wątki nie zawierają instrukcji, które wpływają na działanie pozostałych wątków, to wątki wykonują się równolegle. Gdy część instrukcji wątku może wpłynąć na działanie pozostałych wątków do wątki wykonują się konkurecyjnie.\u003c/p\u003e\n\u003cp\u003eWspółbieżność konkurencyjną można porównać do torów i pociągów. Tor to ciąg instrukcji wątku, pociąg to\naktualnie wykonywana instrukcja wątku. Jeśli dwa tory łączą się ze sobą na pewnym odcinku, to oba pociągi będą musiały ten odcinek przejechać. Może wtedy dojść do kolizji, gdy oba pociągi znajdą się dokładnie tuż przed\nwjazdem na wspólny odcinek. Aby zapewnić bezpieczeństwo trzeba tak zorganizować jazdę obu pociągów, aby w czasie przejazsu przez wspólny odcinek, pozostałe nie mogły na ten odcinek wjechać.\n\u003c/p\u003e\nOdpowiednikiem wspólnego odcinka torów jest tzw. sekcja krytyczna wątku, pozostałe instukcje stanowią\ntzw. sekcję lokalną. Zablokowanie możliwości wykonywania sekcji krytycznej przez więcej niż jeden wątek\nnazywane jest wzajemnym wykluczaniem lub synchronizowaniem.\n\u003c/p\u003e\n\u003cp\u003e\n  Współbieżność może być różnie realizowana: wątki mogą wyć wykonywane w tym samym czasie na różnych procesorach, rdzeniach, mogą być też wykonywane ciągle na tym samym procesorze, który przełącza wykonywane instrukcje\n    kolejnych wątków. Niezależnie od metody realizacji wpsółbieżności zakładamy, że:\n    \u003cul\u003e\n    \u003cli\u003e\n        wątki wykonywane są w przeplocie na jednej maszynie, procesorze, rdzeniu, polegającym na\n        przemiennych wykonywaniu instrukcji należących do różnych wątków\n    \u003c/li\u003e\n    \u003cli\u003e\n        przeplatane są\n    \u003c/li\u003e\n    \u003cli\u003e\n        wszystkie instrukcje wątków trwają tyle samo,\n    \u003c/li\u003e\n    \u003cli\u003e\n        nic nie wiemy o kolejności przeplatanych instrukcji, ale zakładamy uczciwość przeplotu co\n        znaczy, że każdy wątek kiedyś wykona swój kod.\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n  Najczęściej sekcję krytyczną stanowią te fragmenty wątków, które odnoszą się do wspólnego zasobu. Może\n    to być wspólna zmienna, plik, baza danych, łącze sieciowe itd.\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 2",
              "stepic_id": 0,
              "task_files": {
                "src/RunnableDemo.java": {
                  "name": "src/RunnableDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class MessageRunnable implements Runnable{\n  private int pause;\n  private String message;\n  public MessageRunnable(String message, int pause){\n    this.pause \u003d pause;\n    this.message \u003d message;\n  }\n\n  @Override\n  public void run() {\n    int count \u003d 20;\n    while(count-- \u003e 0){\n      try {\n        Thread.sleep(pause);\n        System.out.println(message);\n      } catch (InterruptedException e) {\n\n      }\n    }\n    System.out.println(\"KONIEC WĄTKU\");\n  }\n}\npublic class RunnableDemo {\n  public static void main(String[] args) {\n    MessageRunnable messageThread \u003d new MessageRunnable(\"UWAGA!!!\", 500);\n    Thread thread1 \u003d new Thread(messageThread);\n    Thread thread2 \u003d new Thread(new MessageRunnable(\"STOP!!!\", 300));\n\n    thread1.start();\n    thread2.start();\n  }\n}\n"
                },
                "src/ThreadDemo.java": {
                  "name": "src/ThreadDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.Scanner;\n\nclass MessageThread extends Thread{\n  private String message;\n  private int pause;\n\n  public MessageThread(String message, int pasue){\n    this.message \u003d message;\n    this.pause \u003d pasue;\n  }\n\n  @Override\n  public void run() {\n    int count \u003d 20;\n    while(count-- \u003e 0){\n      try {\n        Thread.sleep(pause);\n        System.out.println(message);\n      } catch (InterruptedException e) {\n\n      }\n    }\n    System.out.println(\"KONIEC WĄTKU\");\n  }\n}\n\nclass ThreadDemo {\n  public static void main(String[] args) {\n    Scanner scan \u003d new Scanner(System.in);\n    MessageThread thread1 \u003d new MessageThread(\"UWAGA!\", 200);\n    MessageThread thread2 \u003d new MessageThread(\"STOP!\", 300);\n    thread1.start();\n    thread2.start();\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eTworzenie wątków\u003c/h1\u003e\n\u003cp\u003e\nWątki to funkcje, metody. Ponieważ w Java funkcje moga być definiowane tylko w klasach, dlatego wątki będą obiektami z metodą.\n\u003c/p\u003e\n\u003cp\u003e\n    Każdy program w Java posiada co najmniej jeden wątek. Funkcja \u003csamp\u003emain\u003c/samp\u003e wykonywana jest w wątku głównym.\u003c/p\u003e\n\u003cp\u003e\n    Klasą do tworzenia wątków jest \u003csamp\u003eThread\u003c/samp\u003e, która posiada metodę\n    \u003csamp\u003erun\u003c/samp\u003e. W metodzie tej umieszczamy kod, który będzie wykonywany w wątku. Tworząc własny wątek możemy zdefiniować własną klasę dziedziczącą \u003csamp\u003eThread\u003c/samp\u003e, w której należy zdefiniowć metodę \u003csamp\u003erun()\u003c/samp\u003e\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass MessageThread extends Thread{\n  private String message;\n  private int pause;\n\n  public MessageThread(String message, int pasue){\n    this.message \u003d message;\n    this.pause \u003d pasue;\n  }\n\n  @Override\n  public void run() {\n    while(!isInterrupted()){\n      try {\n        Thread.sleep(pause);\n        System.out.println(message);\n      } catch (InterruptedException e) {\n        this.interrupt();\n      }\n    }\n    System.out.println(\"KONIEC WĄTKU\");\n  }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Nasza klasa może posiadać pola czy dodatkowe metody w zakeżności od potrzeb. W przykładzie pole \u003csamp\u003emessage\u003c/samp\u003e przechowuje komunikat, który będzie wyświetlany w odstępach czasu \u003csamp\u003epause\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nTworzenie wątku to utworzenie isntacji nasze klasy, a uruchomienie wątku to wywołanie metody \u003csamp\u003estart()\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nMessageThread thread \u003d new MessageThread(\"UWAGA\", 5000);\nthread.start();\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    W chwili wywołania metody \u003csamp\u003estart()\u003c/samp\u003e następuje uruchomienie wątku i przekazanie sterowania do następnej instrukcji. Jest to zaburzenie dotychczasowych naszych przyzwyczajeń, że następna instrukcja jest wykonywanyna, gdy poprzednia się zakończyła. W tym przypadku wywołanie \u003csamp\u003estart()\u003c/samp\u003e powoduje, że równocześnie wykonywane są instrukcje naszego wątku i instrukcje w wątku, który wywołał metodę \u003csamp\u003estart()\u003c/samp\u003e.\n\u003c/p\u003e\n\u003cp\u003e\nDrugą metodą tworzenia wątków jest definiowanie klas impelmentujących interfejs \u003csamp\u003eRunnable\u003c/samp\u003e, który ma zdefiniowaną metodę \u003csamp\u003erun\u003c/samp\u003e. Nasza klasa będzie zmuszona zaimplementować tę metodę.\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass MessageRunnable implements Runnable{\n  private String message;\n  private int pause;\n\n  public MessageRunnable(String message, int pause){\n    this.message \u003d message;\n    this.pause \u003d pause;\n  }\n\n  @Override\n  public void run() {\n    while(!Thread.currentThread().isInterrupted()){\n      try {\n        Thread.sleep(pause);\n      } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n      }\n      System.out.println(message);\n    }\n    System.out.println(\"KONIEC WĄTKU\");\n  }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Zaletą tego sposobu jest możliwość tworzenia własnych klas wątków, które rozszerzają inne klasy, a nie klasę \u003csamp\u003eThread\u003c/samp\u003e. Ponieważ w takiej klasie nie mamy dostępu do odziedziczonych metod \u003csamp\u003eThread\u003c/samp\u003e, więc musimy korzystać z metod statycznych tej klasy, aby móc wykonać operacje. Metoda \u003csamp\u003eThread.currentThread\u003c/samp\u003e zwraca obiekt bieżącego wątku, w posługując się nim możemy przetestować, czy nastąpiło przerwanie wątku\n\u003c/p\u003e\n\u003cp\u003e\n    Z przedstawionych przykładów wynika, że wątek to metoda, w której najczęściej w pętli wykonujemy ciąg instrukcji\n\u003c/p\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 3",
              "stepic_id": 0,
              "task_files": {
                "src/InterruptDemo.java": {
                  "name": "src/InterruptDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.Scanner;\n\nclass CounterThread extends Thread{\n  private int pause;\n  private int counter;\n  public CounterThread(int pasue){\n    this.pause \u003d pasue;\n    this.counter \u003d 0;\n  }\n\n  @Override\n  public void run() {\n    while(!isInterrupted()){\n      try {\n        Thread.sleep(pause);\n        counter++;\n      } catch (InterruptedException e) {\n        this.interrupt();\n      }\n    }\n    System.out.println(\"KONIEC WĄTKU. STAN LICZNIKA \" + counter);\n  }\n}\n\nclass InterruptDemo {\n  public static void main(String[] args) {\n    CounterThread count1 \u003d new CounterThread(400);\n    CounterThread count2 \u003d new CounterThread(600);\n    count1.start();\n    count2.start();\n    Scanner scan \u003d new Scanner(System.in);\n    System.out.println(\"Wpisz cokolwiek, żeby zakończyć program\");\n    String query \u003d scan.next();\n    count1.interrupt();\n    count2.interrupt();\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eKlasa Thread\u003c/h1\u003e\n\u003cp\u003eKlasa \u003csamp\u003eThread\u003c/samp\u003e jest klasą bazową do tworzenia wątków. Posiada kilka istotnym metod:\n\u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003egetName()\u003c/code\u003e - zwraca nazwę wątku\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003egetPriority()\u003c/code\u003e - pobiera priorytet wątku\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eisAlive()\u003c/code\u003e - testuje, czy wątek nadal działa\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003ejoin()\u003c/code\u003e - czeka na zakończenie wątku\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003erun()\u003c/code\u003e - metoda zawierająca kod wątku\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003esleep()\u003c/code\u003e - uśpienie wątku na określony argumentem czas\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003estart()\u003c/code\u003e - uruchomienie metody run() jako osobny wątek programu\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003einterrupt()\u003c/code\u003e - wysyła sygnał przerwania wątku\n    \u003c/li\u003e\n    \u003cli\u003e\n        \u003ccode\u003eisInterrupted()\u003c/code\u003e - wysyła sygnał przerwania wątku\n    \u003c/li\u003e\n\u003c/ul\u003e\u003c/p\u003e\n\u003cp\u003e\n    Gdy tworzymy wątek implementując interfejs \u003csamp\u003eRunnable\u003c/samp\u003e mżemy uzyskać dostęp do bieżącego wątku metodą statyczną klasy:\n    \u003cul\u003e\n    \u003cli\u003e\n        \u003ccode\u003eThread.CurrentThread()\u003c/code\u003e - zwraca bieżący wątek, czyli wątek, w którym została wywołana\n    \u003c/li\u003e\n\u003c/ul\u003e\nMając referencję do obiektu klasy \u003csamp\u003eThread\u003c/samp\u003e, możemy korzystać z wymienionych wcześniej metod klasy.\n\u003c/p\u003e\n\u003cp\u003e\n    W większości sytuacji wątki tworzy się w dwóch sytuacjach:\n    \u003cul\u003e\n    \u003cli\u003e\n        Wywołanie jednej długotrwającej akcji np. pobieranie danych z serwera, zapis do pliku, której przerwanie niweczy całe zadanie\n    \u003c/li\u003e\n    \u003cli\u003e\n        Wykonywanie w pętli powtarzalnych operacji, np. obliczeń, których przerwanie nie musi oznaczać utraty efektów dotychczasowej pracy wątku np. przerwanie wątku pozwalana uzyskanie wyników obliczeń z większym błędem.\n    \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/p\u003e\n\u003cp\u003e\n    Gdy wątek wykonuje kod w pętli i jest usypiany, typowym schematem realizacji rutynowego przerwania wątku jest poniższy schemat:\n\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003e\nclass CounterThread extends Thread{\n  private int pause;\n  private int counter;\n\n  public CounterThread(int pasue){\n    this.pause \u003d pasue;\n    this.counter \u003d 0;\n  }\n\n  @Override\n  public void run() {\n    while(!isInterrupted()){\n      try {\n        Thread.sleep(pause);\n        counter++;\n      } catch (InterruptedException e) {\n        this.interrupt();\n      }\n    }\n    System.out.println(\"KONIEC WĄTKU. STAN LICZNIKA \" + counter);\n  }\n}\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Metoda \u003csamp\u003eisInterrupted()\u003c/samp\u003e testuje, czy wysłano sygnał przerwania wątku. Testowanie\n    odbywa się przed wykonaniem kolejnej iteracji pętli, więc wątek zostanie zakończony w przewidywalnym miejscu. Sygnał przerwania może też został wysłany gdy wątek jest uśpiony, dlatego \"usypianie wątku\" musi być wykonywane w bloku \u003csamp\u003etry...catch\u003c/samp\u003eby w razie przerwania zgłosić wyjątek. Wystąpienie wyjątku usuwa sygnał przerwania, więc w obsłudze wyjątku ponawiamy przerwanie, co spowoduje, że przed wykonaniem następnej iteracji zostanie uwzględniony.\n\u003c/p\u003e\n\u003cp\u003e\nW utworzonym wątku zatrzymanie go w wybranym momencie polega na wywołaniu metody \u003csamp\u003einterrupt()\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nCounterThread thread \u003d new CounterThread(600);\nthread.start();\n...\nthread.interrupt();\n    \u003c/code\u003e\n\u003c/pre\u003e\n\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 4",
              "stepic_id": 0,
              "task_files": {
                "src/MethodSynchronizedDemo.java": {
                  "name": "src/MethodSynchronizedDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.Scanner;\nclass CounterSynchronized{\n  private int counter\u003d0;\n\n  public synchronized void set(int c) {\n    counter \u003d c;\n  }\n\n  public synchronized int get(){\n    return counter;\n  }\n}\n\n\nclass CounterThreadS extends Thread{\n  private CounterSynchronized commonCounter;\n  private int counter \u003d 0;\n\n  public CounterThreadS(CounterSynchronized counter){\n    this.commonCounter \u003d counter;\n\n  }\n\n  @Override\n  public void run() {\n    while(!isInterrupted()){\n      try {\n        Thread.sleep(10);\n        commonCounter.set(commonCounter.get()+1);\n        counter++;\n      } catch (InterruptedException e) {\n        this.interrupt();\n      }\n    }\n    System.out.println(\"KONIEC WĄTKU. STAN LICZNIKA \" + counter);\n  }\n\n  public int get(){\n    return counter;\n  }\n}\n\nclass MethodSynchronizedDemo {\n  public static void main(String[] args) {\n    Counter count \u003d new Counter();\n    CounterThread count1 \u003d new CounterThread(count);\n    CounterThread count2 \u003d new CounterThread(count);\n    count1.start();\n    count2.start();\n    Scanner scan \u003d new Scanner(System.in);\n    System.out.println(\"Wpisz cokolwiek, żeby zakończyć program\");\n    String query \u003d scan.next();\n    count1.interrupt();\n    count2.interrupt();\n    System.out.println(count.get() + \" \u003d \"+ (count1.get()+count2.get()));\n  }\n}"
                },
                "src/NotSynchronizedDemo.java": {
                  "name": "src/NotSynchronizedDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.Scanner;\n\nclass CounterNotSynchronized{\n  private int counter\u003d0;\n\n  public void set(int c){\n    counter \u003d c;\n  }\n\n  public int get(){\n    return counter;\n  }\n}\n\n\nclass CounterThreadNotSynchronized extends Thread{\n  private CounterNotSynchronized commonCounter;\n  private int counter \u003d 0;\n\n  public CounterThreadNotSynchronized(CounterNotSynchronized counter){\n    this.commonCounter \u003d counter;\n\n  }\n\n  @Override\n  public void run() {\n    while(!isInterrupted()){\n      try {\n        Thread.sleep(10);\n        commonCounter.set(commonCounter.get() + 1);\n        counter++;\n      } catch (InterruptedException e) {\n        this.interrupt();\n      }\n    }\n    System.out.println(\"KONIEC WĄTKU. STAN LICZNIKA \" + counter);\n  }\n\n  public int get(){\n    return counter;\n  }\n}\n\nclass NotSynchronizedDemo {\n  public static void main(String[] args) {\n    CounterNotSynchronized count \u003d new CounterNotSynchronized();\n    CounterThreadNotSynchronized count1 \u003d new CounterThreadNotSynchronized(count);\n    CounterThreadNotSynchronized count2 \u003d new CounterThreadNotSynchronized(count);\n    count1.start();\n    count2.start();\n    Scanner scan \u003d new Scanner(System.in);\n    System.out.println(\"Wpisz cokolwiek, żeby zakończyć program\");\n    String query \u003d scan.next();\n    count1.interrupt();\n    count2.interrupt();\n    System.out.println(count.get() + \" \u003d \"+ (count1.get()+count2.get()));\n  }\n}"
                },
                "src/SynchronizedDemo.java": {
                  "name": "src/SynchronizedDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.Scanner;\nclass Counter{\n  private int counter\u003d0;\n\n  public void set(int c){\n    counter \u003d c;\n  }\n\n  public int get(){\n    return counter;\n  }\n}\n\n\nclass CounterThread extends Thread{\n  private Counter commonCounter;\n  private int counter \u003d 0;\n\n  public CounterThread(Counter counter){\n    this.commonCounter \u003d counter;\n\n  }\n\n  @Override\n  public void run() {\n    while(!isInterrupted()){\n      try {\n        Thread.sleep(10);\n        synchronized(commonCounter){\n          commonCounter.set(commonCounter.get()+1);\n        }\n        counter++;\n      } catch (InterruptedException e) {\n        this.interrupt();\n      }\n    }\n    System.out.println(\"KONIEC WĄTKU. STAN LICZNIKA \" + counter);\n  }\n\n  public int get(){\n    return counter;\n  }\n}\n\nclass InterruptDemo {\n  public static void main(String[] args) {\n    Counter count \u003d new Counter();\n    CounterThread count1 \u003d new CounterThread(count);\n    CounterThread count2 \u003d new CounterThread(count);\n    count1.start();\n    count2.start();\n    Scanner scan \u003d new Scanner(System.in);\n    System.out.println(\"Wpisz cokolwiek, żeby zakończyć program\");\n    String query \u003d scan.next();\n    count1.interrupt();\n    count2.interrupt();\n    System.out.println(count.get() + \" \u003d \"+ (count1.get()+count2.get()));\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eSynchronizacja\u003c/h1\u003e\n\u003cp\u003eGdy wątki odwołują się do wspólnej zmiennej to następuje sytuacja konkurencji. Ponieważ zmienna może być modyfikowana tylko przez jeden wątek, to drugi musi zostać zablokowany do czasu zkończenia modyfikacji. Wymuszenie, aby wspólny fragment kilku wątków, mógł być wykonywane tylko przez jeden, nazywamy synchronizacją\u003c/p\u003e\n\u003cp\u003e\n    Do synchronizacji służą: blok sychronizowany lub metoda synchronizowana. Popatrzmy na przykład wątków, które modyfikują wspólny licznik klasy \u003csamp\u003eCounter\u003c/samp\u003e\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass CounterThread extends Thread{\n  private Counter commonCounter;\n  private int counter \u003d 0;\n\n  public CounterThread(Counter counter){\n    this.commonCounter \u003d counter;\n\n  }\n\n  @Override\n  public void run() {\n    while(!isInterrupted()){\n      try {\n        Thread.sleep(10);\n        synchronized(commonCounter){\n          commonCounter.set(commonCounter.get()+1);\n        }\n        counter++;\n      } catch (InterruptedException e) {\n        this.interrupt();\n      }\n    }\n    System.out.println(\"KONIEC WĄTKU. STAN LICZNIKA \" + counter);\n  }\n\n  public int get(){\n    return counter;\n  }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n    Argumentem bloku \u003csamp\u003esynchronized\u003c/samp\u003e jest dowolny obiekt, który stanowi rodzaj zamka, blokady. Jeśli argumentem wszystkich wątków tworzonych na podstawie klasy CounterThread będzie ten sam obiekt \u003csamp\u003ecommonCounter\u003c/samp\u003e, to gdyby kilka wątków w tym czasie próbowało modyfikować ten obiekt, to w chwili gdy któryś wątek zajął już naszą blokadę, to pozostałe wątki zostaną wstrzymane. To gwarantuje,\n    że każda modyfikacja wspólnej zmiennej zostanie wykonana poprawnie, i stan wspólnego licznika będzie równy sumie\n    liczników obu wątków.\n\u003c/p\u003e\n\u003cp\u003e\n    Gdy usuniemy blok synchronizowany w kodzie wątku to łatwo się przekonać, że nastąpi różnica między stanem licznika wspólnego i sumą liczników obu wątków.\n\u003c/p\u003e\n\u003cp\u003e\n    Sytuację co się dzieje, gdy dwa wątki wykonnują ten sam krytyczny fragment w tym samym czasie przy braku synchronizacji, ilustruje poniższe zestawienie\n\u003c/p\u003e\n\u003cpre\u003e\ncount1 \u003d 2                                  count2 \u003d 3\nthread1                                     thread2\nx1 \u003d commonCounter.get()   [5]              x2 \u003d commonCounter.get()    [5]\nx1 \u003d x1 + 1                [6]              x2 \u003d x2 + 1                 [6]\ncommonCounter.set(x1)      [6]              commonCounter.set(x2)       [6]\ncount1 \u003d 3                                  count2 \u003d 4\nrzeczywisty stan licznika - 6\npowinno być               - count1 + count2 \u003d 7\n\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            },
            {
              "name": "Część 5",
              "stepic_id": 0,
              "task_files": {
                "src/CallableDemo.java": {
                  "name": "src/CallableDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.concurrent.*;\n\nclass Calculator implements Callable\u003cDouble\u003e {\n\n  @Override\n  public Double call() throws Exception {\n    double result \u003d 0;\n    int N \u003d 10000000;\n    for (int i \u003d 0; i \u003c N; i++){\n      result +\u003d Math.random();\n    }\n    return result/N;\n  }\n}\n\npublic class CallableDemo {\n  public static void main(String[] args) {\n\n    ExecutorService threadManager \u003d Executors.newFixedThreadPool(2);\n    Future\u003cDouble\u003e result1 \u003d threadManager.submit(new Calculator());\n    Future\u003cDouble\u003e result2 \u003d threadManager.submit(new Calculator());\n    threadManager.submit(new Runnable() {\n      @Override\n      public void run() {\n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n        System.out.println(\"END OF THREAD\");\n      }\n    });\n    try {\n      System.out.println(result1.get());\n      System.out.println(result2.get());\n      threadManager.shutdown();\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    } catch (ExecutionException e) {\n      e.printStackTrace();\n    }\n  }\n}\n"
                },
                "src/ExecutorDemo.java": {
                  "name": "src/ExecutorDemo.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "import java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nclass Task implements Runnable{\n  int n;\n  public Task(int n){\n    this.n \u003d n;\n  }\n\n  @Override\n  public void run() {\n    try {\n      for (int i \u003d 0; i \u003c 5; i++) {\n        Thread.sleep(200);\n        System.out.println(\" THREAD \" + n + \" ITERATION \"+ i);\n      }\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n    System.out.println(\"END OF THREAD \"+n);\n  }\n}\n\nclass ExecutorDemo {\n  public static void main(String[] args) {\n    ExecutorService threadManager \u003d Executors.newFixedThreadPool(2);\n    System.out.println(\"START\");\n    threadManager.submit(new Thread(new Task(1)));\n    threadManager.submit(new Thread(new Task(2)));\n    threadManager.submit(new Thread(new Task(3)));\n    threadManager.submit(new Thread(new Task(4)));\n    threadManager.shutdown();\n    while(!threadManager.isShutdown()){\n      System.out.println(\"RUNNING\");\n    }\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\n\u003ch1\u003eEgzekutory\u003c/h1\u003e\n\u003cp\u003e\n    To obiekty służące do zarządzaniem i uruchamianiem wątków. Przykład poniżej ilustruje jak utworzyć ezgekutor i korzystać z niego:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\n ExecutorService threadManager \u003d Executors.newFixedThreadPool(2);\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nUtworzony obiekt zarządza pulą składającą się dokładnie z dwóch wątków. Wielkość puli określa ile wątków jednocześnie zostanie uruchomionych. Gdy egzekutorowi przekazane zostaną cztery wątki to po wykonaniu dwóch pierwszych uruchomione zostaną dwa kolejne. Uruchomienie wątków wykonuje się metodą \u003csamp\u003esubmit(0\u003c/samp\u003e, a zakończenie pracy ezgekutora po wywołaniu \u003csamp\u003eshutdown()\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\n threadManager.submit(new Runnable() {\n  @Override\n  public void run() {\n    try {\n      Thread.sleep(1000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n    System.out.println(\"END OF THREAD\");\n  }\n});\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nW pliku ExecutorDemo zawarto przykład wykorzystania ezgekutor, a różnicę pracy można zauważyć zmieniając wilekość jego puli.\n\u003c/p\u003e\n\u003ch1\u003eKlasa Callable\u003c/h1\u003e\n\u003cp\u003e\n    Gdy wątek ma działanie funkcyjne, czyli po wykonaniu ma zwrócić jakąś wartość, obiekt, dorbrym rozwiązaniem jest wykorzystanie klasy \u003csamp\u003eCallable\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nclass Calculator implements Callable\u0026lt;Double\u0026gt; {\n\n  @Override\n  public Double call() throws Exception {\n    double result \u003d 0;\n    int N \u003d 100000000;\n    for (int i \u003d 0; i \u003c N; i++){\n      result +\u003d Math.random();\n    }\n    return result/N;\n  }\n}\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\n  Wartość obliczoną przez wątek przekazuje sie obiektu klasy parametrycznej \u003csamp\u003eFuture\u003c/samp\u003e:\n\u003c/p\u003e\n\u003cpre\u003e\n    \u003ccode\u003e\nFuture\u0026lt;Double\u0026gt; result1 \u003d threadManager.submit(new Calculator());\n    \u003c/code\u003e\n\u003c/pre\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        },
        {
          "id": 0,
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "title": "Programowanie funkcyjne",
          "task_list": [
            {
              "name": "Część 1",
              "stepic_id": 0,
              "task_files": {
                "src/Task.java": {
                  "name": "src/Task.java",
                  "placeholders": [],
                  "is_visible": true,
                  "text": "class Task {\n  public static void main(String[] args) {\n    int a \u003d -5;\n    int b \u003d -5;\n    int c \u003d -5;\n    int d \u003d -5;\n    if (3*a \u003d\u003d b+c+d \u0026\u0026 3*b \u003d\u003d a+c+d \u0026\u0026 3*c \u003d\u003d a+b+d){\n      System.out.println(\"romb\");\n    } else {\n      System.out.println(\"nie romb\");\n    }\n  }\n}"
                }
              },
              "test_files": {
                "test/Test.java": "public class Test {\n    // put your test here\n}"
              },
              "description_text": "\u003chtml\u003e\nWrite your task text here.\n\u003cbr\u003e\n\u003cbr\u003e\n\u003cdiv class\u003d\"hint\"\u003e\n  You can add hints anywhere in task text. Copy all hint div block and change its content.\n\u003c/div\u003e\n\u003c/html\u003e",
              "description_format": "html",
              "additional_files": {},
              "update_date": "Jan 1, 1970 1:00:00 AM",
              "feedback_link": {
                "link_type": "STEPIK"
              },
              "task_type": "edu"
            }
          ],
          "unit_id": 0
        }
      ],
      "type": "section"
    },
    {
      "id": 0,
      "update_date": "Jan 1, 1970 1:00:00 AM",
      "title": "Edu additional materials",
      "task_list": [
        {
          "name": "Edu additional materials",
          "stepic_id": 0,
          "task_files": {},
          "test_files": {},
          "description_format": "html",
          "additional_files": {
            "build.gradle": {
              "is_visible": false,
              "text": "buildscript {\n    repositories {\n        mavenCentral()\n    }\n}\n\ndef printOutput(def output) {\n    return tasks.create(\"printOutput\") {\n        for (line in output.toString().readLines()) {\n            println \"#educational_plugin\" + line\n        }\n    }\n}\n\nsubprojects {\n    apply plugin: \u0027application\u0027\n    apply plugin: \u0027java\u0027\n\n    sourceCompatibility \u003d 1.8\n\n    repositories {\n        mavenCentral()\n    }\n\n    dependencies {\n        testCompile group: \u0027junit\u0027, name: \u0027junit\u0027, version: \u00274.12\u0027\n    }\n\n    sourceSets {\n        main {\n            java.srcDir \u0027src\u0027\n        }\n        test {\n            java.srcDir \u0027test\u0027\n        }\n    }\n\n    mainClassName \u003d project.hasProperty(\"mainClass\") ? project.getProperty(\"mainClass\") : \"\"\n\n    test {\n        outputs.upToDateWhen { false }\n        afterTest { TestDescriptor test, TestResult result -\u003e\n            if (result.resultType \u003d\u003d TestResult.ResultType.FAILURE) {\n                def message \u003d result.exception?.message ?: \"Wrong answer\"\n                def lines \u003d message.readLines()\n                println \"#educational_plugin FAILED + \" + lines[0]\n                lines[1..-1].forEach { line -\u003e\n                    println \"#educational_plugin\" + line\n                }\n                // we need this to separate output of different tests\n                println\n            }\n        }\n    }\n\n    def runOutput \u003d new ByteArrayOutputStream()\n    tasks.run.setStandardOutput(runOutput)\n    tasks.run.doLast { printOutput(runOutput) }\n}\n\nproject(\u0027:util\u0027) {\n    dependencies {\n        compile group: \u0027junit\u0027, name: \u0027junit\u0027, version: \u00274.12\u0027\n    }\n}\n\nconfigure(subprojects.findAll {it.name !\u003d \u0027util\u0027}) {\n  dependencies {\n    compile project(\u0027:util\u0027).sourceSets.main.output\n    testCompile project(\u0027:util\u0027).sourceSets.test.output\n  }\n}\n\ntask wrapper(type: Wrapper) {\n  gradleVersion \u003d \u00274.8\u0027\n}\n"
            }
          },
          "update_date": "Jan 1, 1970 1:00:00 AM",
          "feedback_link": {
            "link_type": "STEPIK"
          },
          "task_type": "edu"
        }
      ],
      "unit_id": 0,
      "type": "lesson"
    }
  ],
  "version": 8
}